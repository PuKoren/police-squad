<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Skill.Framework</name>
    </assembly>
    <members>
        <member name="T:Skill.Framework.AI.BehaviorParameter">
            <summary>
            Send custom parameter to behaviors
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorParameter.#ctor(System.String,System.Object)">
            <summary>
            Create new instance of BehaviorParameter
            </summary>
            <param name="name">name of parameter</param>
            <param name="value">Value of parameter</param>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorParameter.Name">
            <summary>
            Name of parameter
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorParameter.Value">
            <summary>
            Value of parameter
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorParameterCollection">
            <summary>
            Contains list of parameters
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorParameterCollection.#ctor(Skill.Framework.AI.BehaviorParameter[])">
            <summary>
            Create new instance of BehaviorParameterCollection
            </summary>
            <param name="parameters">array od parameters</param>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorParameterCollection.GetValue(System.String)">
            <summary>
            Retrieves parameter by name
            </summary>
            <param name="parameterName">Name of parameter</param>
            <returns>Parameter</returns>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorParameterCollection.Item(System.String)">
            <summary>
            Retrieves parameter by name
            </summary>
            <param name="parameterName">Name of parameter</param>
            <returns></returns>
        </member>
        <member name="T:Skill.Framework.AI.PrioritySelector">
            <summary>
            On each traversal priority selectors check which child to run in priority order until the first one succeeds or returns that it is running.
            One option is to call the last still running node again during the next behavior tree update. The other option is to always restart traversal
            from the highest priority child and implicitly cancel the last running child behavior if it isn’t chosen immediately again.
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.Composite">
            <summary>
            Defines base class for composit behaviors
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.Behavior">
            <summary>
            Defines base class for all behavior nodes in BehaviorTree
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Behavior.#ctor(System.String,Skill.Framework.AI.BehaviorType)">
            <summary>
            Create an instance of Behavior
            </summary>
            <param name="name">Name of Behavior</param>
            <param name="behaviorType">Type of behavior (specified by subclass)</param>
        </member>
        <member name="M:Skill.Framework.AI.Behavior.Execute(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            handle execution of behavior and call appropriate events
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result of execution</returns>
        </member>
        <member name="M:Skill.Framework.AI.Behavior.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Let subclass implement behaveior
            </summary>
            <param name="status">Status of BehaviorTre</param>
            <returns>Result of behavior</returns>
        </member>
        <member name="M:Skill.Framework.AI.Behavior.ToString">
            <summary>
            Represent Behavior as string
            </summary>
            <returns>String</returns>
        </member>
        <member name="M:Skill.Framework.AI.Behavior.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset (internal use)
            </summary>
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Name">
            <summary>
            Name of Behavior
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Type">
            <summary>
            Type of Behavior
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Result">
            <summary>
            Last ecexution result of behavior - (setter is for internal use - do not change this manually)
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Concurrency">
            <summary>
            Behavior of node when is child of a ConcurrentSelector
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Weight">
            <summary>
            Wheight or chance of behavior when is behavior is child of a RandomSelector
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.IsLeaf">
            <summary>
            Is loaf of tree? 
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.Tag">
            <summary>
            User object data
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Behavior.LastUpdateId">
            <summary>
            Last update id
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Composite.#ctor(System.String)">
            <summary>
            Create an instance of Composite
            </summary>
            <param name="name">Name of behavior node</param>
        </member>
        <member name="M:Skill.Framework.AI.Composite.Add(Skill.Framework.AI.Behavior,Skill.Framework.AI.BehaviorParameterCollection)">
            <summary>
            Add child. Remember to add children in correct priority
            </summary>
            <param name="child">Child behavior node</param>
            <param name="parameters">optional parameters for behavior</param>
        </member>
        <member name="M:Skill.Framework.AI.Composite.Add(Skill.Framework.AI.Behavior)">
            <summary>
            Add child. Remember to add children in correct priority
            </summary>
            <param name="child">Child behavior node</param>        
        </member>
        <member name="M:Skill.Framework.AI.Composite.RemoveAll">
            <summary>
            remove all children
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Composite.Remove(Skill.Framework.AI.Behavior)">
            <summary>
            Remove specified child
            </summary>
            <param name="child">child to remove</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.AI.Composite.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through children
            </summary>
            <returns>enumerator that iterates through children</returns>
        </member>
        <member name="M:Skill.Framework.AI.Composite.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through children
            </summary>
            <returns>enumerator that iterates through children</returns>
        </member>
        <member name="M:Skill.Framework.AI.Composite.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset
            </summary>        
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="M:Skill.Framework.AI.Composite.IsInSequenceChild(Skill.Framework.AI.Behavior,Skill.Framework.AI.Behavior)">
            <summary>
            Checks whether behavior2 is one of next siblings of behavior1
            </summary>
            <param name="behavior1">firsy behavior</param>
            <param name="behavior2">next behavior</param>
            <returns>True if behavior2 is one of next siblings of behavior1, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.AI.Composite.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Composite.RunningChildIndex">
            <summary>
            Index of child that already running and needs to update next frame
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Composite.Item(System.Int32)">
            <summary>
            Access children by index
            </summary>
            <param name="index">Index of children</param>
            <returns>Child at specified index</returns>
        </member>
        <member name="P:Skill.Framework.AI.Composite.ChildCount">
            <summary>
            Retrieves count of children
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.PrioritySelector.#ctor(System.String)">
            <summary>
            Create an instance of PrioritySelector
            </summary>
            <param name="name">Name of Behavior</param>
        </member>
        <member name="M:Skill.Framework.AI.PrioritySelector.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="P:Skill.Framework.AI.PrioritySelector.Priority">
            <summary>
            Behavior of PrioritySelector (default : HighestPriority)
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.PrioritySelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeState.#ctor(System.String)">
            <summary>
            Create an instance of BehaviorTreeState
            </summary>
            <param name="name">Name of Behavior</param>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorType">
            <summary>
            Defines types of behavior nodes in BehaviorTree
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorType.Action">
            <summary>
            Implement an actors or game world status changes.(leaf node) 
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorType.Condition">
            <summary>
            Check that certain actor or game world statuss hold true.(leaf node)
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorType.Decorator">
            <summary>
            Typically have only one child and are used to enforce a certain return status 
            or to implement timers to restrict how often the child will run in a given amount of time
            or how often it can be executed without a pause.(none leaf node)
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorType.Composite">
            <summary>
            Contains childeren and execute them in specific order.(none leaf node)
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorType.ChangeState">
            <summary>
            Change state of behavior tree
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.ChangeState.#ctor(System.String,System.String)">
            <summary>
            Create an instance of Action
            </summary>
            <param name="name">Name of action</param>
            <param name="destinationState">Name of destination state</param>
        </member>
        <member name="M:Skill.Framework.AI.ChangeState.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result of action</returns>
        </member>
        <member name="P:Skill.Framework.AI.ChangeState.DestinationState">
            <summary>
            State
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.CompositeType">
            <summary>
            Defines type of Composite nodes that implemented in this library
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.Sequence">
            <summary>
            run one child to finish after the other. If one or multiple fail the whole sequence fails, too.
            Without a reset or without finishing the last child node a sequence stores the last running child to immediately return to it on the next update.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.Concurrent">
            <summary>
            visit all of their children during each traversal.
            A pre-specified number of children needs to fail to make the concurrent node fail, too.
            Instead of running its child nodes truly in parallel to each other there might be a specific traversal order which can be exploited when adding conditions
            to a concurrent node because an early failing condition prevents its following concurrent siblings from running.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.Random">
            <summary>
            select a random child by chance for execution.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.Priority">
            <summary>
            On each traversal priority selectors check which child to run in priority order until the first one succeeds or returns that it is running.
            One option is to call the last still running node again during the next behavior tree update. The other option is to always restart traversal
            from the highest priority child and implicitly cancel the last running child behavior if it isn’t chosen immediately again.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.Loop">
            <summary>
            Loops are like sequences but they loop around when reaching their last child during their traversal instead of returning to their parent node like sequence node do.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.CompositeType.State">
            <summary>
            State
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.RunningAction">
            <summary>
            Running Action and it's parameters
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.RunningAction.Action">
            <summary>
            Action that is running
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.RunningAction.Parameters">
            <summary>
            Parameters of Action for internal use        
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.RunningActionCollection">
            <summary>
            Defines a collection of actions.
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.#ctor">
            <summary>
            Create an ActionCollection
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.Add(Skill.Framework.AI.Action,Skill.Framework.AI.BehaviorParameterCollection)">
            <summary>
            Add new action to collection
            </summary>
            <param name="action">Action to add</param>
            <param name="parameters"> parameters of action </param>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.Remove(Skill.Framework.AI.Action)">
            <summary>
            Remove specified action from collection
            </summary>
            <param name="action">action to remove</param>
            <returns>True if action removed, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A System.Collections.Generic.IEnumerator;ltAction;gt that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A System.Collections.Generic.IEnumerator &lt; Action &gt; that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.Clear">
            <summary>
            Remove all actions from collection
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.RunningActionCollection.Contains(Skill.Framework.AI.Action)">
            <summary>
            Determines whether the collection contains a specific Action.
            </summary>
            <param name="action">The Action to locate in the collection.</param>
            <returns>true if item is found in the collection; otherwise,false.</returns>
        </member>
        <member name="P:Skill.Framework.AI.RunningActionCollection.Item(System.Int32)">
            <summary>
            Retrieves Actions by index
            </summary>
            <param name="index">Zero based index of action</param>
            <returns>Action at given index</returns>
        </member>
        <member name="P:Skill.Framework.AI.RunningActionCollection.Count">
            <summary>
            Retrieves umber of actions in collection
            </summary>
        </member>
        <member name="T:Skill.Framework.AnimationCurve3D">
            <summary>
            AnimationCurve in 3D space
            </summary>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.MoveKey(System.Int32,Skill.Framework.Keyframe3D)">
            <summary>
            Removes the keyframe at index and inserts key.
            </summary>
            <param name="index">Index of key</param>
            <param name="key">Keyframe to insert</param>
            <returns>Returns the index of the keyframe after moving it.</returns>
            <remarks>
            If a keyframe already exists at /key.time/ the time of the old keyframe's position /key[index].time/ will be used instead. This is the desired behaviour for dragging keyframes in a curve editor.
            </remarks>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.RemoveKey(System.Int32)">
            <summary>
            Removes a key.
            </summary>
            <param name="index"> Index of key</param>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.Evaluate(System.Single)">
            <summary>
            Evaluate the curve at time.
            </summary>
            <param name="time">Time</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.SmoothTangents(System.Int32,System.Single)">
            <summary>
            Smooth the in and out tangents of the keyframe at index.
            </summary>
            <param name="index">Index of key</param>
            <param name="weight">Weight</param>
            <remarks>
            A weight of 0 evens out tangents
            </remarks>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.GetKeys">
            <summary> Retrieves a copy of all keys defined in the animation curve. (Read Only) </summary>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.GetXKeys">
            <summary> Retrieves a copy of all keys defined in the animation curve x axis. (Read Only) </summary>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.GetYKeys">
            <summary> Retrieves a copy of all keys defined in the animation curve y axis. (Read Only) </summary>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.GetZKeys">
            <summary> Retrieves a copy of all keys defined in the animation curve z axis. (Read Only) </summary>
        </member>
        <member name="M:Skill.Framework.AnimationCurve3D.EaseInOut(System.Single,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
            <summary>
            An ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
            </summary>
            <param name="timeStart"></param>
            <param name="valueStart"></param>
            <param name="timeEnd"></param>
            <param name="valueEnd"></param>
            <returns></returns>
        </member>
        <member name="P:Skill.Framework.AnimationCurve3D.Length">
            <summary> The number of keys in the curve. (Read Only) </summary>
        </member>
        <member name="P:Skill.Framework.AnimationCurve3D.PostWrapMode">
            <summary> The behaviour of the animation after the last keyframe. </summary>
        </member>
        <member name="P:Skill.Framework.AnimationCurve3D.PreWrapMode">
            <summary> The behaviour of the animation before the first keyframe. </summary>
        </member>
        <member name="P:Skill.Framework.AnimationCurve3D.Item(System.Int32)">
            <summary> Retrieves the key at index. (Read Only) </summary>
            <param name="index">Index of key</param>
            <returns>Key</returns>
        </member>
        <member name="T:Skill.Framework.Keyframe3D">
            <summary>
            Keyframe in 3D space
            </summary>
        </member>
        <member name="F:Skill.Framework.Keyframe3D.Time">
            <summary> The time of the keyframe. </summary>
        </member>
        <member name="F:Skill.Framework.Keyframe3D.Value">
            <summary> The value of the curve at keyframe.</summary>
        </member>
        <member name="F:Skill.Framework.Keyframe3D.InTangent">
            <summary> Describes the tangent when approaching this point from the previous point in the curve. </summary>
        </member>
        <member name="F:Skill.Framework.Keyframe3D.OutTangent">
            <summary> Describes the tangent when leaving this point towards the next point in the curve. </summary>
        </member>
        <member name="M:Skill.Framework.Keyframe3D.#ctor">
            <summary>
            Create a Keyframe3D
            </summary>
        </member>
        <member name="M:Skill.Framework.Keyframe3D.#ctor(System.Single,UnityEngine.Vector3)">
            <summary>
            Create a Keyframe3D
            </summary>
            <param name="time">The time of the keyframe.</param>
            <param name="value">The value of the curve at keyframe.</param>
        </member>
        <member name="M:Skill.Framework.Keyframe3D.#ctor(System.Single,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Create a Keyframe3D
            </summary>
            <param name="time">The time of the keyframe.</param>
            <param name="value">The value of the curve at keyframe.</param>
            <param name="inTangent">Describes the tangent when approaching this point from the previous point in the curve.</param>
            <param name="outTangent">Describes the tangent when leaving this point towards the next point in the curve.</param>
        </member>
        <member name="M:Skill.Framework.Keyframe3D.#ctor(Skill.Framework.Keyframe3D)">
            <summary>
            Create a copy of Keyframe3D
            </summary>
            <param name="other">Other Keyframe3D to copy from</param>
        </member>
        <member name="M:Skill.Framework.Keyframe3D.Compare(Skill.Framework.Keyframe3D,Skill.Framework.Keyframe3D)">
            <summary>
            Compare keyframes by time
            </summary>
            <param name="x">Keyframe3D</param>
            <param name="y">Keyframe3D</param>
            <returns></returns>
        </member>
        <member name="T:Skill.Framework.AnimationCurveUtility">
            <summary>
            Static utility class to work around lack of support for Keyframe.tangentMode
            This utility class mimics the functionality that happens behind the scenes in UnityEditor when you manipulate an AnimationCurve. All of this information
            was discovered via .net reflection, and thus relies on reflection to work
            --testure 09/05/2012
            source : http://answers.unity3d.com/questions/313276/undocumented-property-keyframetangentmode.html
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimationTreeState">
            <summary>
            Contains data to send throw AnimNodes at update
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTreeState.#ctor(Skill.Framework.Animation.AnimationTree)">
            <summary>
            Create an instance of AnimationTreeState
            </summary>
            <param name="tree">AnimationTree</param>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTreeState.Tree">
            <summary>
            AnimationTree
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTreeState.Controller">
            <summary>
            The updating controller
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTreeState.ForceUpdate">
            <summary> Force update AnimationTree first time </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeMultilayer">
            <summary>
            base class for AnimNodes that use multiple layers for children
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlendBase">
            <summary>
            Defiens bass class that have children and manage weights of them
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNode">
            <summary>
            Base class for all AnimNodes in AnimationTree
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNode.BecameRelevant">
            <summary>
            Occurs when AnimNode became Relevant
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.OnBecameRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNode.CeaseRelevant">
            <summary>
            Occurs when AnimNode cease Relevant
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.OnCeaseRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNode
            </summary>
            <param name="childCount">Number of childrent</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.Update(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            Update AnimationNode
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.BeginUpdate(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            Perform pre required actions before update
            </summary>
            <param name="state">State of AnimationTree</param>
            <returns>true if update needed, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.Blend">
            <summary>
            subclasses override this method to update weight
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.Destroy">
            <summary>
            Destroy hierarchy of Children
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.GetEnumerator">
            <summary>
             Returns an System.Collections.IEnumerator for the children AnimNodes.
            </summary>
            <returns>Returns an System.Collections.IEnumerator for the children AnimNodes.</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
             Returns an System.Collections.IEnumerator for the children AnimNodes.
            </summary>
            <returns>Returns an System.Collections.IEnumerator for the children AnimNodes.</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.ToString">
            <summary>
            Represent AnimNode as string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNode.SetFormat(System.String)">
            <summary>
            update format of all AnimNodeSequences in tree
            </summary>
            <param name="format">Format</param>        
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.BlendWeight">
            <summary>
            Weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.WeightChange">
            <summary>
            Retrieves weight state of node depend on previous frame
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.ChildCount">
            <summary>
            Retrieves number of children
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.Index">
            <summary>
            Index of node in parent children array
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.Parent">
            <summary> parent node</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.IsRelevant">
            <summary>
            This node is considered 'relevant' - that is, has >0 weight in the final blend.
            </summary> 
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.IsJustBecameRelevant">
            <summary>
            set to true when this node became relevant this round of updates. Will be set to false on the next tick.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.IsJustCeaseRelevant">
            <summary>
            set to true when this node cease relevant this round of updates. Will be set to false on the next tick.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.Name">
            <summary>
            Get of set name of AnimNode
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.CanBlendOutFrom">
            <summary>
            Parent node is requesting a blend out. Give node a chance to delay that.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.CanBlendTo">
            <summary>
            parent node is requesting a blend in. Give node a chance to delay that.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.Item(System.Int32)">
            <summary>
            Get or set chilc AnimNodes by index
            </summary>
            <param name="index">Index of child ( 0 - ChildCount )</param>
            <returns>AnimNode at specified index</returns>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNode.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNode._ChildrenEnumerator">
            <summary>
            custom enumerator to enumerate children of AnimNode
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendBase.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendBase
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendBase.Blend">
            <summary>
            Blend between children
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendBase.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            subclasses should implement this and provide valid weight (0.0 - 0.1) for each child 
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBase.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBase.BlendTime">
            <summary>
            How long to take to get to the blend target.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBase.BlendRate">
            <summary>
            calculate blend base on deltatime
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeMultilayer.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeMultilayer
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeMultilayer.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="T:Skill.Framework.Animation.BlendWeight">
            <summary>
            Weight information
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.BlendWeight.SetBoth(System.Single)">
            <summary>
            Set both Weight and RootMotionWeight in one call
            </summary>
            <param name="value">weight</param>
        </member>
        <member name="P:Skill.Framework.Animation.BlendWeight.Weight">
            <summary>
            Get or set weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.BlendWeight.RootMotion">
            <summary>
            Get or set root motion weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.Vector3Keyframes">
            <summary>
            Defines keyframes for a 3 float component
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.Vector3Keyframes.#ctor(UnityEngine.Keyframe[],UnityEngine.Keyframe[],UnityEngine.Keyframe[])">
            <summary>
            Create a Vector3Keyframes
            </summary>
            <param name="xKeys"> Keyframes for X component </param>
            <param name="yKeys"> Keyframes for Y component </param>
            <param name="zKeys"> Keyframes for Z component </param>
        </member>
        <member name="P:Skill.Framework.Animation.Vector3Keyframes.XKeys">
            <summary> Keyframes for X component </summary>
        </member>
        <member name="P:Skill.Framework.Animation.Vector3Keyframes.YKeys">
            <summary> Keyframes for Y component </summary>
        </member>
        <member name="P:Skill.Framework.Animation.Vector3Keyframes.ZKeys">
            <summary> Keyframes for Z component </summary>
        </member>
        <member name="T:Skill.Framework.Animation.RootMotionState">
            <summary>
            Specify how to update RootMotion
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotionState.PositionX">
            <summary> PositionX is enable or not? </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotionState.PositionY">
            <summary> PositionY is enable or not? </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotionState.PositionZ">
            <summary> PositionZ is enable or not? </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotionState.IsEnable">
            <summary>
            Whether at least one of parameters is enable
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.RootMotion">
            <summary>
            RootMotion of AnimationSequence
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.RootMotion.SetKeyframes(Skill.Framework.Animation.Vector3Keyframes)">
            <summary>
            Set Keyframes
            </summary>
            <param name="keys">Position Keyframes</param>
        </member>
        <member name="M:Skill.Framework.Animation.RootMotion.#ctor(Skill.Framework.Animation.AnimNodeSequence)">
            <summary>
            Create a RootMotion
            </summary>
            <param name="sequence">Owner Sequence</param>
        </member>
        <member name="M:Skill.Framework.Animation.RootMotion.Begin">
            <summary>
            Begin calculatin RootMotion (when Sequence became relevant)
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.RootMotion.End">
            <summary>
            End calculatin RootMotion (when Sequence Cease relevant)
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.RootMotion.Evaluate">
            <summary>
            Evaluate curves and calculate motion between two updates
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotion.Motion">
            <summary> Motion in current update </summary>
        </member>
        <member name="P:Skill.Framework.Animation.RootMotion.State">
            <summary> Whether RootMotion is enable or not? </summary>
        </member>
        <member name="T:Skill.Framework.AvoidScreenSleep">
            <summary>
            for mobile games avoid screen turn off when playing game
            </summary>
        </member>
        <member name="T:Skill.Framework.CameraShake">
            <summary>
            Shakes camera. arrange components in a way that CameraShake component update after camera controller
            </summary>    
        </member>
        <member name="T:Skill.Framework.DynamicBehaviour">
            <summary>
            Defiens basic behaviour for dynamic components
            </summary>
        </member>
        <member name="T:Skill.Framework.StaticBehaviour">
            <summary>
            Defiens basic behaviour for static components
            </summary>
        </member>
        <member name="F:Skill.Framework.StaticBehaviour._Transform">
            <summary> a rederence to transform for better performance</summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.Awake">
            <summary>
            Awake is called when the script instance is being loaded.
            </summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.HookEvents">
            <summary>
            Hook required events if needed
            </summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.UnhookEvents">
            <summary>
            Unhook hooked events 
            </summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.GetReferences">
            <summary>
            Get compoenet references
            </summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.OnDestroy">
            <summary>
            This function is called when the MonoBehaviour will be destroyed.
            </summary>
        </member>
        <member name="M:Skill.Framework.StaticBehaviour.DestroySelf">
            <summary>
            Destroy game object
            </summary>
        </member>
        <member name="P:Skill.Framework.StaticBehaviour.Events">
            <summary> Host events </summary>
        </member>
        <member name="P:Skill.Framework.StaticBehaviour.IsDestroyed">
            <summary> Is GameObject destroyed? </summary>
        </member>
        <member name="M:Skill.Framework.DynamicBehaviour.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.DynamicBehaviour.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.CameraShake.UnhookEvents">
            <summary>
            Unhook hooked events 
            </summary>
        </member>
        <member name="M:Skill.Framework.CameraShake.Shake(Skill.Framework.CameraShakeParams,UnityEngine.Vector3)">
            <summary>
            Shake camera
            </summary>
            <param name="shakeInfo">Parameters of shake</param>
            <param name="sourceOfShake"> source of shake </param>
        </member>
        <member name="M:Skill.Framework.CameraShake.LateUpdate">
            <summary>
            LateUpdate is called every frame, if the Behaviour is enabled.
            </summary>
        </member>
        <member name="T:Skill.Framework.CameraShakeParams">
            <summary>
            Defines basic parameters for shaking camera
            </summary>    
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.Enable">
            <summary> Is shake enable? </summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.Intensity">
            <summary> Intensity of shake
            x in left/right direction 
            y in up/down direction
            z in back/forward (zoom) direction
            </summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.Roll">
            <summary> Intensity of camera roll</summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.Duration">
            <summary> Duration of shake </summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.Range">
            <summary> Max distance to camera. </summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.ByDistance">
            <summary> The shake will be more stronger near to camera </summary>
        </member>
        <member name="F:Skill.Framework.CameraShakeParams.TickTime">
            <summary> time between shake directions </summary>
        </member>
        <member name="M:Skill.Framework.CameraShakeParams.#ctor">
            <summary> Default constructor </summary>
        </member>
        <member name="M:Skill.Framework.CameraShakeParams.#ctor(Skill.Framework.CameraShakeParams)">
            <summary>
            Create a copy of CameraShakeInfo
            </summary>
            <param name="other">Other CameraShakeInfo to copy</param>
        </member>
        <member name="M:Skill.Framework.CameraShakeParams.CopyFrom(Skill.Framework.CameraShakeParams)">
            <summary>
            Copy parameters from another object
            </summary>
            <param name="other">CameraShakeInfo to copy parameters</param>
        </member>
        <member name="T:Skill.Framework.CameraShakeEventArgs">
            <summary>
            containing CameraShake event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.CameraShakeEventArgs.#ctor(Skill.Framework.CameraShakeParams,UnityEngine.Vector3)">
            <summary>
            Create CameraShakeArgs
            </summary>
            <param name="shake"> Shake information </param>
            <param name="source">Source of shake</param>
        </member>
        <member name="P:Skill.Framework.CameraShakeEventArgs.Shake">
            <summary> Shake information </summary>
        </member>
        <member name="P:Skill.Framework.CameraShakeEventArgs.Source">
            <summary> Source position of shake </summary>
        </member>
        <member name="T:Skill.Framework.CameraShakeEventHandler">
            <summary>
            Handle CameraShake
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="args"> a CameraShakeArgs containing shake information </param>
        </member>
        <member name="T:Skill.Framework.CRSpline3D">
            <summary>
            andeeee from the Unity forum's steller Catmull-Rom class ( http://forum.unity3d.com/viewtopic.php?p=218400#218400 ):
            </summary>
        </member>
        <member name="T:Skill.Framework.Path3D">
            <summary>
            base class for path in 3d space
            </summary>
        </member>
        <member name="F:Skill.Framework.Path3D.PostWrapMode">
            <summary> How to evaluate when time exit from range of path </summary>
        </member>
        <member name="F:Skill.Framework.Path3D.PreWrapMode">
            <summary> How to evaluate when time exit from range of path </summary>
        </member>
        <member name="F:Skill.Framework.Path3D.UseWorldSpace">
            <summary> If enabled, the curve are defined in world space.</summary>
        </member>
        <member name="F:Skill.Framework.Path3D.ShowPoints">
            <summary> Show gizmo for control points.</summary>
        </member>
        <member name="F:Skill.Framework.Path3D.SmoothAmount">
            <summary> How to show smooth in editor.</summary>
        </member>
        <member name="F:Skill.Framework.Path3D.Color">
            <summary> color of path in editor.</summary>
        </member>
        <member name="F:Skill.Framework.Path3D.PointRadius">
            <summary> radius of gizmo points.</summary>
        </member>
        <member name="F:Skill.Framework.Path3D.PathTime">
            <summary> use in Editor </summary>
        </member>
        <member name="F:Skill.Framework.Path3D.SelectedIndex">
            <summary> use in Editor </summary>
        </member>
        <member name="M:Skill.Framework.Path3D.GetDirection(System.Single,System.Single)">
            <summary>
            Get direction along path at specified time
            </summary>
            <param name="time">time</param>
            <param name="deltaTime">deltaTime</param>
            <returns>Direction</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.GetDirection(System.Single,System.Single,UnityEngine.Vector3@)">
            <summary>
            Get direction along path at specified time
            </summary>
            <param name="time">time</param>
            <param name="deltaTime">deltaTime</param>    
            <param name="direction">Direction</param>
        </member>
        <member name="M:Skill.Framework.Path3D.Rebuild">
            <summary> Rebuild path after modify keys </summary>
        </member>
        <member name="M:Skill.Framework.Path3D.Evaluate(System.Single)">
            <summary> Evaluate path at specified time </summary>
            <param name="time">time (0 - TimeLength)</param>
            <returns>Evaluated point</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.GetTime(System.Int32)">
            <summary>
            Retrieves time of path at specified point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght - 1)</param>
            <returns>Time</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.GetPoint(System.Int32)">
            <summary>
            Retrieves position of path control point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght - 1)</param>
            <returns>position of path control point</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.CalcDistances(Skill.Framework.Path3D,System.Int32)">
            <summary>
            Calculate distance of path points relative to first point
            </summary>
            <param name="path">Path</param>
            <param name="precision"> precision of calculation</param>
            <returns>distances points relative to first point</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.CalcDeltaDistances(Skill.Framework.Path3D,System.Int32)">
            <summary>
            Calculate distance of path points relative to previous point
            </summary>
            <param name="path">Path</param>
            <param name="precision"> precision of calculation</param>
            <returns>distances points relative to previous point</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.CalcDistance(Skill.Framework.Path3D,System.Single,System.Single,System.Int32)">
            <summary>
            Calculate distance between 2 times in path
            </summary>
            <param name="path">Path</param>
            <param name="startTime">Start time</param>
            <param name="endTime">End time</param>
            <param name="precision"> Precision of calculation</param>
            <returns>distance between 2 times in path</returns>
        </member>
        <member name="M:Skill.Framework.Path3D.CalcPoints(Skill.Framework.Path3D,System.Int32)">
            <summary>
            Caculate points of path in specified resolution
            </summary>
            <param name="path">Path</param>
            <param name="count">number of points</param>
            <returns>calculated points</returns>
        </member>
        <member name="P:Skill.Framework.Path3D.ShowPath">
            <summary> Show lowpoly path in editor(for internal use).</summary>
        </member>
        <member name="P:Skill.Framework.Path3D.Length">
            <summary> Number of keys in path </summary>
        </member>
        <member name="P:Skill.Framework.Path3D.TimeLength">
            <summary> lenght of path in time</summary>
        </member>
        <member name="F:Skill.Framework.CRSpline3D.Keys">
            <summary> Keys of path </summary>
        </member>
        <member name="F:Skill.Framework.CRSpline3D.Times">
            <summary> Times of keys </summary>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.Rebuild">
            <summary> Rebuild path after modify keys </summary>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.Evaluate(System.Single)">
            <summary>
            Evaluate 
            </summary>
            <param name="time"> Time</param>
            <returns>Evaluate position</returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.Evaluate01(System.Single)">
            <summary>
            Evaluate 
            </summary>
            <param name="time"> Time</param>
            <returns>Evaluate position</returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.ConvertToInterpolationTime(System.Single)">
            <summary>
            Convert time to range (0.0f - 1.0f)
            </summary>
            <param name="time">Time</param>
            <returns>time between (0.0f - 1.0f)</returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.GetTime(System.Int32)">
            <summary>
            Retrieves time of path at specified point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght)</param>
            <returns>Time</returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.GetPoint(System.Int32)">
            <summary>
            Retrieves position of path control point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght - 1)</param>
            <returns>position of path control point</returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.Interpolate(UnityEngine.Vector3[],System.Single)">
            <summary>
            Interpolate between points at specified time
            </summary>
            <param name="points">Points</param>
            <param name="time">time (0.0f - 1.0f)</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.CRSpline3D.GeneratorPathControlPoints(UnityEngine.Vector3[])">
            <summary>
            Generate curve points
            </summary>
            <param name="pathPoints">points</param>
            <returns>curve points</returns>
        </member>
        <member name="P:Skill.Framework.CRSpline3D.Length">
            <summary> Number of keys in path </summary>
        </member>
        <member name="P:Skill.Framework.CRSpline3D.TimeLength">
            <summary> lenght of path in time</summary>
        </member>
        <member name="T:Skill.Framework.Curve3D">
            <summary>
            Path3D use tangents
            </summary>
        </member>
        <member name="F:Skill.Framework.Curve3D.ShowInTangent">
            <summary> use in Editor </summary>
        </member>
        <member name="F:Skill.Framework.Curve3D.ShowOutTangent">
            <summary> use in Editor </summary>
        </member>
        <member name="F:Skill.Framework.Curve3D.Keys">
            <summary> Keys of path </summary>
        </member>
        <member name="F:Skill.Framework.Curve3D.SmoothValue">
            <summary> use in Editor </summary>
        </member>
        <member name="M:Skill.Framework.Curve3D.Rebuild">
            <summary> Rebuild path after modify keys </summary>
        </member>
        <member name="M:Skill.Framework.Curve3D.Evaluate(System.Single)">
            <summary> Evaluate path at specified time </summary>
            <param name="time">time (0 - TimeLength)</param>
            <returns>Evaluated point</returns>
        </member>
        <member name="M:Skill.Framework.Curve3D.GetTime(System.Int32)">
            <summary>
            Retrieves time of path at specified point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght)</param>
            <returns>Time</returns>
        </member>
        <member name="M:Skill.Framework.Curve3D.GetPoint(System.Int32)">
            <summary>
            Retrieves position of path control point
            </summary>
            <param name="pointIndex">Index of point (0 - Path.Lenght - 1)</param>
            <returns>position of path control point</returns>
        </member>
        <member name="P:Skill.Framework.Curve3D.TimeLength">
            <summary> lenght of path in time</summary>
        </member>
        <member name="P:Skill.Framework.Curve3D.Length">
            <summary> Number of keys in path </summary>
        </member>
        <member name="T:Skill.Framework.Dynamics.Explosion">
            <summary>
            apply damage to in range objects OnEnable
            </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.Radius">
            <summary> Maximum Damage radius.</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.FalloffRadius">
            <summary> Damage falloff radius.</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.Damage">
            <summary> Amount of damage to apply on affected objects </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.DamageType">
            <summary> Type of damage </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.Force">
            <summary> Apply force to objects </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.ForceMode">
            <summary> ForceMode </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.Offset">
            <summary> Offset of explosion position </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.IgnoreExplision">
            <summary> tags that ignored by explosion</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.IgnoreRaycast">
            <summary> tags that filtered for raycast</summary>
            <remarks>
            for example if a glass be in radius but there was something between glass and explosion as a block, it is not matter, glass will breaks anyway
            and this method should return true for tag == "Glass"
            </remarks>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.IgnoreForce">
            <summary> tags that filtered to apply force</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.UseRaycast">
            <summary> Use raycast to know if any object is between explosion and collider to block explosion </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosion.LayerMask">
            <summary> use raycast to sure there is something between collider and explosion that block explosion</summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosion.OnEnable">
            <summary>
            This function is called when the object becomes enabled and active.
            </summary>
        </member>
        <member name="T:Skill.Framework.Dynamics.MoveAround">
            <summary>
            Move around a circle
            </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.MoveAround.Resolution">
            <summary> Number of points in circle - greater value : smoother circle </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.MoveAround.Period">
            <summary> How long takes each round </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.MoveAround.Radius">
            <summary> Radius of circle </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.MoveAround.StartTime">
            <summary> Start time (0 - Period) </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.MoveAround.ResetTime">
            <summary> Reset timer to start time </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.MoveAround.Move">
            <summary> Start moving around  </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.MoveAround.Stop">
            <summary> Stop moving around  </summary>
        </member>
        <member name="P:Skill.Framework.Dynamics.MoveAround.Center">
            <summary> Center of circle to move around </summary>
            <remarks>
            Modify it at Start
            </remarks>
        </member>
        <member name="P:Skill.Framework.Dynamics.MoveAround.IsMoving">
            <summary> Is moving around center </summary>
        </member>
        <member name="T:Skill.Framework.FollowCamera">
            <summary>
            This camera smoothes out rotation around the y-axis and height.
            Horizontal Distance to the target is always fixed.
            There are many different ways to smooth the rotation but doing it this way gives you a lot of control over how the camera behaves.
            For every of those smoothed values we calculate the wanted value and the current value.
            Then we smooth it using the Lerp function.
            Then we apply the smoothed values to the transform's position.
            </summary>
        </member>
        <member name="F:Skill.Framework.FollowCamera.Target">
            <summary> The target we are following </summary>
        </member>
        <member name="F:Skill.Framework.FollowCamera.Distance">
            <summary> The distance in the x-z plane to the target </summary>
        </member>
        <member name="F:Skill.Framework.FollowCamera.Height">
            <summary> the height we want the camera to be above the target </summary>
        </member>
        <member name="F:Skill.Framework.FollowCamera.HeightDamping">
            <summary> HeightDamping </summary>
        </member>
        <member name="F:Skill.Framework.FollowCamera.RotationDamping">
            <summary> RotationDamping </summary>
        </member>
        <member name="F:Skill.Framework.Modules.BatchMesh.Roots">
            <summary> root of all meshfilter to merge </summary>
        </member>
        <member name="F:Skill.Framework.Modules.BatchMesh.UnitLength">
            <summary> unit length in world space. the space containing meshes seperate to unit squares then mehses inside each square will be merged </summary>
        </member>
        <member name="F:Skill.Framework.Modules.BatchMesh.SeprateByMesh">
            <summary> Sperate by sharedMesh </summary>
        </member>
        <member name="F:Skill.Framework.Modules.BatchMesh.SeprateBySubmesh">
            <summary> Sperate by submesh </summary>
        </member>
        <member name="T:Skill.Framework.Modules.ScreenShot">
            <summary>
            Take screenshots during game
            </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.Directory">
            <summary> Where to save screen shots </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.Shortcut">
            <summary> Combined keys as shortcut to take screenshot </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.CustomSize">
            <summary> Use custom size for shots? </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.Width">
            <summary> Custom width of screenshot </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.Height">
            <summary> Custom height of screenshot </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ScreenShot.Scale">
            <summary> Scale of screenshot relative to screen size </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ScreenShot.GetNewFilePath(System.Int32,System.Int32)">
            <summary>
            Create new png file path to save new screenshot
            </summary>
            <param name="width"> Width of screenshot</param>
            <param name="height"> Height of screenshot</param>
            <returns>new png file path</returns>
        </member>
        <member name="T:Skill.Framework.Modules.ShowFPS">
             <summary>
             Attach this to a GUIText to make a frames/second indicator.   
             </summary>
             <remarks>
             It calculates frames/second over each updateInterval,
             so the display does not keep changing wildly.
            
             It is also fairly accurate at very low FPS counts (less than 10).
             We do this not by simply counting frames per interval, but
             by accumulating FPS for each frame. This way we end up with
             correct overall FPS even if the interval renders something like
             5.5 frames.
             </remarks>
        </member>
        <member name="F:Skill.Framework.Modules.ShowFPS.UpdateInterval">
            <summary> </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ShowFPS.Format">
            <summary> Format of fps text </summary>
        </member>
        <member name="F:Skill.Framework.Modules.ShowFPS.MaterialColor">
            <summary> Change material.color depending of fps </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShowFPS.GetReferences">
            <summary>
            Get required references
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShowFPS.Start">
            <summary>
            Start
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShowFPS.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="T:Skill.Framework.Rendering.UVShift">
            <summary>
            Shift uv. for example tank wheel chain
            </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.UVShift.Parameters">
            <summary> Texture parameters in material shader </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.UVShift.Speed">
            <summary> Speed of shift </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.UVShift.U">
            <summary> Shift U </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.UVShift.V">
            <summary> Shift V </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.UVShift.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.UVShift.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.ITrackKey">
            <summary>
            Base class for a key to use in Matinee
            </summary>
        </member>
        <member name="P:Skill.Framework.Sequence.ITrackKey.FireTime">
            <summary> Execution time </summary>
        </member>
        <member name="P:Skill.Framework.Sequence.IPropertyKey`1.ValueKey">
            <summary> Value key</summary>
        </member>
        <member name="F:Skill.Framework.Sequence.BooleanKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.BooleanKey.Value">
            <summary> Value to set </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.Track">
            <summary>
            Base class for all available tracks in Matinee
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.Awake">
            <summary> Awake </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.Evaluate(System.Single)">
            <summary>
            evaluate time relative to previous evaluation
            </summary>
            <param name="time">time to evaluate</param>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.Seek(System.Single)">
            <summary>
            Seek to specific time because Evaluate is continues relative to previous evaluation
            </summary>
            <param name="time">Seek time</param>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.SortKeys">
            <summary>
            Sort keys
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.Stop">
            <summary>
            Stop evaluation
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.Rollback">
            <summary>
            Rollback all changes to start frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Track.FindMaxIndexBeforeTime(System.Array,System.Single)">
            <summary>
            Find index of closest key before specified time 
            </summary>
            <param name="keys">Keys to search inside</param>
            <param name="time">Time to find right before it</param>
            <returns>index of closest key before specified time </returns>
            <remarks>
            Keys must be sorted
            </remarks>    
        </member>
        <member name="P:Skill.Framework.Sequence.Track.Type">
            <summary> Type of Track </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.PropertyTrack`1.DefaultValue">
            <summary>
            Default value before Matinee
            </summary>  
        </member>
        <member name="M:Skill.Framework.Sequence.PropertyTrack`1.Execute(Skill.Framework.Sequence.IPropertyKey{`0})">
            <summary>
            When time is paused but make sure key applied (for curve tracks)
            </summary>
            <param name="key">Key to Verify</param>
        </member>
        <member name="M:Skill.Framework.Sequence.PropertyTrack`1.Evaluate(Skill.Framework.Sequence.IPropertyKey{`0})">
            <summary>
            When time is paused but make sure key applied (for curve tracks)
            </summary>
            <param name="key">Key to Evaluate</param>
        </member>
        <member name="T:Skill.Framework.Sequence.PlayAnimationEvent">
            <summary>
            Fades the animation with name animation in over a period of time seconds and fades other animations out.
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.EventKey.Fire">
            <summary>Fire event </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.AttachToParent">
            <summary>
            Add this event when you want to manipulate the parent child relationship of two objects.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.WarpToObject">
            <summary>
            Add this event when you need one object to teleport to the location of another.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.PauseOrResumeAudio">
            <summary>
            This event will allow you to Pause or Resume playback on an already playing AudioClip.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.PlayAudio">
            <summary>
            Add this event when you want to play an Audio Clip
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.StopAudio">
            <summary>
             Add this Event when you would like to stop the playback of audio.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.LogMessage">
            <summary>
            Add this event when you would like to write a debug message to the Unity Console.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.ToggleObject">
            <summary>
            Add this event to toggle a GameObject.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.StartStopEmitter">
            <summary>
            Add this event when you would like to start or stop emission a Particle System Emitter.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.Emit">
            <summary>
            Add this event when you would like to Emit a number of particles.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.EmitSingle">
            <summary>
            Add this event when you would like to Emit a single particle with given parameters.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.AddForce">
            <summary>
            Add this event when you need to Apply physical forces to objects in your scene.
            The object that this event applies to must have a rigid body for this event to work.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.AddExplosionForce">
            <summary>
            Add this event when you need to Apply explosion forces to objects in your scene.
            The object that this event applies to must have a rigid body for this event to work.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.AddTorque">
            <summary>
            Add this event when you need to Apply physical torque to objects in your scene.
            The object that this event applies to must have a rigid body for this event to work.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.SendMessage">
            <summary>
            Add this event if you would like to call a function on an object.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.SpawnPrefab">
            <summary>
            Add this event when you would like to dynamically spawn an object.
            </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.ColorKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.ColorKey.Value">
            <summary> Value to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.FloatKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.FloatKey.Value">
            <summary> Value to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.FloatKey.Curve">
            <summary> Value curve </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.IntegerKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.IntegerKey.Value">
            <summary> Value to set </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.Matinee">
            <summary>
            Matinee is a tool for keyframing the properties of Actors in your scene over time, including their position.
            It can also be used to author cinematic sequences in your level.
            </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.StartVisible">
            <summary> Start time of visible area </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.EndVisible">
            <summary> End time of visible area </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.StartSelection">
            <summary> Maximum available time to scroll</summary>    
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.EndSelection">
            <summary> End time of selected time </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.TimePosition">
            <summary> position of time </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.Length">
            <summary> Length of matinee over time</summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.Loop">
            <summary> Is loop? </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.Speed">
            <summary> Playback speed </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Matinee.Cutscene">
            <summary> Is game enters cutscene mode? </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Awake">
            <summary> Awake </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Seek(System.Single)">
            <summary>
            Seek to specific time
            </summary>
            <param name="seekTime">time to seek (0 - Length)</param>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Stop(System.Boolean)">
            <summary> Stop playing Matinee </summary>
            <param name="rollBack">RollBack to start frame?</param>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Play">
            <summary> Start playing matinee from curret(seek) time </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Pause">
            <summary> Pause playback of matinee </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.Matinee.Update">
            <summary> Update </summary>
        </member>
        <member name="P:Skill.Framework.Sequence.Matinee.IsPlaying">
            <summary> Is Matinee playing? </summary>
        </member>
        <member name="P:Skill.Framework.Sequence.Matinee.IsPaused">
            <summary> Is Matinee paused? </summary>
        </member>
        <member name="E:Skill.Framework.Sequence.Matinee.PlaybackChanged">
            <summary>
            Occurs when matinee play/pause or stoppped.
            </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.QuaternionKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.QuaternionKey.Value">
            <summary> Value to set </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.SoundKey">
            <summary>
            Sound key data
            </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.SoundKey.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.SoundKey.Clip">
            <summary> Clip to play </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.SoundKey.VolumeFactor">
            <summary> Volume factor </summary>   
        </member>
        <member name="P:Skill.Framework.Sequence.SoundKey.FireTime">
            <summary> Execution Time </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.TrackType">
            <summary>
            Defines types of all available tracks in Matinee
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.TrackGroup">
            <summary>
            Group of tracks in Matinee
            </summary>
        </member>
        <member name="T:Skill.Framework.Sequence.TrackKeyComparer`1">
            <summary>
            Comparer for ITrackKey to sort them based on ExecutionTime
            </summary>
        </member>
        <member name="M:Skill.Framework.Sequence.TrackKeyComparer`1.Compare(`0,`0)">
            <summary>
            Compare two ITrackKey based on ExecutionTime
            </summary>
            <param name="x">ITrackKey</param>
            <param name="y">ITrackKey</param>
            <returns>x relative to y</returns>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector2Key.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector2Key.Value">
            <summary> Value to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector3Key.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector3Key.Value">
            <summary> Value to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector4Key.Time">
            <summary> time to set </summary>
        </member>
        <member name="F:Skill.Framework.Sequence.Vector4Key.Value">
            <summary> Value to set </summary>
        </member>
        <member name="T:Skill.Framework.Triggers.IsometricCameraMotionTrigger">
            <summary>
            Trigger to change IsometricCamera
            </summary> 
        </member>
        <member name="T:Skill.Framework.Triggers.Trigger">
            <summary>
            Base class for all triggers
            </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.Trigger.Tags">
            <summary> Filter other colliders by tags </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.Trigger.TriggerCount">
            <summary> How many times execute trigger</summary>
        </member>
        <member name="F:Skill.Framework.Triggers.Trigger.Unlimite">
            <summary> Execution of trigger is unlimited</summary>
        </member>
        <member name="M:Skill.Framework.Triggers.Trigger.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.Trigger.OnEnter(UnityEngine.Collider)">
            <summary>
            called when the Collider other enters the trigger.
            </summary>        
            <param name="other">other Collider</param>
            <returns>True if event handled, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Triggers.Trigger.OnExit(UnityEngine.Collider)">
            <summary>
            called when the Collider other has stopped touching the trigger.
            </summary>
            <param name="other">other Collider</param>        
        </member>
        <member name="M:Skill.Framework.Triggers.Trigger.OnStay(UnityEngine.Collider)">
            <summary>
            called almost all the frames for every Collider other that is touching the trigger.
            </summary>
            <param name="other">other Collider</param>        
        </member>
        <member name="M:Skill.Framework.Triggers.Trigger.OnDrawGizmos">
            <summary>
            Draw gizmo
            </summary>
        </member>
        <member name="P:Skill.Framework.Triggers.Trigger.GizmoFilename">
            <summary>
            Name of file in Gizmos folder 
            </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.Motion">
            <summary> reference to IsometricCameraMotion attached to camera </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.Relative">
            <summary> Apply parameters relative to current parameters of camera or set parameters absolutely </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.Fov">
            <summary> faild of view </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.AroundAngle">
            <summary> Rotation angle around target ( 0 - 360) </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.LookAngle">
            <summary> Rotation angle behind target( 0 - 90). 0 is completely horizontal to target and 90 is completely vertical to target. </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.IsometricCameraMotionTrigger.MotionTime">
            <summary> length of motion to reach this values</summary>
        </member>
        <member name="M:Skill.Framework.Triggers.IsometricCameraMotionTrigger.OnEnter(UnityEngine.Collider)">
            <summary>
            On enter trigger
            </summary>
            <param name="other"> other collider</param>
            <returns>true if trigger accepted, otherwise false</returns>
        </member>
        <member name="T:Skill.Framework.UI.Cursor">
            <summary>
            Simple cursor
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Cursor.Normal">
            <summary>
            Cursor texture
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.ProgressBar">
            <summary>
            Simple ProgressBar : use a Box as background and an Image as fill image
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Canvas">
            <summary>    
            Defines an area within which you can explicitly position child elements by
            using coordinates that are relative to the Canvas area.    
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Panel">
            <summary>
            Provides a base class for all Panel elements. Use Panel elements to position and arrange child objects
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.BaseControl">
            <summary>
            Defines base class for all controls
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.IControl">
            <summary>
            Defines Control interface
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.IsEnabled">
            <summary>
            Gets or sets a value indicating whether this element is enabled in the user interface (UI).
            </summary>
            <returns>  true if the element is enabled; otherwise, false. The default value is true. </returns>
        </member>
        <member name="P:Skill.Framework.UI.IControl.Position">
            <summary> Position of control relative to parent </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.X">
            <summary> Gets or sets Position.X </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.Y">
            <summary> Gets or sets Position.Y </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.Width">
            <summary> Gets or sets the suggested width of the element </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.Height">
            <summary> Gets or sets the suggested height of the element. </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.ControlType">
            <summary> Specify type of Control  </summary>
        </member>
        <member name="P:Skill.Framework.UI.IControl.Parent">
            <summary> Parent Panel that host this control.(this value should be setted by parent) </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnPositionChanged">
            <summary>
            when position of control changed 
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnRenderAreaChanged">
            <summary>
            when RenderArea of control changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnLayoutChanged">
            <summary>
            when layout of control changed and parent control needs to update layout of it's children
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnVisibilityChanged">
            <summary>
            when Visibility of control changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseEnter(Skill.Framework.UI.MouseEventArgs)">
            <summary>
            Occurs when mouse enters control (if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseLeave(Skill.Framework.UI.MouseEventArgs)">
            <summary>
            Occurs when mouse leaves control (if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseDown(Skill.Framework.UI.MouseClickEventArgs)">
            <summary>
            Occurs when mouse button was pressed.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseClickEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseUp(Skill.Framework.UI.MouseClickEventArgs)">
            <summary>
            Occurs when mouse button was released.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseClickEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseDrag(Skill.Framework.UI.MouseMoveEventArgs)">
            <summary>
            Occurs when mouse was dragged.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseMoveEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnMouseMove(Skill.Framework.UI.MouseMoveEventArgs)">
            <summary>
            Occurs when mouse was dragged.(if WantsMouseEvents = true)(works only in EditorWindow with set wantsMouseMove true)
            </summary>
            <param name="args"> MouseMoveEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnScrollWheel(Skill.Framework.UI.MouseMoveEventArgs)">
            <summary>
            Occurs when The scroll wheel was moved.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseMoveEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.HandleEvent(UnityEngine.Event)">
            <summary>
            Check for events
            </summary>
            <remarks>
            this method does not works correct if control is inside ScrollView,
            so for that controls you must check mouse events  inside Render method,
            and to do that set 'IsInScrollView = true'
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.#ctor">
            <summary>
            Create a BaseControl
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.Render">
            <summary> Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.BeginRender">
            <summary> Begin Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.ApplyGUIEnable(System.Boolean)">
            <summary> Make control enabled or disabled</summary>
            <param name="enable">Enabled value</param>        
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.RestoreGUIEnable">
            <summary>
            Restore previous value of GUI enable
            </summary>        
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.OnGUI">
            <summary>
            to render control you have to call this method in OnGUI method of MonoBehavior.(call this for Frame class)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.BringToFront">
            <summary> Attempts to bring this element to front. </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.BringToBack">
            <summary> Attempts to bring this element to back. </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.Contains(UnityEngine.Vector2)">
            <summary>
            Returns true if the x and y components of point is inside RenderArea.
            </summary>
            <param name="point">Mouse position</param>        
            <returns>true if the x and y components of point is inside RenderArea, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>        
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.IsInHierarchy(Skill.Framework.UI.BaseControl)">
            <summary>
            Is control in hierarchy of this control
            </summary>
            <param name="control">control to check</param>
            <returns>true if is in hierarchy, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.GetControlAtPoint(UnityEngine.Vector2)">
            <summary>
            Returns first control that given point is inside
            </summary>
            <param name="point">Point</param>
            <returns>found BaseControl </returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControl.FindInParents``1">
            <summary>
            Find first object of type T in parents
            </summary>
            <typeparam name="T">Type of parent</typeparam>
            <returns>T</returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ScaleFactor">
            <summary> Gets or sets ScaleFactor </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.IsFocusable">
            <summary>
            Indicates whether the element can receive focus.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.IsEnabled">
            <summary>
            Gets or sets a value indicating whether this element is enabled in the user interface (UI).
            </summary>
            <returns>  true if the element is enabled; otherwise, false. The default value is true. </returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Position">
            <summary>
            Position of control relative to parent
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.X">
            <summary>
            Gets or sets Position.X
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Y">
            <summary>
            Gets or sets Position.Y
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Width">
            <summary>
            Gets or sets the suggested width of the element
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Height">
            <summary>
            Gets or sets the suggested height of the element.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.RenderSize">
            <summary> Gets the final render size of this element. </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.LayoutWidth">
            <summary>
            Retrieves Width used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.LayoutHeight">
            <summary>
            Retrieves Height used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ActualWidth">
            <summary> Gets the rendered width of this element. </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ActualHeight">
            <summary> Gets the rendered height of this element. </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Margin">
            <summary> Gets or sets the outer margin of an element.</summary>        
            <returns>
            Provides margin values for the element. The default value is a System.Windows.Thickness with all properties equal to 0 (zero).
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.RenderArea">
            <summary>
            The area that used to render control.
            </summary>
            <remarks>
            if it is child of Scrollview or Group RenderArea is relative, otherwise it is absolute
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Parent">
            <summary> Parent Panel that host this control.(this value should be setted by parent) </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.VerticalAlignment">
            <summary>
            Gets or sets the vertical alignment characteristics applied to this element
            when it is composed within a parent element such as a panel or items control.
            </summary>
            <returns> A vertical alignment setting. The default is VerticalAlignment.Stretch. </returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.HorizontalAlignment">
            <summary>
            Gets or sets the horizontal alignment characteristics applied to this element
            when it is composed within a parent element, such as a panel or items control.
            </summary>
            <returns> A horizontal alignment setting, as a value of the enumeration. The default is HorizontalAlignment.Stretch. </returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Name">
            <summary>
            Name of control. (optional)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Tag">
            <summary>
            The tag of this control.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.UserData">
            <summary>
            User data.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Dock">
            <summary>
            Dock of Control when it is a child of DockPanel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Row">
            <summary>
            Grid.Row when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Column">
            <summary>
            Grid.Column when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.RowSpan">
            <summary>
            Grid.RowSpan when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ColumnSpan">
            <summary>
            Grid.ColumnSpan when it is a child of Grid panel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.Visibility">
            <summary>
            Gets or sets the user interface (UI) visibility of this element.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.OwnerFrame">
            <summary>
            Retrieves Owner frame
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.IsMouseOver">
            <summary>
            Is mouse over the control
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.PositionChanged">
            <summary> Occurs when position of control changed </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.RenderAreaChanged">
            <summary> Occurs when RenderArea of control changed </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.LayoutChanged">
            <summary> Occurs when layout of control changed and parent control needs to update layout of it's children</summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.VisibilityChanged">
            <summary> Occurs when Visibility of control changed </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseEnter">
            <summary> Occurs when mouse enters control.(if WantsMouseEvents = true)</summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseLeave">
            <summary> Occurs when mouse leaves control.(if WantsMouseEvents = true)</summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseDown">
            <summary> Occurs when mouse button was pressed.(if WantsMouseEvents = true)</summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseUp">
            <summary> Occurs when mouse button was released.(if WantsMouseEvents = true) </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseDrag">
            <summary> Occurs when mouse was dragged.(if WantsMouseEvents = true) </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.MouseMove">
            <summary> Occurs when mouse was dragged.(if WantsMouseEvents = true)(works only in EditorWindow with set wantsMouseMove true) </summary>
        </member>
        <member name="E:Skill.Framework.UI.BaseControl.ScrollWheel">
            <summary> Occurs when The scroll wheel was moved.(if WantsMouseEvents = true) </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.WantsMouseEvents">
            <summary> check mouse events? (MouseDown, MouseUp, MouseDrag, MouseMove, ScrollWheel) </summary>        
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.IsInScrollView">
            <summary> if control is renderd inside a scrollview then HandleEvent must called inside Render method</summary>        
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.IsHandlingEventInternal">
            <summary>
            Is handle event called inside render method
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ContextMenu">
            <summary> ContextMenu </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControl.ControlType">
            <summary> Specify type of Control  </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.RequestUpdateLayout">
            <summary>
            used by inherited objets to request UpdateLayout
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.#ctor">
            <summary>
            Create a panel
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.OnRenderAreaChanged">
            <summary>
            When RenderArea changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.OnLayoutChanged">
            <summary>
            When Layout changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.BeginRender">
            <summary>
            Prepare for render
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.Render">
            <summary>
            Render child controls
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.Panel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
            <remarks>
            Calling this method has no effect if layout is unchanged, or if neither arrangement nor measurement state of a layout is invalid. 
            However, if layout is invalid in either respect, the UpdateLayout call will redo the entire layout.
            Therefore, you should avoid calling UpdateLayout after each incremental and minor change in the element tree.
            The layout system will perform element layout in a deferred manner, using an algorithm that balances performance and currency, and with a weighting strategy to defer changes to roots until all child elements are valid.
            You should only call UpdateLayout if you absolutely need updated sizes and positions, and only after you are certain that all changes to properties that you control and that may affect layout are completed.
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByName(System.String)">
            <summary>
            Find control in hierarchy with specified name
            </summary>
            <param name="controlName">Name of control to search</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.IsInHierarchy(Skill.Framework.UI.BaseControl)">
            <summary>
            Is control in hierarchy of this control
            </summary>
            <param name="control">control to check</param>
            <returns>true if is in hierarchy, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.GetControlAtPoint(UnityEngine.Vector2)">
            <summary>
            Returns first control that given point is inside
            </summary>
            <param name="point">Point</param>
            <returns>found BaseControl </returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByTabIndex(System.UInt32)">
            <summary>
            Find control in hierarchy with specified tab index
            </summary>
            <param name="tabIndex">Tab index of control to search</param>
            <returns>FocusableControl with specified tab index</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByMaxTabIndex">
            <summary>
            Find control in hierarchy with maximum tab index
            </summary>        
            <returns>FocusableControl with specified tab index</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByMaxTabIndexBefore(System.Int32)">
            <summary>
            Find control in hierarchy with maximum tab index before specified index
            </summary>
            <param name="before">Tab index of control to search</param>
            <returns>FocusableControl with specified tab index</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByMinTabIndex">
            <summary>
            Find control in hierarchy with minimum tab index
            </summary>        
            <returns>FocusableControl with specified tab index</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.FindControlByMinTabIndexAfter(System.Int32)">
            <summary>
            Find control in hierarchy with minimum tab index but greater than specified index
            </summary>
            <param name="tabIndex">Tab index of control to search</param>
            <returns>FocusableControl with specified tab index</returns>
        </member>
        <member name="M:Skill.Framework.UI.Panel.SetControlRenderArea(Skill.Framework.UI.BaseControl,UnityEngine.Rect)">
            <summary>
            calculate RenderArea of Control based on given available Rect
            </summary>
            <param name="c">Control to calc it's RenderArea</param>
            <param name="cellRect">Available space</param>
        </member>
        <member name="M:Skill.Framework.UI.Panel.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command.
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>   
            <remarks>
            let controls that contains mouse position to handle input        
            as soon as first control handled the command ignore next steps
            </remarks>        
        </member>
        <member name="M:Skill.Framework.UI.Panel.HandleEvent(UnityEngine.Event)">
            <summary>
            HandleEvent event
            </summary>
            <param name="e">event to handle</param>
        </member>
        <member name="P:Skill.Framework.UI.Panel.ControlType">
            <summary>  Type of Control : Panel </summary>
        </member>
        <member name="P:Skill.Framework.UI.Panel.Padding">
            <summary>
            Gets or sets the padding inside a control.
            </summary>
            <returns>
            The amount of space between the content of a Panel
            and its Margin or Border.
            The default is a thickness of 0 on all four sides.
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.Panel.Controls">
            <summary>
            Gets a BaseControlCollection of child elements of this Panel.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Panel.DesiredSize">
            <summary> The Size needs for all controls </summary>
        </member>
        <member name="P:Skill.Framework.UI.Panel.RenderAreaShrinksByPadding">
            <summary>
            Gets RenderArea that shrinks by Padding.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Canvas.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ProgressBar.OnValueChanged">
            <summary>
            when value of ProgressBar changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ProgressBar.#ctor">
            <summary>
            Create a ProgressBar
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ProgressBar.OnRenderAreaChanged">
            <summary>
            When RenderArea changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ProgressBar.Render">
            <summary>
            Render
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ProgressBar.SetValue(System.Single,System.Single,System.Single)">
            <summary>
            Set value between minimum and maximum
            </summary>
            <param name="min">Minimum value</param>
            <param name="max">Maximum value</param>
            <param name="value">Value between min and max</param>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ProgressBar.FillImage">
            <summary> Texture to use as fill ProgressBar </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ProgressBar.BackgroundStyle">
            <summary> Style to use as background Box of ProgressBar </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.ProgressBar.ValueChanged">
            <summary>
            Occurs when value of ProgressBar changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ProgressBar.Value">
            <summary>
            Value that is shown (0.0f - 1.0f).
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ProgressBar.FillMargin">
            <summary> Margin of fill </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.RoundSidedProgressBar">
            <summary>
            a ProgressBar with round corners at left/right or top/down
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.RoundSidedProgressBar.OnValueChanged">
            <summary>
            when value of ProgressBar changed
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Extended.RoundSidedProgressBar._Value">
            <summary>
            Value to show between 0.0f - 1.0f
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.RoundSidedProgressBar.OnRenderAreaChanged">
            <summary>
            When RenderArea changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.RoundSidedProgressBar.#ctor(UnityEngine.Texture,Skill.Framework.UI.Orientation,System.Single)">
            <summary>
            Create a RoundSidedProgressBar
            </summary>
            <param name="texture">Texture of ProgressBar</param>
            <param name="orientation"> left/right or top/down </param>
            <param name="roundSize">Size of round side in pixel</param>
        </member>
        <member name="M:Skill.Framework.UI.Extended.RoundSidedProgressBar.SetValue(System.Single,System.Single,System.Single)">
            <summary>
            Set value between minimum and maximum
            </summary>
            <param name="min">Minimum value</param>
            <param name="max">Maximum value</param>
            <param name="value">Value between min and max</param>
        </member>
        <member name="E:Skill.Framework.UI.Extended.RoundSidedProgressBar.ValueChanged">
            <summary>
            Occurs when value of ProgressBar changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.RoundSidedProgressBar.Orientation">
            <summary>
            Is corners at left/right or top/down
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.RoundSidedProgressBar.Texture">
            <summary>
            Texture
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.RoundSidedProgressBar.RoundSize">
            <summary>
            Size of round side in pixel
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.FadeScreen">
            <summary>
            Draw a texture on entire screen
            </summary>    
        </member>
        <member name="F:Skill.Framework.UI.FadeScreen.FadeTexture">
            <summary> Texture to draw on screen- usually a black texture </summary>
        </member>
        <member name="F:Skill.Framework.UI.FadeScreen.TintColor">
            <summary> TintColor of texture </summary>
        </member>
        <member name="F:Skill.Framework.UI.FadeScreen.Depth">
            <summary> The sorting depth. </summary>
        </member>
        <member name="M:Skill.Framework.UI.FadeScreen.GetReferences">
            <summary> Get references </summary>
        </member>
        <member name="P:Skill.Framework.UI.FadeScreen.Fading">
            <summary> Fading  component </summary>
        </member>
        <member name="T:Skill.Framework.Fading">
            <summary> Fade in/out  alpha between 0.0f - 1.0f </summary>
        </member>
        <member name="F:Skill.Framework.Fading.FadeInTime">
            <summary> Time to FadeIn  </summary>
        </member>
        <member name="F:Skill.Framework.Fading.FadeOutTime">
            <summary> Time to FadeOut  </summary>
        </member>
        <member name="F:Skill.Framework.Fading.SmoothStep">
            <summary> Use SmoothStep or linear </summary>
        </member>
        <member name="F:Skill.Framework.Fading.FadeInOnAwake">
            <summary> FadeIn on awake  </summary>
        </member>
        <member name="M:Skill.Framework.Fading.Awake">
            <summary> Awake </summary>
        </member>
        <member name="M:Skill.Framework.Fading.Fade">
            <summary> Fadeout and fadein  </summary>
        </member>
        <member name="M:Skill.Framework.Fading.FadeIn(System.Boolean)">
            <summary> FadeIn  </summary>
            <param name="resetAlpha"> Reset alpha or continue from last alpha value </param>
        </member>
        <member name="M:Skill.Framework.Fading.FadeOut(System.Boolean)">
            <summary>  FadeOut </summary>
            <param name="resetAlpha"> Reset alpha or continue from last alpha value </param>
        </member>
        <member name="M:Skill.Framework.Fading.FadeTo(System.Single)">
            <summary>
            Fade to specified alpha
            </summary>
            <param name="alpha">Alpha value to fade to</param>
        </member>
        <member name="M:Skill.Framework.Fading.ApplyAlpha(UnityEngine.Color)">
            <summary> Apply alpha channel to color </summary>
            <param name="color">Color to apply alpha</param>
            <returns>Color</returns>
        </member>
        <member name="M:Skill.Framework.Fading.ApplyAlpha(UnityEngine.Color@)">
            <summary> Apply alpha channel to color </summary>
            <param name="color">Color to apply alpha</param>        
        </member>
        <member name="M:Skill.Framework.Fading.Update">
            <summary> Update </summary>
        </member>
        <member name="P:Skill.Framework.Fading.IsFadeIn">
            <summary> Is in fadein mode  </summary>
        </member>
        <member name="P:Skill.Framework.Fading.IsFadeOut">
            <summary>  Is in fadeout mode </summary>
        </member>
        <member name="P:Skill.Framework.Fading.Alpha">
            <summary> Current alpha between (0.0f - 1.0f)  </summary>
        </member>
        <member name="T:Skill.Framework.UI.GameMenu">
            <summary> Simple game menu that contains MenuFrames. can show on frame at time</summary>
        </member>
        <member name="F:Skill.Framework.UI.GameMenu.Skin">
            <summary> Skin </summary>
        </member>
        <member name="F:Skill.Framework.UI.GameMenu.Depth">
            <summary> The sorting depth. </summary>
        </member>
        <member name="M:Skill.Framework.UI.GameMenu.Start">
            <summary> Start </summary>
        </member>
        <member name="M:Skill.Framework.UI.GameMenu.Show">
            <summary> Show Game Menu </summary>
        </member>
        <member name="M:Skill.Framework.UI.GameMenu.Hide">
            <summary> Hide Game Menu </summary>
        </member>
        <member name="M:Skill.Framework.UI.GameMenu.Update">
            <summary> Update </summary>
        </member>
        <member name="M:Skill.Framework.UI.GameMenu.OnGUI">
            <summary> OnGUI </summary>
        </member>
        <member name="P:Skill.Framework.UI.GameMenu.Menu">
            <summary> Menu </summary>
        </member>
        <member name="P:Skill.Framework.UI.GameMenu.IsVisible">
            <summary> Is GameMenu visible? </summary>
        </member>
        <member name="T:Skill.Framework.Global">
            <summary>
            Provides global variables, events and methods to be shared between all objetcs
            you can name GameObject start with 'A' to be the first object created in scene
            </summary>    
        </member>
        <member name="M:Skill.Framework.Global.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Global.Initialize(Skill.Framework.Dynamics.Explosive)">
            <summary>
            Overriding this allow programmers to modify all instances of Skill.Dynamics.Explosive
            </summary>
            <param name="explosive"> Dynamics.Explosive to initialize </param>
        </member>
        <member name="M:Skill.Framework.Global.CreateSettings">
            <summary>
            Allow subclass to instantiate another custom Settings
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Global.PlayOneShot(UnityEngine.AudioSource,UnityEngine.AudioClip,Skill.Framework.Sounds.SoundCategory)">
            <summary>
            Play sound
            </summary>
            <param name="source">Source of sound</param>
            <param name="clip">Sound to play</param>
            <param name="category">Category of sound</param>
        </member>
        <member name="M:Skill.Framework.Global.RaiseCameraShake(System.Object,Skill.Framework.CameraShakeParams,UnityEngine.Vector3)">
            <summary>
            Notify globla that a CameraShake happened
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="info"> Camera shake information </param>
            <param name="source"> Source of shake </param>
        </member>
        <member name="M:Skill.Framework.Global.RaiseSlowMotion(System.Object,Skill.Framework.SlowMotionInfo)">
            <summary>
            Notify globla that a SlowMotion happened
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="info"> Slow motion information</param>
        </member>
        <member name="M:Skill.Framework.Global.Register(Skill.Framework.IControllerManager)">
            <summary>
            Register an IControllerManager to be notified when Controller start or destroy
            </summary>
            <param name="host">IControllerManager to register</param>
        </member>
        <member name="M:Skill.Framework.Global.UnRegister(Skill.Framework.IControllerManager)">
            <summary>
            UnRegister IControllerManager
            </summary>
            <param name="host">IControllerManager to unregister</param>
        </member>
        <member name="P:Skill.Framework.Global.Instance">
            <summary>
            The only instance of Global object in scene
            </summary>
        </member>
        <member name="P:Skill.Framework.Global.Settings">
            <summary> Settings </summary>
        </member>
        <member name="P:Skill.Framework.Global.IsGamePaused">
            <summary> 
            Static shared variable to allow behaviours know about whether game is paused(PauseMenu is visible) or not.
            update this value value when you pause/resume game, do to PauseMenu or any reasons.
            </summary>
        </member>
        <member name="P:Skill.Framework.Global.CutSceneEnable">
            <summary> 
            Static shared variable to allow behaviours know about whether game is in cutscene mode.
            update this value value when you enter/exist cutscene.
            </summary>
        </member>
        <member name="E:Skill.Framework.Global.CameraShake">
            <summary>
            Occurs when a CameraShake happened
            </summary>
        </member>
        <member name="E:Skill.Framework.Global.SlowMotion">
            <summary>
            Occurs when a SlowMotion happened
            </summary>
        </member>
        <member name="T:Skill.Framework.HealthChangeEventArgs">
            <summary>
            containing HealthChange event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.HealthChangeEventArgs.#ctor(System.Single)">
            <summary>
            Create a HealthChangeEventArgs
            </summary>
            <param name="deltaHealth"> Amount of health change </param>
        </member>
        <member name="P:Skill.Framework.HealthChangeEventArgs.DeltaHealth">
            <summary> Amount of health change </summary>
        </member>
        <member name="T:Skill.Framework.HealthChangeHandler">
            <summary>
            Handle health change
            </summary>
            <param name="sender">The source of event</param>
            <param name="args"> a HealthChangeEventArgs containing HealthChange event data.</param>        
        </member>
        <member name="T:Skill.Framework.Health">
            <summary>
            Defines Health behaviour for gameobject
            </summary>    
        </member>
        <member name="F:Skill.Framework.Health.Decals">
            <summary> Decale objects to spawn on hit( leave it null for no decal). </summary>
        </member>
        <member name="F:Skill.Framework.Health.HitParticles">
            <summary> Particle(like sparkle) to spawn on hit( leave it null for no particle). </summary>
        </member>
        <member name="F:Skill.Framework.Health.DecalOffset">
            <summary> Offset of decale to hit surface </summary>
        </member>
        <member name="F:Skill.Framework.Health.InverseHit">
            <summary> If true, it takes additional raycast to find position of decale with more precision  </summary>
            public bool UseRaycastForDecal = false;
            <summary> True if you want HitParticle spawn at inverse direction of hit normal </summary>
        </member>
        <member name="F:Skill.Framework.Health.MaxHealth">
            <summary> Maximum amount of health (if RegenerateSpeed > 0) </summary>
        </member>
        <member name="F:Skill.Framework.Health.InitialHealth">
            <summary> Initial health value </summary>
        </member>
        <member name="F:Skill.Framework.Health.RegenerateSpeed">
            <summary> The speed of regenerate health after damage.</summary>
        </member>
        <member name="F:Skill.Framework.Health.RegenerateDelay">
            <summary> The delay time before start to regenerate health.</summary>
        </member>
        <member name="F:Skill.Framework.Health.Invincible">
            <summary> If true, never take damage </summary>
        </member>
        <member name="F:Skill.Framework.Health.DieDelay">
            <summary> the time begins when health is zero to delay die </summary>
        </member>
        <member name="M:Skill.Framework.Health.OnHealthChange(System.Single)">
            <summary>
            Occurs when amount of Health changed.
            </summary>
            <param name="deltaHealth"> amount of Health changed. </param>
        </member>
        <member name="M:Skill.Framework.Health.HookEvents">
            <summary>
            Hook required events 
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.UnhookEvents">
            <summary>
            Unhook hooked events
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.Events_Die(System.Object,System.EventArgs)">
            <summary>
            When Health GameObject is dead
            </summary>
            <param name="sender">sender</param>
            <param name="e">EventArgs</param>
        </member>
        <member name="M:Skill.Framework.Health.Restore">
            <summary>
            Restore health to initial values and alive
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.Events_Cached(System.Object,Skill.Framework.Managers.CacheEventArgs)">
            <summary>
            Occurs when health cached by CacheSpawner
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.Awake">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.Events_Hit(System.Object,Skill.Framework.HitEventArgs)">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> sender </param>
            <param name="args"> An HitEventArgs that contains hit event data. </param>        
        </member>
        <member name="M:Skill.Framework.Health.SelectHitParticleToSpawn(Skill.Framework.HitEventArgs)">
            <summary>
            Select HitParticle based on hit. ( default returns random index)
            </summary>
            <returns>Index of HitParticle ( 0 - (HitParticle.Length - 1) ) to spawn</returns>
            <remarks>
            It is possible to spawn hit particles based on incoming bulled. ( normal bullet, Laser bullet, ...)
            Type of hit can be specified by 'HitInfo.UserData', 'HitInfo.HitType' or inherit 'HitInfo' or 'HitEventArgs' class and provide custom data and properties
            </remarks>
        </member>
        <member name="M:Skill.Framework.Health.SelectDecaleToSpawn(Skill.Framework.HitEventArgs)">
            <summary>
            Select Decale based on hit. ( default returns random index)
            </summary>
            <returns>Index of Decale ( 0 - (Decale.Length - 1) ) to spawn</returns>
            <remarks>
            It is possible to spawn decales based on incoming bulled. ( normal bullet, Laser bullet, ...)
            Type of hit can be specified by 'HitInfo.UserData', 'HitInfo.HitType' or inherit 'HitInfo' or 'HitEventArgs' class and provide custom data and properties
            </remarks>
        </member>
        <member name="M:Skill.Framework.Health.Events_Damage(System.Object,Skill.Framework.DamageEventArgs)">
            <summary>
            Handle imposed damage
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> An DamageEventArgs that contains damage event data.</param>
        </member>
        <member name="M:Skill.Framework.Health.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Health.Regenerate">
            <summary>
            Regenerate health
            </summary>
        </member>
        <member name="P:Skill.Framework.Health.CurrentHealth">
            <summary>
            Gets or sets current health value
            </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastCausedDamage">
            <summary> Retrieve last object that caused damage to this health </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastCausedDamageTag">
            <summary> Retrieve tag of last object that caused damage to this health </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastDamage">
            <summary> Amount of last damage </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastHitPoint">
            <summary> Position of last hit </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastHitNormal">
            <summary> Normal of last hit </summary>
        </member>
        <member name="P:Skill.Framework.Health.LastDamageType">
            <summary> type of last damage </summary>
        </member>
        <member name="P:Skill.Framework.Health.IsDead">
            <summary>
            Whether agent is dead or not.
            </summary>
        </member>
        <member name="E:Skill.Framework.Health.HealthChange">
            <summary>
            Occurs when amount of Health changed.
            </summary>
        </member>
        <member name="T:Skill.Framework.HitType">
            <summary>
            Defines types hit
            </summary>
        </member>
        <member name="F:Skill.Framework.HitType.None">
            <summary> None </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Bullet">
            <summary> hit caused by a bullet </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Raycast">
            <summary> hit caused by a raycast </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Collision">
            <summary> hit caused by colliding another object</summary>
        </member>
        <member name="F:Skill.Framework.HitType.Hit1">
            <summary> user define hit 1  </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Hit2">
            <summary> user define hit 2  </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Hit3">
            <summary> user define hit 3  </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Hit4">
            <summary> user define hit 4  </summary>
        </member>
        <member name="F:Skill.Framework.HitType.Hit5">
            <summary> user define hit 5  </summary>
        </member>
        <member name="T:Skill.Framework.HitEventArgs">
            <summary>
            Defines information about when an object hits
            </summary>
        </member>
        <member name="F:Skill.Framework.HitEventArgs.CauseParticle">
            <summary> Whether this hit cause particle on colliding object?</summary>
            <remarks>
            Maybe you don't want an explosion cause to particles spawns.
            </remarks>
        </member>
        <member name="M:Skill.Framework.HitEventArgs.#ctor(UnityEngine.GameObject,Skill.Framework.HitType,UnityEngine.Collider)">
            <summary>
            Create a HitInfo
            </summary>
            <param name="hitter"> The object that caused this hit </param>
            <param name="type"> Type of hit </param>
            <param name="collider"> Collider </param>       
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Type">
            <summary> Type of hit </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Hitter">
            <summary> The object that caused this hit </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Collider">
            <summary> Collider </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.UserData">
            <summary> User data </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.DamageType">
            <summary> Damage Type of projectil</summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Tag">
            <summary> Tag </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Point">
            <summary> Position of hit </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Normal">
            <summary> Normal of hit </summary>
        </member>
        <member name="P:Skill.Framework.HitEventArgs.Damage">
            <summary> Amount of damage imposed by this hit </summary>
        </member>
        <member name="T:Skill.Framework.RaycastHitEventArgs">
            <summary>
            Defines information about when an object hits by raycast
            </summary>
        </member>
        <member name="F:Skill.Framework.RaycastHitEventArgs.RaycastHit">
            <summary>
            Raycast hit information
            </summary>
        </member>
        <member name="M:Skill.Framework.RaycastHitEventArgs.#ctor(UnityEngine.GameObject,Skill.Framework.HitType,UnityEngine.Collider)">
            <summary>
            Create a RaycastHitInfo
            </summary>
            <param name="owner"> The object that caused this hit </param>
            <param name="type"> Type of hit </param>
            <param name="other"> Other collider </param>       
        </member>
        <member name="T:Skill.Framework.CollisionHitEventArgs">
            <summary>
            Defines information about when an object hits by another object
            </summary>
        </member>
        <member name="F:Skill.Framework.CollisionHitEventArgs.CollisionInfo">
            <summary>
            Collision hit information
            </summary>
        </member>
        <member name="M:Skill.Framework.CollisionHitEventArgs.#ctor(UnityEngine.GameObject,Skill.Framework.HitType,UnityEngine.Collider)">
            <summary>
            Create a CollisionHitInfo
            </summary>
            <param name="owner"> The object that caused this hit </param>
            <param name="type"> Type of hit </param>
            <param name="other"> Other collider </param>       
        </member>
        <member name="T:Skill.Framework.DamageEventArgs">
            <summary>
            containing damage event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.DamageEventArgs.#ctor(System.Single)">
            <summary>
            Create DamageEventArgs
            </summary>
            <param name="damage"> Amount of damage </param>        
        </member>
        <member name="P:Skill.Framework.DamageEventArgs.Damage">
            <summary> Amount of damage </summary>
        </member>
        <member name="P:Skill.Framework.DamageEventArgs.Tag">
            <summary> Tag of object that cause damage </summary>
        </member>
        <member name="P:Skill.Framework.DamageEventArgs.UserData">
            <summary> User Data </summary>
        </member>
        <member name="P:Skill.Framework.DamageEventArgs.DamageType">
            <summary> Damage Type of projectil</summary>
        </member>
        <member name="T:Skill.Framework.IBehavioural">
            <summary>
            Behavioural object
            </summary>
        </member>
        <member name="P:Skill.Framework.IBehavioural.Behavior">
            <summary> Behavior </summary>
        </member>
        <member name="T:Skill.Framework.IControllerManager">
            <summary>
            Manage all controllers in game
            </summary>
        </member>
        <member name="M:Skill.Framework.IControllerManager.Register(Skill.Framework.Controller)">
            <summary>
            Notify a Controller started
            </summary>
            <param name="controller">Controller</param>
        </member>
        <member name="M:Skill.Framework.IControllerManager.UnRegister(Skill.Framework.Controller)">
            <summary>
            Notify a Controller destroyed
            </summary>
            <param name="controller">Controller</param>
        </member>
        <member name="T:Skill.Framework.IO.DragGestureEventArgs">
            <summary>
            DragGestureEventArgs 
            </summary>
        </member>
        <member name="T:Skill.Framework.IO.GestureEventArgs">
            <summary>
            Event arguments of GestureDetector 
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[])">
            <summary>
            Create a GestureDetectorEventArgs
            </summary>    
            <param name="fingerCount"> Number of fingers </param>
            <param name="positions">Position of touches when event happened  </param>    
        </member>
        <member name="P:Skill.Framework.IO.GestureEventArgs.Positions">
            <summary> Position of touches when event happened  </summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureEventArgs.FingerCount">
            <summary> Number of fingers </summary>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Create a DragGestureEventArgs
            </summary>    
            <param name="fingerCount"> Number of fingers </param>
            <param name="positions">Position of touches when event happened  </param>  
            <param name="deltaTranslation">Delta translation since last event</param>
            <param name="totalTranslation"> total translation relative to start position  </param>
        </member>
        <member name="P:Skill.Framework.IO.DragGestureEventArgs.DeltaTranslation">
            <summary> Delta translation since last event </summary>
        </member>
        <member name="P:Skill.Framework.IO.DragGestureEventArgs.TotalTranslation">
            <summary> total translation relative to start position </summary>
        </member>
        <member name="T:Skill.Framework.IO.DragGestureEventHandler">
            <summary>
            Handle Drag Gesture events
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.DragGestureDetector">
            <summary>
            Drag gesture detector 
            </summary>
        </member>
        <member name="T:Skill.Framework.IO.LockerGestureDetector">
            <summary>
            Base class for gesture detector that need to lock touches while detecting
            </summary>
        </member>
        <member name="T:Skill.Framework.IO.GestureDetector">
            <summary>
            Base definition of gesture detectors
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.#ctor">
            <summary>
            Create a GestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.Update(Skill.Framework.IO.ITouchStateProvider)">
            <summary>
            Update detector
            </summary>
            <param name="provider">touch provider</param>
            <returns>result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.Reset">
            <summary> Reset detector and unlock all locked touches </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.TouchLocation">
            <summary>
            returns the location of the touches. If there are multiple touches this will return the centroid of the location.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.RemoveInvalidTouches">
            <summary>
            Remove the tracking touches that is no more valid for this detector
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.LockTrackingTouches">
            <summary> Lock tracking touches </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.UnlockTrackingTouches">
            <summary> unLock locked tracking touches by this detector </summary>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.IsAnyTrackingTouchesMoved">
            <summary>
            Is phase of any tracking touches Phase.Moved
            </summary>
            <returns>True if moved, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.IsAnyTrackingTouchesEnded">
            <summary>
            Is phase of any tracking touches Phase.Ended
            </summary>
            <returns>True if ended, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.TrackTouch(Skill.Framework.IO.TouchState)">
            <summary>
            Add given TouchState to list of tracking touches and start track this touch
            </summary>
            <param name="ts">TouchState to track</param>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.GetPositionOfTrackingTouches">
            <summary>
            Retrieves positions of tracking touches
            </summary>
            <returns>positions of tracking touches</returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.GetTrackingToucheByIndex(System.Int32)">
            <summary>
            Retrieve tracking touch by index
            </summary>
            <param name="index">Index of TrackingTouche</param>
            <returns>tracking touch</returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.DistanceBetweenTrackedTouches(System.Int32,System.Int32)">
            <summary>
            Calc distance between two tracking touch
            </summary>
            <param name="touch1">touch 1</param>
            <param name="touch2">touch 2</param>
            <returns> distance between touches </returns>
        </member>
        <member name="M:Skill.Framework.IO.GestureDetector.IsTrackingTouchesValid">
            <summary>
            Is all tracking touches valid for this detector
            </summary>
            <returns>True if valid, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.IsEnabled">
            <summary> Is Detector enabled </summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.BoundaryFrame">
            <summary> Frame that the touch must be within to be recognized. null means full screen. </summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.Priority">
            <summary> Priority of detector</summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.FingerCount">
            <summary> Number of fingers required to detect gesture </summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.LastReslut">
            <summary> Last result of detector </summary>
        </member>
        <member name="P:Skill.Framework.IO.GestureDetector.TrackingToucheCount">
            <summary> Number of tracking touches </summary>
        </member>
        <member name="M:Skill.Framework.IO.LockerGestureDetector.BeginDetection">
            <summary> found number of required touch </summary>
        </member>
        <member name="M:Skill.Framework.IO.LockerGestureDetector.Detection">
            <summary>
            try to detect gestures every frame after begin called
            </summary>
            <returns>Result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.LockerGestureDetector.#ctor">
            <summary>
            Create a LockerGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.LockerGestureDetector.Update(Skill.Framework.IO.ITouchStateProvider)">
            <summary>
            Update detector
            </summary>
            <param name="provider">touch provider</param>
            <returns>result of detection</returns>
        </member>
        <member name="P:Skill.Framework.IO.LockerGestureDetector.LockTouches">
            <summary> Lock touches while detecting? </summary>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.OnDrag">
            <summary> Occurs when a drag gesture event detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.OnDragStart">
            <summary> Occurs when a drag gesture started </summary>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.#ctor">
            <summary>
            Create a DragGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.BeginDetection">
            <summary>
            Begin detection
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.Detection">
            <summary>
            Detection
            </summary>
            <returns>Result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.DragGestureDetector.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.DragGestureDetector.MinimumDrag">
            <summary> Minimum rotation to start detecting </summary>
        </member>
        <member name="E:Skill.Framework.IO.DragGestureDetector.Drag">
            <summary> Occurs when a drag gesture event detected </summary>
        </member>
        <member name="E:Skill.Framework.IO.DragGestureDetector.DragStart">
            <summary> Occurs when a drag gesture started </summary>
        </member>
        <member name="T:Skill.Framework.IO.GestureDetectionResult">
            <summary>
            Result of GestureDetector
            </summary>
        </member>
        <member name="F:Skill.Framework.IO.GestureDetectionResult.None">
            <summary> nothing </summary>
        </member>
        <member name="F:Skill.Framework.IO.GestureDetectionResult.Failed">
            <summary> detector was detecting but failed to complete detection </summary>
        </member>
        <member name="F:Skill.Framework.IO.GestureDetectionResult.Detecting">
            <summary> detector is successfully detecting </summary>
        </member>
        <member name="F:Skill.Framework.IO.GestureDetectionResult.Detected">
            <summary> detector successfully detecting  </summary>
        </member>
        <member name="T:Skill.Framework.IO.GestureEventHandler">
            <summary>
            Handle Gesture events
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.HoldGestureEventArgs">
            <summary>
            HoldGestureEventArgs 
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],System.Single)">
            <summary>
            Create a HoldGestureEventArgs
            </summary>
            <param name="fingerCount">Number of fingers</param>
            <param name="positions"> Position of touches </param>
            <param name="duration"> Duration of hold </param>
        </member>
        <member name="P:Skill.Framework.IO.HoldGestureEventArgs.Duration">
            <summary> Duration of hold </summary>
        </member>
        <member name="T:Skill.Framework.IO.HoldGestureEventHandler">
            <summary>
            Handle Hold Gesture Event
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.HoldGestureDetector">
            <summary>
            Detector for holding touch for specific time
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureDetector.OnHold">
            <summary> Occuers when a hold detected</summary>
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureDetector.#ctor">
            <summary>
            Create aHoldGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureDetector.BeginDetection">
            <summary>
            Begin detection
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureDetector.Detection">
            <summary> detecting gestures </summary>
            <returns>Result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.HoldGestureDetector.Reset">
            <summary>
            Reset detector
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.HoldGestureDetector.Duration">
            <summary> Duration of hold to detect (default = 0.5f) </summary>
        </member>
        <member name="P:Skill.Framework.IO.HoldGestureDetector.AllowableMovement">
            <summary> Movement allowed when holding touch</summary>
        </member>
        <member name="P:Skill.Framework.IO.HoldGestureDetector.FingerCount">
            <summary> Number of fingers</summary>
        </member>
        <member name="E:Skill.Framework.IO.HoldGestureDetector.Hold">
            <summary> Occuers when a hold detected</summary>
        </member>
        <member name="M:Skill.Framework.IO.InputButton.#ctor(System.String,UnityEngine.KeyCode[])">
            <summary>
            Create Button
            </summary>
            <param name="name"> Name of Button </param>
            <param name="keys"> keys that atleast one press required to activate this button. </param>
        </member>
        <member name="P:Skill.Framework.IO.InputButton.Value">
            <summary>
            value (power of 2)
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.InputButton.Name">
            <summary> Name of Button </summary>
        </member>
        <member name="P:Skill.Framework.IO.InputButton.Keys">
            <summary>
            keys that atleast one press required to activate this button.
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.InputButton.IsDirection">
            <summary> Is direction button </summary>
        </member>
        <member name="P:Skill.Framework.IO.InputButton.IsPressed">
            <summary> Is button pressed </summary>
        </member>
        <member name="T:Skill.Framework.IO.InputManager">
            <summary>
            Manage gesture detectors
            </summary>
        </member>
        <member name="T:Skill.Framework.IO.ITouchStateProvider">
            <summary>
            Handles touches and allow gesture detectors to access touches and use them
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.ITouchStateProvider.GetFreeTouches(UnityEngine.TouchPhase,System.Nullable{UnityEngine.Rect})">
            <summary> go throw free and ready for use touches </summary>
            <param name="phase">Phase of free touch</param>
            <param name="boundaryFrame">Boundary frame that touch must be within</param>
            <returns>Free touches</returns>
        </member>
        <member name="F:Skill.Framework.IO.InputManager.MaxTouchesToProcess">
            <summary> Maximum number of touch to process </summary>
        </member>
        <member name="F:Skill.Framework.IO.InputManager.BufferTimeOut">
            <summary>
            This is how long to wait for input before all input data is expired.
            This prevents the player from performing half of a move, waiting, then
            performing the rest of the move after they forgot about the first half.
            </summary>
        </member>
        <member name="F:Skill.Framework.IO.InputManager.MergeInputTime">
            <summary>
            This is the size of the "merge window" for combining button presses that
            occur at almsot the same time.
            If it is too small, players will find it difficult to perform moves which
            require pressing several buttons simultaneously.
            If it is too large, players will find it difficult to perform moves which
            require pressing several buttons in sequence.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Awake">
            <summary> Awake </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Update">
            <summary> Update </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.RearrangeGestureDetectors">
            <summary>
            Call this if you change priority of a GestureDetector after add to InputManager
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Add(Skill.Framework.IO.GestureDetector)">
            <summary>
            Add a GestureDetector
            </summary>
            <param name="detector">GestureDetector to add</param>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Remove(Skill.Framework.IO.GestureDetector)">
            <summary>
            Remove GestureDetector
            </summary>
            <param name="detector">GestureDetector to remove</param>
            <returns>True if removed, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.RemoveAllGestures">
            <summary>
            Remove all GestureDetectors
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.GetFreeTouches(UnityEngine.TouchPhase,System.Nullable{UnityEngine.Rect})">
            <summary>
            enumorate throw touches and retrieves free touches with specified phase
            </summary>
            <param name="phase">Phase of free touch</param>
            <param name="boundaryFrame">Boundary frame (if available)</param>
            <returns>Free Touches</returns>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Add(Skill.Framework.IO.Move)">
            <summary>
            Add a Move
            </summary>
            <param name="move">Move to add</param>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.Remove(Skill.Framework.IO.Move)">
            <summary>
            Remove Move
            </summary>
            <param name="move">Move to remove</param>
            <returns>True if removed, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.RemoveAllMoves">
            <summary>
            Remove all Moves
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.InputManager.CreateButton(System.String,UnityEngine.KeyCode[])">
            <summary>
            Add a Button
            </summary>
            <param name="name">name of button</param>
            <param name="keys">Keys</param>
        </member>
        <member name="P:Skill.Framework.IO.InputManager.Instance">
            <summary> Single instance of Gestures </summary>
        </member>
        <member name="T:Skill.Framework.IO.Move">
            <summary>
            Describes a sequences of buttons which must be pressed to active the move.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.Move.#ctor(System.String,System.Int32[])">
            <summary>
            Create a Move
            </summary>
            <param name="name">Name of move</param>
            <param name="sequence"> The sequence of buttons presses required to activate this move. </param>
        </member>
        <member name="P:Skill.Framework.IO.Move.Name">
            <summary> Name of move </summary>
        </member>
        <member name="P:Skill.Framework.IO.Move.Sequence">
            <summary>
            The sequence of buttons presses required to activate this move.
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.Move.IsSubMove">
            <summary>
            Set this to true if the input used to activate this move may
            be reused as a component of longer moves.
            </summary>
        </member>
        <member name="E:Skill.Framework.IO.Move.Perform">
            <summary> Occurs when move sequence detected </summary>
        </member>
        <member name="T:Skill.Framework.IO.RotationGestureEventArgs">
            <summary>
            RotationGestureEventArgs
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],System.Single,System.Single)">
            <summary>
            Create a GestureDetectorEventArgs
            </summary>    
            <param name="fingerCount"> Number of fingers </param>
            <param name="positions">Position of touches when event happened  </param>    
            <param name="deltaRotation"> Delta rotation since last rotation </param>
            <param name="totalRotation"> Total rotation relative to initial rotation  </param>
        </member>
        <member name="P:Skill.Framework.IO.RotationGestureEventArgs.DeltaRotation">
            <summary> Delta rotation since last rotation </summary>
        </member>
        <member name="P:Skill.Framework.IO.RotationGestureEventArgs.TotalRotation">
            <summary> Total rotation relative to initial rotation </summary>
        </member>
        <member name="T:Skill.Framework.IO.RotationGestureEventHandler">
            <summary>
            Handle rotation gesture events
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="T:Skill.Framework.IO.RotationGestureDetector">
            <summary>
            Detect rotation gesture
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureDetector.OnRotate">
            <summary> Occurs when a rotation gesture detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureDetector.OnRotateStart">
            <summary> Occurs when a rotation gesture started </summary>
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureDetector.#ctor">
            <summary>
            Create a RotationGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureDetector.BeginDetection">
            <summary>
            Begin detection
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.RotationGestureDetector.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.RotationGestureDetector.MinimumRotation">
            <summary> Minimum rotation to start detecting </summary>
        </member>
        <member name="E:Skill.Framework.IO.RotationGestureDetector.Rotate">
            <summary> Occurs when a rotation gesture detected </summary>
        </member>
        <member name="E:Skill.Framework.IO.RotationGestureDetector.RotateStart">
            <summary> Occurs when a rotation gesture started </summary>
        </member>
        <member name="P:Skill.Framework.IO.RotationGestureDetector.Origin">
            <summary>
            Center of rotation on screen.
            null : detector use two finger that rotate relative together
            not null : detector use single finger that rotates around origin
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.RotationGestureDetector.FingerCount">
            <summary> Number of fingers </summary>
        </member>
        <member name="T:Skill.Framework.IO.ScaleGestureEventArgs">
            <summary>
            ScaleGestureEventArgs
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],System.Single,System.Single)">
            <summary>
            Create a HoldGestureEventArgs
            </summary>
            <param name="fingerCount">Number of fingers</param>
            <param name="positions"> Position of touches </param>
            <param name="deltaScale"> Delta scale relative to previous scale </param>
            <param name="totalScale"> Total scale relative to initial scale </param>
        </member>
        <member name="P:Skill.Framework.IO.ScaleGestureEventArgs.DeltaScale">
            <summary> Delta scale relative to previous scale</summary>
        </member>
        <member name="P:Skill.Framework.IO.ScaleGestureEventArgs.TotalScale">
            <summary> Total scale relative to initial scale</summary>
        </member>
        <member name="T:Skill.Framework.IO.ScaleGestureEventHandler">
            <summary>
            Handle scale gesture event
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> Arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.ScaleGestureDetector">
            <summary>
            Detector for scale
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureDetector.OnScale">
            <summary> Occurs when scale event detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureDetector.#ctor">
            <summary>
            Create a ScaleGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureDetector.BeginDetection">
            <summary>
            Begin Detection
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureDetector.Detection">
            <summary>
            Detection
            </summary>
            <returns>Result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.ScaleGestureDetector.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.ScaleGestureDetector.FingerCount">
            <summary>
            Number of fingers
            </summary>
        </member>
        <member name="E:Skill.Framework.IO.ScaleGestureDetector.Scale">
            <summary> Occurs when scale event detected </summary>
        </member>
        <member name="T:Skill.Framework.IO.SwipeDirection">
            <summary>
            Swie direction
            </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.None">
            <summary> None </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Left">
            <summary> Left </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Right">
            <summary> Right </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Up">
            <summary> Up </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Down">
            <summary> Down </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Horizontal">
            <summary> Left or Right </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.Vertical">
            <summary> Up or Down </summary>
        </member>
        <member name="F:Skill.Framework.IO.SwipeDirection.AnyDirection">
            <summary> Left or Right or Up or Down </summary>
        </member>
        <member name="T:Skill.Framework.IO.SwipeGestureEventArgs">
            <summary>
            SwipeGestureEventArgs 
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.SwipeGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],Skill.Framework.IO.SwipeDirection,System.Single)">
            <summary>
            Create a SwipeGestureEventArgs
            </summary>    
            <param name="fingerCount"> Number of fingers </param>
            <param name="positions">Position of touches when event happened  </param>          
            <param name="direction"> Swipe direction </param>
            <param name="swipeVelocity"> Velocity of swipe </param>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureEventArgs.Velocity">
            <summary> Velocity of swipe </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureEventArgs.Direction">
            <summary> Swipe direction  </summary>
        </member>
        <member name="T:Skill.Framework.IO.SwipeGestureEventHandler">
            <summary>
            Handle Swipe Gesture events
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.SwipeGestureDetector">
            <summary>
            Detect swipe gesture
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.SwipeGestureDetector.OnSwipe(Skill.Framework.IO.SwipeDirection,System.Single)">
            <summary> Occurs when a swipe gesture detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.SwipeGestureDetector.#ctor">
            <summary>
            Create a SwipeGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.SwipeGestureDetector.BeginDetection">
            <summary> Begin detection </summary>
        </member>
        <member name="M:Skill.Framework.IO.SwipeGestureDetector.Detection">
            <summary>
            Detection
            </summary>
            <returns>Result of detection </returns>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.TimeToSwipe">
            <summary> Maximum allowed time to swipe (default :  0.5f) </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.AllowedVariance">
            <summary> Maximum allowed variance in perpendicular direction (default : 35.0f) </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.MinimumDistance">
            <summary> Minimum distance to swipe </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.FingerCount">
            <summary>
            Number of finger
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.DetectedSwipeDirection">
            <summary> Detected swipe drection </summary>
        </member>
        <member name="P:Skill.Framework.IO.SwipeGestureDetector.SwipesToDetect">
            <summary> What swipe direction to detect </summary>
        </member>
        <member name="E:Skill.Framework.IO.SwipeGestureDetector.Swipe">
            <summary> Occurs when a swipe gesture detected </summary>
        </member>
        <member name="T:Skill.Framework.IO.TapGestureEventArgs">
            <summary>
            TapGestureEventArgs 
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureEventArgs.#ctor(System.Int32,UnityEngine.Vector2[],System.Int32)">
            <summary>
            Create a TapGestureEventArgs
            </summary>
            <param name="fingerCount"> Number of fingers </param>
            <param name="positions">Position of touches when event happened  </param>  
            <param name="tapCount">Number of touches</param>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureEventArgs.TapCount">
            <summary> Number of tap </summary>
        </member>
        <member name="T:Skill.Framework.IO.TapGestureEventHandler">
            <summary>
            Handle Tap Gesture events
            </summary>
            <param name="sender">Sender</param>
            <param name="args"> arguments </param>
        </member>
        <member name="T:Skill.Framework.IO.TapGestureDetectorUnity">
            <summary>
            Detect tap gesture. use unity result touch.tapcount
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetectorUnity.#ctor">
            <summary>
            Create a TapGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetectorUnity.OnDetect">
            <summary> Occurs when a tap detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetectorUnity.Update(Skill.Framework.IO.ITouchStateProvider)">
            <summary>
            Update detector
            </summary>
            <param name="provider">Touch provider</param>
            <returns>Result of detection</returns>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetectorUnity.TapCount">
            <summary> Number of required tap count </summary>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetectorUnity.FingerCount">
            <summary> Number of required touches </summary>
        </member>
        <member name="E:Skill.Framework.IO.TapGestureDetectorUnity.Tap">
            <summary> Occurs when a tap detected </summary>
        </member>
        <member name="T:Skill.Framework.IO.TapGestureDetector">
            <summary>
            Detect tap gesture
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetector.#ctor">
            <summary>
            Create a TapGestureDetector
            </summary>        
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetector.OnTap">
            <summary> Occurs when a tap detected </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetector.BeginDetection">
            <summary>
            Begin detection
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetector.Detection">
            <summary>
            Detection
            </summary>
            <returns> Result of detection</returns>
        </member>
        <member name="M:Skill.Framework.IO.TapGestureDetector.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetector.TapCount">
            <summary> Number of required tap count </summary>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetector.FingerCount">
            <summary> Number of required touches </summary>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetector.MaxTapInterval">
            <summary> Maximum time allowd to detect a tap</summary>
        </member>
        <member name="P:Skill.Framework.IO.TapGestureDetector.MaxDeltaMovement">
            <summary> Maximum delta movement for tap consideration </summary>
        </member>
        <member name="E:Skill.Framework.IO.TapGestureDetector.Tap">
            <summary> Occurs when a tap detected </summary>
        </member>
        <member name="T:Skill.Framework.IO.TouchState">
            <summary>
            State of touch
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.#ctor(System.Int32)">
            <summary>
            Create a TouchState
            </summary>
            <param name="fingerId"> The unique index for the touch. </param>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.Update(UnityEngine.Touch)">
            <summary>
            Update state from a touch
            </summary>
            <param name="touch">Touch</param>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.Update">
            <summary>
            update from Input.GetTouch(FingerId)
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.UpdateFromMouse(UnityEngine.Vector3)">
            <summary> Update from mouse input </summary>
            <remarks>
            seperating this out into a seperate method allows us to pass in a real mousePosition or a simulated mouse position when populating the touch
            </remarks>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.UpdateFromMouse">
            <summary>
            Update from mouse input
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.ToString">
            <summary>
            Represent state as string
            </summary>
            <returns>String</returns>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.Lock(System.Object)">
            <summary>
            Lock touch and get exclusive access
            </summary>
            <param name="locker">who wants to lock touch</param>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.UnLock(System.Object)">
            <summary>
            Unlock touch by locker
            </summary>
            <param name="locker">who locked the touch</param>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.Use">
            <summary> Set touch as used </summary>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.IsLockedBy(System.Object)">
            <summary>
            Is touch locked by specified object
            </summary>
            <param name="locker">object that maybe locked this touch</param>
            <returns>True if locked, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.IO.TouchState.IsValidFor(System.Object)">
            <summary>
            Is touch valid to use by specified object
            </summary>
            <param name="locker">object that maybe locked this touch</param>
            <returns>True if valid, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.FingerId">
            <summary> The unique index for the touch. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.Position">
            <summary> The position of the touch in pixel coordinates. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.DeltaPosition">
            <summary> The position delta since last change. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.DeltaTime">
            <summary>  Amount of time that has passed since the last recorded change in Touch values. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.TapCount">
            <summary> Number of taps. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.Phase">
            <summary> Describes the phase of the touch. </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.IsLocked">
            <summary> Is state locked by a detector </summary>
        </member>
        <member name="P:Skill.Framework.IO.TouchState.IsUsed">
            <summary> Is touch used at current frame. touch will be unused at next update </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlDocument.CreateElement(System.String)">
            <summary>
            Creates an element with the specified name.
            </summary>
            <param name="name"> The qualified name of the element. </param>
            <returns> The new XmlElement. </returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlDocument.AppendChild(Skill.Framework.IO.XmlElement)">
            <summary>
            Adds the specified node to the end of the list of child nodes, of this node.
            </summary>
            <param name="newChild"> The node to add. All the contents of the node to be added are moved into the specified location.</param>
            <returns>The node added.</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlDocument.LoadXml(System.String)">
            <summary>
            Loads the XML document from the specified string.
            </summary>
            <param name="xml">String containing the XML document to load.</param>
        </member>
        <member name="P:Skill.Framework.IO.XmlDocument.Item(System.String)">
            <summary>
            Gets the first child element with the specified Name.
            </summary>
            <param name="name"> The qualified name of the element to retrieve. </param>
            <returns> The first XmlElement that matches the specified name. </returns>
        </member>
        <member name="P:Skill.Framework.IO.XmlDocument.OuterXml">
            <summary>
            Gets the markup representing this node and all its child nodes.
            </summary>
        </member>
        <member name="T:Skill.Framework.IsometricCamera">
            <summary>
            Isometric camera to view target from above. Add this component to 'UnityEngine.Camera' GameObject and set Target to player or a movable object.
            </summary>    
        </member>
        <member name="F:Skill.Framework.IsometricCamera.Target">
            <summary> Target to follow </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.Damping">
            <summary> How to damp movement of camera when following target</summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.CameraPreview">
            <summary> Camera moves by mouse when mouse position gets far from center of screen. </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.AroundAngle">
            <summary> Rotation angle around target ( 0 - 360) </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.LookAngle">
            <summary> Rotation angle behind target( 0 - 90). 0 is completely horizontal to target and 90 is completely vertical to target. </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.ZoomIn">
            <summary> Minimum distance to target when PointOfIntrest is close to target</summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.ZoomOut">
            <summary> Maximum distance to target when PointOfIntrest is far from target</summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.MaxOffset">
            <summary> Maximum distance of PointOfIntrest from target</summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.Fov">
            <summary> Field of view </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.CursorPlaneHeight">
            <summary> height of cursor plane above target </summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.FastTarget">
            <summary> If target can move very fast do not allow camera to loose it</summary>
        </member>
        <member name="F:Skill.Framework.IsometricCamera.CustomOffset">
            <summary>
            Apply relative custom offset to position of camera
            </summary>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.LateUpdate">
            <summary>
            LateUpdate
            </summary>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.HandleMousePosition">
            <summary>
            Allow subclass to handle mouse position in different way
            </summary>
            <returns>Position of mouse on screen</returns>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.ScreenPointToWorldPointOnPlane(UnityEngine.Vector3,UnityEngine.Plane,UnityEngine.Camera)">
            <summary>
            Calculate intersect position of a ray from camera at screenPoint to a plane in world
            </summary>
            <param name="screenPoint">Position of point in screen space (mouse position)</param>
            <param name="plane">Plane in world space</param>
            <param name="camera">Camera to create ray</param>
            <returns> Intersection poitn of ray and plane </returns>
        </member>
        <member name="M:Skill.Framework.IsometricCamera.PlaneRayIntersection(UnityEngine.Plane,UnityEngine.Ray)">
            <summary>
            Find out where the ray intersects with the plane
            </summary>
            <param name="plane">Plane</param>
            <param name="ray">Ray</param>
            <returns>Intersection poitn of ray and plane</returns>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.CursorScreenPosition">
            <summary> Prepare a cursor point variable. This is the mouse position on PC and controlled by the thumbstick on mobiles. </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.CursorWorldPosition">
            <summary> Position of cursur in world on CursorPlane </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.ScreenForward">
            <summary> Screen forward direction</summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.ScreenRight">
            <summary> Screen right direction</summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.Camera">
            <summary> Camera </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.Zoom">
            <summary> Current zoom distance </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.PointOfInterest">
            <summary> It can be center of all enemies around player </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCamera.ScreenSpace">
            <summary>  Camera screen space </summary>
        </member>
        <member name="T:Skill.Framework.IsometricCameraMotion">
            <summary>
            Motion Isometric camera smoothly. Add this component to 'UnityEngine.Camera' with 'Skill.Framework.IsometricCamera' component attached.
            </summary>    
        </member>
        <member name="M:Skill.Framework.IsometricCameraMotion.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.IsometricCameraMotion.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="P:Skill.Framework.IsometricCameraMotion.Camera">
            <summary> Isometric Camera </summary>
        </member>
        <member name="P:Skill.Framework.Modules.Meter.Distance">
            <summary> Retrieves distance between StartPosition and EndPosition.</summary>
        </member>
        <member name="P:Skill.Framework.Modules.Meter.StartPosition">
            <summary> Gets or set StartPosition.</summary>
        </member>
        <member name="P:Skill.Framework.Modules.Meter.EndPosition">
            <summary> Gets or set EndPosition.</summary>
        </member>
        <member name="T:Skill.Framework.Modules.Implant">
            <summary>
            Defines implant data
            </summary>    
        </member>
        <member name="T:Skill.Framework.Modules.ShakeOnEnable">
             <summary>
             Call Global.OnCameraShake event OnEnable. this is usefull for explisions to shake camera
             </summary>
            <remarks>
             When a GameObject instantiated OnEnable method will called.
             if use this behavior with a cachable object, and cache objects instantiated before use,
             so it is better to ignore first enable
             so make sure that if you use this behavior and CacheBehavior together, this gameobject must be inside a CacheGroup to work correctly
             </remarks>    
        </member>
        <member name="F:Skill.Framework.Modules.ShakeOnEnable.Shake">
            <summary> Shake parameter </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShakeOnEnable.OnEnable">
            <summary>
            This function is called when the object becomes enabled and active.
            </summary>
        </member>
        <member name="T:Skill.Framework.Modules.ShakeOnDie">
            <summary>
            Call Global.OnCameraShake event OnDie
            </summary>    
        </member>
        <member name="F:Skill.Framework.Modules.ShakeOnDie.Shake">
            <summary> Shake parameter </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShakeOnDie.HookEvents">
            <summary>
            Hook required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShakeOnDie.UnhookEvents">
            <summary>
            Unhook hooked events
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.ShakeOnDie.Events_Die(System.Object,System.EventArgs)">
            <summary>
            Hooked to Die event of EventManager
            </summary>
            <param name="sender">Source of event</param>
            <param name="e"> EventArgs </param>
        </member>
        <member name="T:Skill.Framework.SequenceEventHandler">
            <summary>
            Handle SequenceEvent
            </summary>
            <param name="sender">Sender of event</param>
            <param name="args">Args that contains information about event</param>
        </member>
        <member name="T:Skill.Framework.SequenceEventArgs">
            <summary>
            Args that contains information about event
            </summary>
        </member>
        <member name="M:Skill.Framework.SequenceEventArgs.#ctor(Skill.Framework.TimeEvent,System.Int32)">
            <summary>
            Create a SequenceEventArgs
            </summary>
            <param name="e">Event</param>
            <param name="index">Index of event</param>
        </member>
        <member name="P:Skill.Framework.SequenceEventArgs.Event">
            <summary> event </summary>
        </member>
        <member name="P:Skill.Framework.SequenceEventArgs.Index">
            <summary> Index of event in SequenceEvent</summary>
        </member>
        <member name="T:Skill.Framework.TimeEvent">
            <summary>
            An event that execute at specific time
            </summary>
        </member>
        <member name="F:Skill.Framework.TimeEvent.Name">
            <summary> Name of event </summary>
        </member>
        <member name="F:Skill.Framework.TimeEvent.Time">
            <summary> Local time of event </summary>
        </member>
        <member name="M:Skill.Framework.TimeEvent.#ctor(System.String,System.Single)">
            <summary>
            Create an Event
            </summary>
            <param name="name">Name of event</param>
            <param name="time">Local time of event</param>
        </member>
        <member name="T:Skill.Framework.EventSequence">
            <summary>
            Represent a sequence of events. this class manage execution of these events. it is useful when you want to do some works in sequence but each in cetain time
            </summary>
        </member>
        <member name="F:Skill.Framework.EventSequence.TimeEvents">
            <summary> Events </summary>
        </member>
        <member name="F:Skill.Framework.EventSequence.Loop">
            <summary> Is loop throw events after execution of lase event </summary>
        </member>
        <member name="M:Skill.Framework.EventSequence.OnEvent(System.Int32)">
            <summary> Occurs when an event's time reached </summary>
        </member>
        <member name="M:Skill.Framework.EventSequence.Update">
            <summary>
            Update sequence
            </summary>
        </member>
        <member name="M:Skill.Framework.EventSequence.Reset">
            <summary>
            Reset sequence from begining if it is started
            </summary>
        </member>
        <member name="E:Skill.Framework.EventSequence.Event">
            <summary> Occurs when an event's time reached </summary>
        </member>
        <member name="P:Skill.Framework.EventSequence.Finished">
            <summary>
            Is all events executed (never be true if loop)
            </summary>
        </member>
        <member name="T:Skill.Framework.Modules.PaintColor">
            <summary> Defines data needed to paint on texture </summary>
        </member>
        <member name="T:Skill.Framework.Rendering.BeamSection">
            <summary>
            Defins parameters for each repeatable section of beam
            </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.BeamSection.Name">
            <summary> Optional name of section</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.BeamSection.VertexCount">
            <summary> Number of vertex(by considering resolution) to use for section </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.BeamSection.Scale">
            <summary> Magnitude Scale of section</summary>
        </member>
        <member name="T:Skill.Framework.Rendering.Beam">
            <summary>
            A Beam line
            </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.Sections">
            <summary> Sections of beam </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.StartPivot">
            <summary> Start pivot to attach beam</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.EndPivot">
            <summary> End pivot to attach beam</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.MinAmplitude">
            <summary> Minimum amplitude </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.MaxAmplitude">
            <summary> Maximum amplitude </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.UpdateInterval">
            <summary> Update interval </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.Length">
            <summary> Length of beam </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.OffTime">
            <summary> OffTime after each OffTime interval (zero or negative to disable)</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.MinOffInterval">
            <summary> Minimum time of between each OffTime</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.MaxOffInterval">
            <summary> Maximum time of between each OffTime </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.Resolution">
            <summary> Resolusion of beam vertex per meter </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.Billboard">
            <summary> Rotate beam towards camera </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.LockStart">
            <summary> Lock start vertex to StartPosition </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.Beam.LockEnd">
            <summary> Lock end vertex to HitPoint </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.Beam.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.Beam.ValidateParameters">
            <summary>
            Validate parameters to be in valid range
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.Beam.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.Beam.UpdateBeamRenderer(UnityEngine.LineRenderer,System.Int32)">
            <summary>
            Update beam renderer
            </summary>
            <param name="renderer">The LineRenderer use to render beam</param>
            <param name="vertexCount">Number of vertex</param>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.HitPoint">
            <summary> Point of hit(if IsHit) </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.IsHit">
            <summary> Is beam hit something? </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.VertexCount">
            <summary> Number of vertex at current frame.</summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.Repeat">
            <summary> Number of vertex used by all sections in first repeat.</summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.OffsetDirection">
            <summary> Direction of beam offset (can be billboard to camera or transform.right )</summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.Direction">
            <summary> Direction of beam</summary>
        </member>
        <member name="P:Skill.Framework.Rendering.Beam.StartPosition">
            <summary> Where beam start</summary>
        </member>
        <member name="T:Skill.Framework.Rendering.LaserBeam">
            <summary>
            Should be parent of one or more "Beam" to work correctly. each beam can have deferent parameters and when combined togather create desired result
            </summary>    
        </member>
        <member name="F:Skill.Framework.Rendering.LaserBeam.EndEffect">
            <summary> The particle system, in this case sparks which will be created by the Laser </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.LaserBeam.MaxLength">
            <summary> Maximum lenght of laser beam </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.LaserBeam.Collision">
            <summary> check for collision </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.LaserBeam.RotateEffect">
            <summary> if collision, rotate EndEffect along hit normal </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.LaserBeam.CollisionLayerMask">
            <summary> filter raycast collision detection </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.LaserBeam.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.LaserBeam.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.LaserBeam.HitPoint">
            <summary> Hit point (valid if IsHit) </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.LaserBeam.HitNormal">
            <summary> Hit normal (valid if IsHit) </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.LaserBeam.HitDistance">
            <summary> Hit distance (valid if IsHit) </summary>
        </member>
        <member name="P:Skill.Framework.Rendering.LaserBeam.IsHit">
            <summary> Is laser hit by something?</summary>
        </member>
        <member name="P:Skill.Framework.Rendering.LaserBeam.Beams">
            <summary> child beams </summary>
        </member>
        <member name="T:Skill.Framework.Rendering.RandomizeBeam">
            <summary>
            A beam that use random between min and max amplitude each frame.
            </summary>    
        </member>
        <member name="M:Skill.Framework.Rendering.RandomizeBeam.UpdateBeamRenderer(UnityEngine.LineRenderer,System.Int32)">
            <summary>
            Update beam renderer
            </summary>
            <param name="renderer">The LineRenderer use to render beam</param>
            <param name="vertexCount">Number of vertex</param>
        </member>
        <member name="T:Skill.Framework.Rendering.WaveBeam">
            <summary>
            A wave beam
            </summary>    
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.PulseInterval">
            <summary> Interval between amplitude change</summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.Noise">
            <summary> Noise factor </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.RelativeNoise">
            <summary> apply noise relative to wave amplitude or absolute to wave </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.ZigZag">
            <summary> -/+ wave between intervals </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.Fixed">
            <summary> do not move between min and max amplitudes </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.Shift">
            <summary> shift wave each update interval </summary>
        </member>
        <member name="F:Skill.Framework.Rendering.WaveBeam.ShiftBuffer">
            <summary> Max buffer to use for shift</summary>
        </member>
        <member name="M:Skill.Framework.Rendering.WaveBeam.ValidateParameters">
            <summary>
            Validate parameters
            </summary>
        </member>
        <member name="M:Skill.Framework.Rendering.WaveBeam.UpdateBeamRenderer(UnityEngine.LineRenderer,System.Int32)">
            <summary>
            Update beam renderer
            </summary>
            <param name="renderer">The LineRenderer use to render beam</param>
            <param name="vertexCount">Number of vertex</param>
        </member>
        <member name="M:Skill.Framework.Rendering.WaveBeam.CalculateWaveFactors(System.Int32)">
            <summary>
            Calculate wave factors. by default calc sin(0 - PI)
            </summary>    
            <param name="vertexCount">Number of vertex to use in wavefactors</param>
            <returns>Wavefactors</returns>
        </member>
        <member name="T:Skill.Framework.SlowMotionInfo">
            <summary>
            Defines basic information about slow motion
            </summary>
        </member>
        <member name="F:Skill.Framework.SlowMotionInfo.Freez">
            <summary> Lenght of freez time at begining of slow motion.( Freez time is calculated as part of SlowMotion time ) </summary>
        </member>
        <member name="F:Skill.Framework.SlowMotionInfo.SlowMotion">
            <summary> Lenght of slow motion </summary>
        </member>
        <member name="F:Skill.Framework.SlowMotionInfo.TimeScale">
            <summary> Target TimeScale when slow motion </summary>
        </member>
        <member name="F:Skill.Framework.SlowMotionInfo.Pitch">
            <summary> Target sound pitch when slow motion </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionInfo.#ctor">
            <summary> Default constructor </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionInfo.#ctor(Skill.Framework.SlowMotionInfo)">
            <summary>
            Create a copy of SlowMotionInfo
            </summary>
            <param name="other">Oter SlowMotionInfo to copy</param>
        </member>
        <member name="M:Skill.Framework.SlowMotionInfo.CopyFrom(Skill.Framework.SlowMotionInfo)">
            <summary>
            Create a copy of SlowMotionInfo
            </summary>
            <param name="other">Oter SlowMotionInfo to copy</param>
        </member>
        <member name="T:Skill.Framework.SlowMotionEventArgs">
            <summary>
            containing SlowMotion event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionEventArgs.#ctor(Skill.Framework.SlowMotionInfo)">
            <summary>
            Create SlowMotionEventArgs
            </summary>
            <param name="motion"> SlowMotion information </param>
        </member>
        <member name="P:Skill.Framework.SlowMotionEventArgs.Motion">
            <summary> SlowMotion information </summary>
        </member>
        <member name="T:Skill.Framework.SlowMotionEventHandler">
            <summary>
            Handle SlowMotion
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> A SlowMotionEventArgs containing SlowMotion event data </param>
        </member>
        <member name="T:Skill.Framework.SlowMotionController">
            <summary>
            Modify TimeScale to simulate slowmotion
            </summary>    
        </member>
        <member name="M:Skill.Framework.SlowMotionController.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionController.HookEvents">
            <summary>
            Hook required events if needed
            </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionController.UnhookEvents">
            <summary>
            Unhook hooked events 
            </summary>
        </member>
        <member name="M:Skill.Framework.SlowMotionController.OnStartSlowMotion">
            <summary>
            Occurs when a SlowMotion begined
            </summary>        
        </member>
        <member name="M:Skill.Framework.SlowMotionController.OnEndSlowMotion">
            <summary>
            Occurs when a SlowMotion ended
            </summary>        
        </member>
        <member name="M:Skill.Framework.SlowMotionController.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="P:Skill.Framework.SlowMotionController.Instance">
            <summary>
            The only instance of Global object in scene
            </summary>
        </member>
        <member name="P:Skill.Framework.SlowMotionController.IsSlowingMotion">
            <summary>
            Whether game is in slow motion mode or not
            </summary>
        </member>
        <member name="E:Skill.Framework.SlowMotionController.StartSlowMotion">
            <summary>
            Occurs when a SlowMotion started
            </summary>
        </member>
        <member name="E:Skill.Framework.SlowMotionController.EndSlowMotion">
            <summary>
            Occurs when a SlowMotion ended
            </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.SoundVolume">
            <summary> Set volume of all audios on enable </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundVolume.Category">
            <summary> Category of sound </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundVolume.VolumeFactor">
            <summary> Volume factor </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.DynamicSoundVolume">
            <summary>
            Manage volume of sounds every frame
            </summary>
        </member>
        <member name="T:Skill.Framework.SpawnAsset">
            <summary>
            Defines serializable data asset required for Spawner
            </summary>
        </member>
        <member name="F:Skill.Framework.SpawnAsset.Objects">
            <summary>
            Array of SpawnObjects
            </summary>
        </member>
        <member name="T:Skill.Framework.Spawner">
            <summary>
            Use this class to spawn object in scheduled time and with triggers
            </summary>    
        </member>
        <member name="F:Skill.Framework.Spawner.SpawnObjects">
            <summary> GameObject to spawn </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.Locations">
            <summary> where to spawn objects </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.CycleLocations">
            <summary> If true, the spawner will cycle through the spawn locations instead of spawning from a randomly chosen one </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.Interval">
            <summary> Delta time between spawns </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.AliveCount">
            <summary> The maximum number of agents alive at one time. If agents are destroyed, more will spawn to meet this number. </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.SpawnCount">
            <summary> The maximum number of agents to spawn.when number of spawned object reach this value the spawner will not spawn anymore  </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.SpawnRadius">
            <summary> Radius around spawn location to spawn agents. </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.OnlySpawnHidden">
            <summary> If true, only spawn agents if player can't see spawn point </summary>
        </member>
        <member name="F:Skill.Framework.Spawner.DeadInterval">
            <summary> If true, wait Interval after one spawned gameobject is dead </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.RecalculateWeights">
            <summary>
            Call this method if you change SpawnObjects after the Spawner started.
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.InitializeSpawnedObject(UnityEngine.GameObject)">
            <summary>
            let inherited class modify spawned object right after spawn time
            </summary>
            <param name="spawnedObj">Spawned Object</param>
        </member>
        <member name="M:Skill.Framework.Spawner.OnComplete">
            <summary>
            when spawner spawned all objects
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.OnAllDead">
            <summary>
            when spawner complete and all spawned objects dead
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.GetNextSpawnObject">
            <summary>
            Select a random GameObject from SpawnObjects by chance
            subclass can change this behavior
            </summary>
            <returns>New GameObject from SpawnObjects to instantiate from</returns>
        </member>
        <member name="M:Skill.Framework.Spawner.Spawn">
            <summary>
            Spawn new game objects
            </summary>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Spawner.GetNextLocation(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>
            Get next location to spawn object
            </summary>
            <param name="position">Position of spawn object</param>
            <param name="rotation">Rotation of spawn object</param>
        </member>
        <member name="M:Skill.Framework.Spawner.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.OnDestroy">
            <summary>
            when spawner destroyed (all spawned objects will destroyed too)
            </summary>
        </member>
        <member name="M:Skill.Framework.Spawner.NotifySpawnedObjectIsDead(UnityEngine.GameObject)">
            <summary>
            Notify spawner that given object is dead but not destroyed yet ( the dead body is still visible )
            </summary>
            <param name="deadSpawnedObj">dead spawned object</param>
        </member>
        <member name="M:Skill.Framework.Spawner.KillAllAlives">
            <summary>
            Destroy all alive objects
            </summary>
        </member>
        <member name="P:Skill.Framework.Spawner.AliveObjects">
            <summary> List of all alive spawned objects </summary>
        </member>
        <member name="P:Skill.Framework.Spawner.DeadObjects">
            <summary> List of all alive spawned objects </summary>
        </member>
        <member name="P:Skill.Framework.Spawner.NumberOfAliveObjects">
            <summary> Number of alive objects </summary>
        </member>
        <member name="P:Skill.Framework.Spawner.NumberOfDeadObjects">
            <summary> Number of dead objects </summary>
        </member>
        <member name="P:Skill.Framework.Spawner.CanSpawn">
            <summary>
            Subclasses can avoid spawning for some reason at specific times
            </summary>
        </member>
        <member name="E:Skill.Framework.Spawner.Complete">
            <summary>
            Occurs when spawner spawned all objects
            </summary>
        </member>
        <member name="E:Skill.Framework.Spawner.AllDead">
            <summary>
            Occurs when spawner complete and all spawned objects dead
            </summary>
        </member>
        <member name="T:Skill.Framework.SpawnObject">
            <summary>
            Contains data needed to spawn an object
            </summary>
        </member>
        <member name="F:Skill.Framework.SpawnObject.Prefab">
            <summary> GameObject to spawn </summary>
        </member>
        <member name="F:Skill.Framework.SpawnObject.Weight">
            <summary> Chance to spawn </summary>
        </member>
        <member name="T:Skill.Framework.Collisions.HealthCollider">
            <summary>
            when a Prefab is made of more than one collider, but you want use single Health for entire Prefab assign this behaiour to each collider
            and set reference to main health
            </summary>
        </member>
        <member name="F:Skill.Framework.Collisions.HealthCollider.Health">
            <summary> Main Health</summary>
        </member>
        <member name="F:Skill.Framework.Collisions.HealthCollider.Hit">
            <summary> Notify main Health about incomming hits</summary>
        </member>
        <member name="F:Skill.Framework.Collisions.HealthCollider.Damage">
            <summary> Notify main Health about incomming damages</summary>
        </member>
        <member name="M:Skill.Framework.Collisions.HealthCollider.HookEvents">
            <summary>
            Hook required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Collisions.HealthCollider.Events_Damage(System.Object,Skill.Framework.DamageEventArgs)">
            <summary>
            Handle imposed damage
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> An DamageEventArgs that contains damage event data.</param>
        </member>
        <member name="M:Skill.Framework.Collisions.HealthCollider.Events_Hit(System.Object,Skill.Framework.HitEventArgs)">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> sender </param>
            <param name="args"> An HitEventArgs that contains hit event data. </param>        
        </member>
        <member name="T:Skill.Framework.Dynamics.ExplosiveObject">
            <summary>
            Defines base class for ExplosiveObjects. usually this object has a Health and an exploded mesh. When Health dies, explodedMesh will be visible and an explosion effect spawned
            </summary>
        </member>
        <member name="T:Skill.Framework.Dynamics.Explosive">
            <summary>
            Base class for explosive objects. it explode OnDie.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosive.ExpPrefab">
            <summary> The GameObject to spawn on explosion </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosive.ExpPositions">
            <summary> Positions to spawn ExpPrefab </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosive.OrientToExpPosition">
            <summary> use rotation of ExpPosition for ExpPrefab </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosive.DestroyDelay">
            <summary> Amount of self destruction delay after explosion (set it to negative to disable self destruction)</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.Explosive.Shake">
            <summary> Shake camera on explosion </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.HookEvents">
            <summary>
            Hook required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.Events_Die(System.Object,System.EventArgs)">
            <summary>
            The GameObject dies and explosion happened
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="e"> An System.EventArgs that contains no event data. </param>        
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.SpawnExplosionPrefab(UnityEngine.Transform)">
            <summary>
            Subclass can override this method to spawn ExplosionPrefab another way
            </summary>
            <param name="position">Where to spawn</param>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.Start">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.Explosive.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.ExplodedObjects">
            <summary> Active after explosion </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.SpreadObjects">
            <summary> to spread around after explosion </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.SpreadCount">
            <summary> number of spread to select in random from SpreadObjects </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.SpreadOffset">
            <summary> offset of spread objetcs </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.ExplosionRadius">
            <summary> how many far to spread objects </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.ExplosionForce">
            <summary> Froce to apply on spread object's Rigidbody </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.UpwardsModifier">
            <summary> upwardsModifier to use in Rigidbody.AddExplosionForce method </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.FirePositions">
            <summary> instantiate when health reach FireHealthThreshold </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.FirePrefab">
            <summary> instantiate when health reach FireHealthThreshold </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.FireHealthThreshold">
            <summary> when health reach lower than this negative RegenerateSpeed begins </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ExplosiveObject.FireDamageSpeed">
            <summary> speed of self-destruction when fire starts </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ExplosiveObject.GetReferences">
            <summary>
            Get required references
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ExplosiveObject.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ExplosiveObject.Events_Die(System.Object,System.EventArgs)">
            <summary>
            The GameObject dies and explosion happened
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="e"> An System.EventArgs that contains no event data. </param>   
        </member>
        <member name="M:Skill.Framework.Dynamics.ExplosiveObject.OnDestroy">
            <summary>
            This function is called when the MonoBehaviour will be destroyed.
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ExplosiveObject.SpawnSpreadObject(UnityEngine.GameObject)">
            <summary>
            Subclass can override this method to spawn SpreadObjects another way
            </summary>        
            <param name="prefab"> SpreadObject to spawn from </param>        
        </member>
        <member name="P:Skill.Framework.Dynamics.ExplosiveObject.Health">
            <summary> Health </summary>
        </member>
        <member name="T:Skill.Framework.Dynamics.ThrowUp">
            <summary>
            Simulation force of explosion without Rigidbody in y axis until returns to initial position.
            This behavior is disable and by enabling this behavior simulation starts.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Dynamics.ThrowUp.Gravity">
            <summary> Gravity (must be positive)</summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ThrowUp.Force">
            <summary> Initial force(speed) of explosion </summary>
        </member>
        <member name="F:Skill.Framework.Dynamics.ThrowUp.SimulateOnDie">
            <summary> require valid EventManager component assined to game object to hook Die event </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.HookEvents">
            <summary>
            Hook required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.UnhookEvents">
            <summary>
            Hook required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.Events_Die(System.Object,System.EventArgs)">
            <summary>
            Notify GameObject is dead
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="e"> An System.EventArgs that contains no event data. </param>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.OnEnable">
            <summary>
            prepare for simulation
            </summary>
        </member>
        <member name="M:Skill.Framework.Dynamics.ThrowUp.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:Skill.Framework.IO.BinaryLoadStream">
            <summary>
            Defines all methods required to load ISavable object.
            you have to inherite from this class and Implement four Read method (ReadInt, ReadFloat, ReadBoolean and ReadString ) based on target platform
            all other data types can be read by these four method
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadInt">
            <summary>
            Read an int32 value for stream
            </summary>
            <returns>Int32</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadFloat">
            <summary>
            Read a float value for stream
            </summary>
            <returns>float</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadBoolean">
            <summary>
            Read a boolean value for stream
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadString">
            <summary>
            Read a string value for stream
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadBounds">
            <summary>
            Read Bounds data from stream
            </summary>
            <returns>Bounds</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadColor">
            <summary>
            Read Color data from stream
            </summary>
            <returns>Color</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadMatrix4x4">
            <summary>
            Read Matrix4x4 data from stream
            </summary>
            <returns>Matrix4x4</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadPlane">
            <summary>
            Read Plane data from stream
            </summary>
            <returns>Plane</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadQuaternion">
            <summary>
            Read Quaternion data from stream
            </summary>
            <returns>Quaternion</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadRay">
            <summary>
            Read Ray data from stream
            </summary>
            <returns>Ray</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadRect">
            <summary>
            Read Rect data from stream
            </summary>
            <returns>Rect</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector2">
            <summary>
            Read Vector2 data from stream
            </summary>
            <returns>Vector2</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector3">
            <summary>
            Read Vector3 data from stream
            </summary>
            <returns>Vector3</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector4">
            <summary>
            Read Vector4 data from stream
            </summary>
            <returns>Vector4</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadSavable``1(Skill.Framework.IO.CreateISavable{``0})">
            <summary>
            Read a Savable class from stream
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="creator">Helper method to instantiate ISavable class</param>
            <returns>ISavable data</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadSavableArray``1(Skill.Framework.IO.CreateISavable{``0})">
            <summary>
            Read an array of Savable class from stream
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="creator">Helper method to instantiate ISavable class</param>
            <returns>array of ISavable data</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadIntArray">
            <summary>
            Read array of int data from stream
            </summary>
            <returns>array of int</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadFloatArray">
            <summary>
            Read array of float data from stream
            </summary>
            <returns>array of float</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadBooleanArray">
            <summary>
            Read array of bool data from stream
            </summary>
            <returns>array of bool</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadStringArray">
            <summary>
            Read array of string data from stream
            </summary>
            <returns>array of string</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadBoundsArray">
            <summary>
            Read array of Bounds data from stream
            </summary>
            <returns>array of Bounds</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadColorArray">
            <summary>
            Read array of Color data from stream
            </summary>
            <returns>array of Color</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadMatrix4x4Array">
            <summary>
            Read array of Matrix4x4 data from stream
            </summary>
            <returns>array of Matrix4x4</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadPlaneArray">
            <summary>
            Read array of Plane data from stream
            </summary>
            <returns>array of Plane</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadQuaternionArray">
            <summary>
            Read array of Quaternion data from stream
            </summary>
            <returns>array of Quaternion</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadRayArray">
            <summary>
            Read array of Ray data from stream
            </summary>
            <returns>array of Ray</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadRectArray">
            <summary>
            Read array of Rect data from stream
            </summary>
            <returns>array of Rect</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector2Array">
            <summary>
            Read array of Vector2 data from stream
            </summary>
            <returns>array of Vector2</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector3Array">
            <summary>
            Read array of Vector3 data from stream
            </summary>
            <returns>array of Vector3</returns>
        </member>
        <member name="M:Skill.Framework.IO.BinaryLoadStream.ReadVector4Array">
            <summary>
            Read array of Vector4 data from stream
            </summary>
            <returns>array of Vector4</returns>
        </member>
        <member name="T:Skill.Framework.IO.BinarySaveStream">
            <summary>
            Defines all methods required to save an ISavable object.
            you have to inherite from this class and Implement four write method (WriteInt, WriteFloat, WriteBoolean and WriteString ) based on target platform
            all other data types can be saved by these four method
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Int32)">
            <summary>
            Write given int value to stream
            </summary>
            <param name="i">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Single)">
            <summary>
            Write given float value to stream
            </summary>
            <param name="f">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Boolean)">
            <summary>
            Write given bool value to stream
            </summary>
            <param name="b">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.String)">
            <summary>
            Write given string value to stream
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Bounds)">
            <summary>
            Write given bounds value to stream
            </summary>
            <param name="bound">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Color)">
            <summary>
            Write given color value to stream
            </summary>
            <param name="color">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Matrix4x4)">
            <summary>
            Write given Matrix4x4 value to stream
            </summary>
            <param name="matrix">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Plane)">
            <summary>
            Write given plane value to stream
            </summary>
            <param name="plane">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Quaternion)">
            <summary>
            Write given quaternion value to stream
            </summary>
            <param name="quaternion">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Ray)">
            <summary>
            Write given ray value to stream
            </summary>
            <param name="ray">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Rect)">
            <summary>
            Write given rect value to stream
            </summary>
            <param name="rect">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector2)">
            <summary>
            Write given vector2 value to stream
            </summary>
            <param name="vector">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector3)">
            <summary>
            Write given vector3 value to stream
            </summary>
            <param name="vector">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector4)">
            <summary>
            Write given vector4 value to stream
            </summary>
            <param name="vector">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write``1(``0)">
            <summary>
            Write given ISavable value to stream
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="savable">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write``1(``0[])">
            <summary>
            Write given array of ISavable value to stream
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="savables">array of ISavable to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Int32[])">
            <summary>
            Write given array of int value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Single[])">
            <summary>
            Write given array of float value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.Boolean[])">
            <summary>
            Write given array of bool value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(System.String[])">
            <summary>
            Write given array of string value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Bounds[])">
            <summary>
            Write given array of Bounds value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Color[])">
            <summary>
            Write given array of Color value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Matrix4x4[])">
            <summary>
            Write given array of Matrix4x4 value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Plane[])">
            <summary>
            Write given array of Plane value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Quaternion[])">
            <summary>
            Write given array of Quaternion value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Ray[])">
            <summary>
            Write given array of Ray value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Rect[])">
            <summary>
            Write given array of Rect value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector2[])">
            <summary>
            Write given array of Vector2 value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector3[])">
            <summary>
            Write given array of Vector3 value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.BinarySaveStream.Write(UnityEngine.Vector4[])">
            <summary>
            Write given array of Vector4 value to stream
            </summary>
            <param name="primitives">array of int value to write</param>
        </member>
        <member name="T:Skill.Framework.IO.ISavable">
            <summary>
            Defines behaviors for an object to be savable by our algorithm
            </summary>
            <remarks>
            actually you do not need to use this interface and implent it. Skill Studio will generate this class for you.
            </remarks>
        </member>
        <member name="M:Skill.Framework.IO.ISavable.Save(Skill.Framework.IO.XmlElement,Skill.Framework.IO.XmlSaveStream)">
            <summary>
            Save data to given XmlElement e
            </summary>
            <param name="e">XmlElement to save data in</param>
            <param name="stream">helper stream</param>        
        </member>
        <member name="M:Skill.Framework.IO.ISavable.Save(Skill.Framework.IO.BinarySaveStream)">
            <summary>
            Save data to given stream
            </summary>
            <param name="stream">Stream to save data</param>
        </member>
        <member name="M:Skill.Framework.IO.ISavable.Load(Skill.Framework.IO.XmlElement,Skill.Framework.IO.XmlLoadStream)">
            <summary>
            Load data from given XmlElement e
            </summary>
            <param name="e">XmlElement that containes data</param>
            <param name="stream">Helper stream</param>
        </member>
        <member name="M:Skill.Framework.IO.ISavable.Load(Skill.Framework.IO.BinaryLoadStream)">
            <summary>
            Load data from given stream
            </summary>
            <param name="stream">Stream to load data from</param>
        </member>
        <member name="T:Skill.Framework.IO.PCBinaryLoadStream">
            <summary>
            Implement pc(windows) version of BinaryLoadStream
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.#ctor(System.String)">
            <summary>
            Create an instance of PCBinaryLoadStream.
            </summary>
            <param name="fileName"> valid full path of filename. </param>        
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.#ctor(System.IO.Stream)">
            <summary>
            Create an instance of PCBinaryLoadStream.
            </summary>
            <param name="stream">Stream to read from</param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.Close">
            <summary>
            Close Stream
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.ReadInt">
            <summary>
            Read an int32 value for stream
            </summary>
            <returns>Int32</returns>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.ReadFloat">
            <summary>
            Read a float value for stream
            </summary>
            <returns>float</returns>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.ReadBoolean">
            <summary>
            Read a boolean value for stream
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:Skill.Framework.IO.PCBinaryLoadStream.ReadString">
            <summary>
            Read a string value for stream
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Skill.Framework.IO.PCBinarySaveStream">
            <summary>
            Implement pc(windows) version of BinarySaveStream
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.#ctor(System.String,System.Boolean)">
            <summary>
            Create an instance of PCBinarySaveStream.
            </summary>
            <param name="fileName"> valid full path of destination filename. </param>
            <param name="overwrite"> allow overwrite file? </param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.#ctor(System.IO.Stream)">
            <summary>
            Create an instance of PCBinarySaveStream.
            </summary>
            <param name="stream">Strea, to save</param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.Close">
            <summary>
            Close stream
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.Write(System.Int32)">
            <summary>
            Write given int value to stream
            </summary>
            <param name="i">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.Write(System.Single)">
            <summary>
            Write given float value to stream
            </summary>
            <param name="f">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.Write(System.Boolean)">
            <summary>
            Write given boolean value to stream
            </summary>
            <param name="b">value to write</param>
        </member>
        <member name="M:Skill.Framework.IO.PCBinarySaveStream.Write(System.String)">
            <summary>
            Write given string value to stream
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="T:Skill.Framework.IO.PCSaveGame">
            <summary>
            Implements pc(windows) version helper methods to save and load ISavable interface
            </summary>
        </member>
        <member name="F:Skill.Framework.IO.PCSaveGame.RootXmlElementName">
            <summary>
            Name of root XmlElement in xml data
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.CreateFileName(System.String,System.String,System.String)">
            <summary>
            Create a full path filename in 'My Games' directory
            </summary>
            <param name="companyName"> Name of the company</param>
            <param name="gameName">Name of the game</param>
            <param name="fileName"> name of file with extension </param>
            <returns> full path filename in 'My Games' directory </returns>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadFromBinaryFile(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object from binary file
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="fileName"> full path of file</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadFromXmlFile(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object from xml file
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="fileName"> full path of file</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadXmlFromPlayerPrefs(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object from a xml string already saved in PlayerPrefs
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="keyString">key of xmldata in PlayerPrefs</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadBinaryFromPlayerPrefs(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object from a binarydata as string already saved in PlayerPrefs
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="keyString">key of binarydata in PlayerPrefs</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadFromStream(Skill.Framework.IO.ISavable,Skill.Framework.IO.PCBinaryLoadStream)">
            <summary>
            Load specified ISavable object from a stream
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="stream">Stream to load</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.LoadFromXmlContent(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object from a xml data
            </summary>
            <param name="savable">ISavable to load</param>
            <param name="xmlContent">String contains xml data</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveToBinaryFile(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object to binary file
            </summary>
            <param name="savable">ISavable to save</param>
            <param name="fileName"> full path of destination file</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveToXmlFile(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Load specified ISavable object to xml file
            </summary>
            <param name="savable">ISavable to save</param>        
            <param name="fileName"> full path of destination file</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveXmlToPlayerPrefs(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Save specified ISavable object to a xml string in PlayerPrefs
            </summary>
            <param name="savable">ISavable to save</param> 
            <param name="keyString">key of xmldata in PlayerPrefs</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveToBinaryString(Skill.Framework.IO.ISavable)">
            <summary>
            Save specified ISavable object to binary string
            </summary>
            <param name="savable">ISavable to save</param>         
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveBinaryToPlayerPrefs(Skill.Framework.IO.ISavable,System.String)">
            <summary>
            Save specified ISavable object to binary data as string in PlayerPrefs
            </summary>
            <param name="savable">ISavable to save</param> 
            <param name="keyString">key of binarydata in PlayerPrefs</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveToStream(Skill.Framework.IO.ISavable,Skill.Framework.IO.PCBinarySaveStream)">
            <summary>
            Save specified ISavable object to stream
            </summary>
            <param name="savable">ISavable to save</param> 
            <param name="stream">Stream to save</param>
        </member>
        <member name="M:Skill.Framework.IO.PCSaveGame.SaveToXmlContent(Skill.Framework.IO.ISavable)">
            <summary>
            Save specified ISavable object to xml content
            </summary>
            <param name="savable">ISavable to save</param> 
            <returns>Saved data as string in xml format</returns>
        </member>
        <member name="T:Skill.Framework.IO.CreateISavable`1">
            <summary>
            defines a method to instantiate ISavable T
            </summary>
            <typeparam name="T">ISavable to instantiate</typeparam>
            <returns>A valid instance of ISavable T</returns>
        </member>
        <member name="T:Skill.Framework.IO.XmlLoadStream">
            <summary>
            This class provides all required methods to load an ISavable class from Xml format. 
            you do not need to use read methods of this class, Skill Studio takes care of it.
            </summary>
            <remarks>
            Because content of Xml format can be modfied by final users and slower than binary, Xml format is useful for debuging.
            Skill IO Xml saving algorithm designed to allow modify savable classes and still read from previous data (new data will be in default value).
            so in Xml mode (debug time) you can add or remove new variables in Savable class designed in Skill Studio, and load savable class from previous data ( from HDD or PlayerPrefs and ...).
            when your game is created and ready to release switch to binary format.
            </remarks>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadInt(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as int
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>int</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadFloat(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as float
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>float</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadBoolean(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as boolean
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>bool</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadString(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as string
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>string</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadBounds(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Bounds
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Bounds</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadColor(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Color
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Color</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadMatrix4x4(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Matrix4x4
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Matrix4x4</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadPlane(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Plane
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Plane</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadQuaternion(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Quaternion
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Quaternion</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadRay(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Ray
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Ray</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadRect(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Rect
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Rect</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector2(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Vector2
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Vector2</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector3(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Vector3
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Vector3</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector4(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as Vector4
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>Vector4</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadSavable``1(Skill.Framework.IO.XmlElement,Skill.Framework.IO.CreateISavable{``0})">
            <summary>
            Read data of given XmlElement as specified ISavable
            </summary>                
            <typeparam name="T">type of ISavable to read</typeparam>
            <param name="e">XmlElement contains data</param>
            <param name="creator">Helper method for instantiation of T</param>
            <returns>Instance of T</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadSavableArray``1(Skill.Framework.IO.XmlElement,Skill.Framework.IO.CreateISavable{``0})">
            <summary>
            Read data of given XmlElement as array of specified ISavable
            </summary>                
            <typeparam name="T">type of ISavable to read</typeparam>
            <param name="e">XmlElement contains data</param>
            <param name="creator">Helper method for instantiation of T</param>
            <returns>array of instance of T</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadIntArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of int
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of int</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadFloatArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of float
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of float</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadBooleanArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of boolean
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of bool</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadStringArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of string
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of string</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadBoundsArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Bounds
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Bounds</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadColorArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Color
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Color</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadMatrix4x4Array(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Matrix4x4
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Matrix4x4</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadPlaneArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Plane
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Plane</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadQuaternionArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Quaternion
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Quaternion</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadRayArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Ray
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Ray</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadRectArray(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Rect
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Rect</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector2Array(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Vector2
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Vector2</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector3Array(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Vector3
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Vector3</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlLoadStream.ReadVector4Array(Skill.Framework.IO.XmlElement)">
            <summary>
            Read data of given XmlElement as array of Vector4
            </summary>
            <param name="e">XmlElement contains data</param>
            <returns>array of Vector4</returns>
        </member>
        <member name="T:Skill.Framework.IO.XmlSaveStream">
            <summary>
            This class provides all required methods to save an ISavable class in Xml format. 
            you do not need to use read methods of this class, Skill Studio takes care of it.
            </summary>
            <remarks>
            Because content of Xml format can be modfied by final users and slower than binary, Xml format is useful for debuging.
            Skill IO Xml saving algorithm designed to allow modify savable classes and still read from previous data (new data will be in default value).
            so in Xml mode (debug time) you can add or remove new variables in Savable class designed in Skill Studio, and load savable class from previous data ( from HDD or PlayerPrefs and ...).
            when your game is created and ready to release switch to binary format.
            </remarks>
        </member>
        <member name="F:Skill.Framework.IO.XmlSaveStream.NoData">
            <summary>
            when an instance of ISavable class is null the content of Xml element will be NoData
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.#ctor">
            <summary>
            Create an instance of XmlSaveStream
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.#ctor(Skill.Framework.IO.ISavable)">
            <summary>
            Create an instance of XmlSaveStream and save given ISavable
            </summary>
            <param name="savable">ISavable to save</param>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Int32)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="i">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Single)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="f">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Boolean)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="b">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.String)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="s">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Bounds)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="bound">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Color)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="color">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Matrix4x4)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="matrix">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Plane)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="plane">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Quaternion)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="quaternion">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Ray)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="ray">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Rect)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="rect">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector2)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="vector">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector3)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="vector">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector4)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="vector">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create``1(System.String,``0)">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="savable">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create``1(System.String,``0[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <typeparam name="T">Type of ISavable</typeparam>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="savables">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Int32[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Single[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.Boolean[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,System.String[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Bounds[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Color[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Matrix4x4[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Plane[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Quaternion[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Ray[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Rect[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector2[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector3[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlSaveStream.Create(System.String,UnityEngine.Vector4[])">
            <summary>
            Create an XmlElement containing property data
            </summary>
            <param name="propertyName">Name of property (XmlElement)</param>
            <param name="primitives">data to save</param>
            <returns>XmlElement containig data</returns>
        </member>
        <member name="P:Skill.Framework.IO.XmlSaveStream.Document">
            <summary>
            The document contains all saved data. save content of Document to file or everywhere as needed
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheBehavior">
            <summary>
            Behavior that required for a Cacheable object
            </summary>    
            <remarks>
            when an object is cached, it instantiated at scene start but disabled, and because unity call Awake and OnEnable method right after instantiation, sometimes
            it is better to set cachable prefab to be deactivated. for example if there is a "ShakeOnEnable" component on GameObject when you play game you can see a shake camera
            happens when game started, it is because OnEnable of "ShakeOnEnable" was called at initialize time. if you set GameObject to be deactivated in prefab, initialize time of cachable object
            do not shake camera.
            Oo... do not bother yourself to understand my weak english(:D) just "select prefab and uncheck the checkbox at top left corner of inspector"
            </remarks>
        </member>
        <member name="P:Skill.Framework.Managers.CacheBehavior.CacheId">
            <summary> Unique id for all instance of this object </summary>
        </member>
        <member name="P:Skill.Framework.Managers.CacheBehavior.IsCached">
            <summary> whether this object collected by CacheSpawner or not </summary>
        </member>
        <member name="P:Skill.Framework.Managers.CacheBehavior.Group">
            <summary> Group </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheGroup">
            <summary>
            Group of CacheObjects for better management
            </summary>    
        </member>
        <member name="F:Skill.Framework.Managers.CacheGroup.InitializeOnAwake">
            <summary> create all cached objects on awake </summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheGroup.MakeAsChild">
            <summary> create all cached objects as childs of group </summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheGroup.CleanInterval">
            <summary> Clean Interval of this group</summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheGroup.Caches">
            <summary> CacheObjects </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheGroup.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheGroup.OnDestroy">
            <summary>
            On Destroy
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheGroup.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheLifeTime">
            <summary>
            After specific time CacheObject automatically cached
            </summary>        
        </member>
        <member name="F:Skill.Framework.Managers.CacheLifeTime.LifeTime">
            <summary>
            Life Time
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheLifeTime.OnEnable">
            <summary>
            On Enable
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheLifeTime.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheObject">
            <summary>
            Information about an GameObject by CacheBehavior component
            </summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheObject.Prefab">
            <summary> Cacheable GameObject</summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheObject.CacheSize">
            <summary> Number of instances to create at initialize time</summary>
        </member>
        <member name="F:Skill.Framework.Managers.CacheObject.Growable">
            <summary> Is Growable?</summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheObject.Initialize(Skill.Framework.Managers.CacheGroup)">
            <summary>
            Initialize and instantiate objects
            </summary>
            <param name="group">Group</param>
        </member>
        <member name="M:Skill.Framework.Managers.CacheObject.Next">
            <summary>
            Get next available and deactive object to reuse
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Managers.CacheObject.Free(UnityEngine.GameObject)">
            <summary>
            Add unused GameObject to free list
            </summary>
            <param name="objToFree"> unused GameObject </param>
        </member>
        <member name="M:Skill.Framework.Managers.CacheObject.Destroy">
            <summary>
            Destroy all instances
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheObject.Clean">
            <summary>
            Clean
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.CacheObject.Group">
            <summary> Group </summary>
        </member>
        <member name="P:Skill.Framework.Managers.CacheObject.CacheId">
            <summary> Unique id (same as CacheBehavior.CacheId ) </summary>
        </member>
        <member name="T:Skill.Framework.EventManager">
            <summary>    
            This class designed to avoid using SendMessage. 
            </summary>    
            <remarks>
            i think SenMessage can be expensive because it must use reflection to know which behavior has requested method    
            so i use this way to call methods on MonoBehaviors. this needs more work to do
            besides you always know format of methods and what prameters to sent
            each game must defines it's own EventManager
            </remarks>
            <example> for example    
            <code>
            public class ThisGameEventManager : EventManager
            {
                public delegate void OnHitHandler(UnityEngine.Collider other);   
                public event OnHitHandler Hit;
                    
                public void OnHit(UnityEngine.Collider other)
                {
                    if (Hit != null)
                        Hit(other);
                }
            }
            
            public class PLayer : MonoBehaviour
            {    
                void Awake()
                {
                    HookEvents();
                }    
            
                public void HookEvents()
                {    
                    ThisGameEventManager eventManager = ThisGameEventManager.Get;ltThisGameEventManager;gt(this.gameObject);
                    if (eventManager != null)
                    {                
                        eventManager.Hit += OnHit;
                    }
                }    
                    
                private void OnHit(UnityEngine.Collider other)
                {
                    // do something
                }
            }    
            </code>
            
            other behaviors could call OnHit method to notify interested behaviors
            </example>              
        </member>
        <member name="M:Skill.Framework.EventManager.RaiseHit(System.Object,Skill.Framework.HitEventArgs)">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> sender </param>
            <param name="args"> An HitEventArgs that contains hit event data. </param>        
        </member>
        <member name="M:Skill.Framework.EventManager.RaiseDie(System.Object,System.EventArgs)">
            <summary>
            Notify GameObject is dead
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="e"> An System.EventArgs that contains no event data. </param>
        </member>
        <member name="M:Skill.Framework.EventManager.RaiseDamage(System.Object,Skill.Framework.DamageEventArgs)">
            <summary>
            Handle imposed damage
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> An DamageEventArgs that contains damage event data.</param>
        </member>
        <member name="M:Skill.Framework.EventManager.RaiseCached(System.Object,Skill.Framework.Managers.CacheEventArgs)">
            <summary>
             Occurs when some object cached (called by Managers.Cache)
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> An Managers.CacheEventArgs that contains cache event data.</param>
        </member>
        <member name="E:Skill.Framework.EventManager.Hit">
            <summary>
            Occurs when a ray or somthing Hit this GameObject
            </summary>
        </member>
        <member name="E:Skill.Framework.EventManager.Die">
            <summary>
            Occurs when this GameObject is dead
            </summary>
        </member>
        <member name="E:Skill.Framework.EventManager.Damage">
            <summary>
            Occurs when some damage imposed
            </summary>
        </member>
        <member name="E:Skill.Framework.EventManager.Cached">
            <summary>
            Occurs when some object cached
            </summary>
        </member>
        <member name="T:Skill.Framework.HitEventHandler">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="args"> damage args </param>
        </member>
        <member name="T:Skill.Framework.DamageEventHandler">
            <summary>
            Handle imposed damage
            </summary>    
            <param name="sender">The source of the event.</param>
            <param name="args"> damage args </param>
        </member>
        <member name="T:Skill.Framework.Managers.SearchGridResult">
            <summary>
            Contains information about found transforms after searching grids
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGridResult.#ctor(UnityEngine.Transform,System.Single)">
            <summary>
            Create a SearchGridResult
            </summary>
            <param name="transform">Found Transform</param>
            <param name="distance">Distance to center of search</param>
        </member>
        <member name="P:Skill.Framework.Managers.SearchGridResult.Transform">
            <summary>
            Found Transform
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.SearchGridResult.Distance">
            <summary>
            Distance to center of search. can be used to sort transforms
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.SearchGridResultComparer">
            <summary>
            A Comparer of SearchGridResult to use in sort algorithm
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGridResultComparer.Compare(Skill.Framework.Managers.SearchGridResult,Skill.Framework.Managers.SearchGridResult)">
            <summary>
            Compare two given SearchGridResult 
            </summary>
            <param name="x">First SearchGridResult </param>
            <param name="y">Second SearchGridResult </param>
            <returns>Result of compare</returns>
        </member>
        <member name="P:Skill.Framework.Managers.SearchGridResultComparer.Descending">
            <summary>
            Compare for descending sort
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.SearchGrid2D">
            <summary>
            This class contains as need as Grid2Ds to keep track of, and quickly search, any Game Objects in a level.
            The center of SearchGrid2D is (0,0). just look at Transform.position and place GameObject somewhere in Grid2D.
            If an object is dynamic you have to update it in SearchGrid2D whenever it moves.
            </summary>
            <remarks>
            Usually this class is usefull for keep track of ai information like : cover points, shelters, ... .
            if objects have colliders, it is beter to use Physics.OverlapSphere.
            </remarks>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.#ctor(System.Int32,System.Single)">
            <summary>
            Create a SearchGrid2D
            </summary>
            <param name="gridDimension"> Dimention of each grid along x or z axis </param>
            <param name="quadSize">Size of each quad along x or z axis</param>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.Add(UnityEngine.Transform)">
            <summary>
            Add Transform to search grid
            </summary>
            <param name="transform">Transform to add</param>        
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.Remove(UnityEngine.Transform)">
            <summary>
            Remove Transform from search grid
            </summary>
            <param name="transform">Transform to remove</param>        
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.Update(UnityEngine.Transform)">
            <summary>
            Update Transform in search grid. use this method whenever object moves.
            </summary>
            <param name="transform">Transform to update</param>           
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.GetQuadGrid(UnityEngine.Vector3@,System.Boolean)">
            <summary>
            find thegrid that contains specified point
            </summary>
            <param name="position">Point to check</param>
            <param name="create"> Create grid if does not exist (created yet) </param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.OverlapCircle(UnityEngine.Vector3,System.Single,System.String)">
            <summary>
            Search for Transforms in specified circle
            </summary>
            <param name="center">Center of circle</param>
            <param name="radius">Radius of circle</param>
            <param name="tag">Tag to filter Transforms</param>
            <returns>List of SearchGridResult that is inside circle</returns>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.OverlapCircle(UnityEngine.Vector3,System.Single,System.Collections.Generic.List{Skill.Framework.Managers.SearchGridResult},System.String)">
            <summary>
            Search for Transforms in specified circle
            </summary>
            <param name="position">Center of circle</param>
            <param name="radius">Radius of circle</param>                
            <param name="objects">List of objects to fill</param>
            <param name="tag">Tag to filter Transforms</param>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.Clear">
            <summary>
            Clear and remove all Transforms from search grid
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.GetEnumerator">
            <summary>
            Get enumerators of Grid2Ds
            </summary>
            <returns>IEnumerator</returns>
        </member>
        <member name="M:Skill.Framework.Managers.SearchGrid2D.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerators of Grid2Ds
            </summary>
            <returns>IEnumerator</returns>
        </member>
        <member name="P:Skill.Framework.Managers.SearchGrid2D.QuadSize">
            <summary>
            Size of each quad along x or z axis
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.SearchGrid2D.GridDimension">
            <summary>
            Dimention of each grid along x or z axis
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.Grid2D">
            <summary>
            A larger 2d rectangle in world made of array of quads
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.Contains(UnityEngine.Vector3@)">
            <summary>
            Whether this Grid2D contains given point in 2D space
            </summary>
            <param name="pos">Point to check</param>
            <returns>True if containes, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.Contains(UnityEngine.Vector3)">
            <summary>
            Whether this Grid2D contains given point in 2D space
            </summary>
            <param name="pos">Point to check</param>
            <returns>True if containes, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create an instance of Grid2D
            </summary>
            <param name="dimention"> Number of quads in each row and column</param>
            <param name="x">Start position of Grid2D in x axis (min X)</param>
            <param name="z">Start position of Grid2D in z axis (min Z)</param>
            <param name="quadSize">Size of each quad</param>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.Add(UnityEngine.Transform)">
            <summary>
            Add transform to Grid
            </summary>
            <param name="transform">Transform to add</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.Remove(UnityEngine.Transform)">
            <summary>
            Remove transform from Grid
            </summary>
            <param name="transform">Transform to remove</param>
            <returns>True if success, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.GetQuadIndex(UnityEngine.Vector3@,System.Int32@,System.Int32@)">
            <summary>
            Specify given point is in witch quad index
            </summary>
            <param name="pos">Point to check</param>
            <param name="row"> Row index of quad (if found) </param>
            <param name="column"> Column index of quad (if found) </param>
            <returns>True if point is inside of this Grid2D, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.GetQuad(UnityEngine.Vector3,System.Boolean)">
            <summary>
            Get the quad that includes specified point
            </summary>
            <param name="pos">Point to check</param>
            <param name="create">Create quad if does not exist (created yet)</param>
            <returns> The quad that includes specified point</returns>
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.GetQuads(UnityEngine.Vector3,System.Single,Skill.Framework.Managers.Quad[],System.Int32)">
            <summary>
            Get list of quads that intersect specified circle
            </summary>
            <param name="pos">Position of circle</param>
            <param name="radius">Radius of circle</param>
            <param name="quads">The destination of the quads to copy quads</param>
            <param name="startIndex">The zero-based index in array at which copying begins.</param>
            <returns>number of quads that intersect specified circle</returns>                
        </member>
        <member name="M:Skill.Framework.Managers.Grid2D.Clear">
            <summary>
            Remove all registered Transforms from Grid
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Quads">
            <summary>
            Array of quads in size [Dimention , Dimention]
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Dimention">
            <summary> Number of quads in each row and column </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.X">
            <summary> Start position of Grid2D in x axis (min X) </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Z">
            <summary> Start position of Grid2D in z axis (min Z) </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Right">
            <summary> End position of Grid2D in x axis (max X) </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Top">
            <summary> End position of Grid2D in z axis (max Z) </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.QuadSize">
            <summary> Size of each quad </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Grid2D.Length">
            <summary> Lenght of Grid2D along x or z axis (Dimention * QuadSize) </summary>
        </member>
        <member name="T:Skill.Framework.Managers.Quad">
            <summary>
            Defines a rectangular 2D space
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.Quad.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a Quad
            </summary>
            <param name="row">Row index of quad in Grid2D</param>
            <param name="column">Column index of quad in Grid2D</param>
        </member>
        <member name="P:Skill.Framework.Managers.Quad.Objetcs">
            <summary>
            List of transforms inside quad
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Quad.Row">
            <summary>
            Row index of quad in Grid2D
            </summary>
        </member>
        <member name="P:Skill.Framework.Managers.Quad.Column">
            <summary>
            Column index of quad in Grid2D
            </summary>
        </member>
        <member name="T:Skill.Framework.MathHelper">
            <summary>
            Some helper methods for math
            </summary>
        </member>
        <member name="M:Skill.Framework.MathHelper.IsAngleLeftOf(System.Single,System.Single)">
            <summary>
            Wether given angle is between (sourceAngle) and (sourceAngle - 180)
            </summary>
            <param name="angle">Angle</param>
            <param name="sourceAngle">Source angle</param>
            <returns>True if angle is left side, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.HorizontalAngle(UnityEngine.Vector3)">
            <summary>
            Calc angle rotation around y axis
            </summary>
            <param name="direction">Direction</param>
            <returns>Angle</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.HorizontalAngle(System.Single,System.Single)">
            <summary>
            Calc angle rotation around y axis
            </summary>
            <param name="x">Direction.x</param>
            <param name="z">Direction.z</param>
            <returns>Angle</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.ClampAngle(System.Single)">
            <summary>
            Keep angle between -180 to 180
            </summary>
            <param name="angle">Angle to validate</param>
            <returns>angle between -180 to 180</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.ClampAngle(System.Single@)">
            <summary>
            Keep angle between -180 to 180
            </summary>
            <param name="angle">Angle to validate</param>        
        </member>
        <member name="M:Skill.Framework.MathHelper.AngleAroundAxis(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            The angle between dirA and dirB around axis
            </summary>
            <param name="dirA">Direction A</param>
            <param name="dirB">Direction B</param>
            <param name="axis">Axis</param>
            <returns>The angle between dirA and dirB around axis</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.MPS_To_KPH(System.Single)">
            <summary>
            Converts 'Meter Per Second' to 'Kilometer Per Hour'
            </summary>
            <param name="mps">value in meter per second</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.QuickSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort array
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="array">Array to sort</param>
            <param name="comparer">Comparer to compare items</param>
        </member>
        <member name="M:Skill.Framework.MathHelper.ProjectPointOnLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            calc projection of a point on a line
            </summary>
            <param name="point">Point</param>
            <param name="lineStart">Start of line</param>
            <param name="lineDirection">Direction of line</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.GetLayerMask(System.Int32[])">
            <summary>
            Calculate 32bit integer layermask
            </summary>
            <param name="layerIndices">Index of layers</param>
            <returns>layermask</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.FrameFrustumHeight(UnityEngine.Camera,System.Single)">
            <summary>
            Calculate distance to camera where height of frustum is specified value
            </summary>
            <param name="camera">Camera</param>
            <param name="frustumHeight">Height of frustum</param>
            <returns>distance to camera</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.FrameFrustumWidth(UnityEngine.Camera,System.Single)">
            <summary>
            Calculate distance to camera where width of frustum is specified value
            </summary>
            <param name="camera">Camera</param>
            <param name="frustumWidth">Width of frustum</param>
            <returns>distance to camera</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.GetCirclePath(System.Int32)">
            <summary>
            Calclate points on a xzplane circle with specified resolution
            </summary>
            <param name="resolution">number of points (at least 3)</param>
            <returns>Circle path</returns>
        </member>
        <member name="M:Skill.Framework.MathHelper.NormalizeAndMagnitude(UnityEngine.Vector3@)">
            <summary>
            Normalize vector3 and calc magnitude
            </summary>
            <param name="v">Vector3</param>
            <returns>Magnitude of Vector3</returns>
        </member>
        <member name="T:Skill.Framework.Modules.Vehicles.PuncturableChassis">
            <summary>
            This behaviour is useful for situations like when a static car placed besides of street and you want it's wheel be puncturable but without using RigidBodies.
            assign this components to chassis and set reference of chassis to each child wheel.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableChassis.PunctureSmoothing">
            <summary> Parameters of how smooth rotation of chassis when a wheel is punctured </summary>
        </member>
        <member name="M:Skill.Framework.Modules.Vehicles.PuncturableChassis.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.Vehicles.PuncturableChassis.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.Vehicles.PuncturableChassis.NotifyWheelPuncture(Skill.Framework.Modules.Vehicles.PuncturableWheel)">
            <summary>
            Notify chassis that a wheel is punctured
            </summary>
            <param name="puncturedWheel"> Punctured wheel </param>
        </member>
        <member name="T:Skill.Framework.Modules.Vehicles.PuncturableWheel">
            <summary>
            This behaviour is useful for situations like when a static car placed besides of street and you want it's wheel be puncturable but without using RigidBodies.
            assign this components to each wheel and set valid reference to Chassis.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.Chassis">
            <summary> Puncturable Chassis </summary>
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.PuncturePrefab">
            <summary> a prefab like 'wheel his' to spawn when wheel is punctured </summary>
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.PuncturePrefabDirection">
            <summary> Rotation of PuncturePrefab relate to wheel </summary>
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.PunctureHeight">
            <summary> delta height to apply wheel when wheel is punctured </summary>
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.PunctureRotation">
            <summary> delta rotation to apply Chassis when wheel is punctured </summary>
        </member>
        <member name="F:Skill.Framework.Modules.Vehicles.PuncturableWheel.PunctureHitType">
            <summary> Type of hits that cause puncture </summary>
        </member>
        <member name="M:Skill.Framework.Modules.Vehicles.PuncturableWheel.Events_Hit(System.Object,Skill.Framework.HitEventArgs)">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> sender </param>
            <param name="args"> An HitEventArgs that contains hit event data. </param>
        </member>
        <member name="T:Skill.Framework.Settings">
            <summary>
            A general settings class that contains all variables needed for games, that provides some methods to ease process of save/load settings.
            is is possible to save/load settings in binary and xml formats. New variables will be added in future versions.
            Override virtual methods to fit your default settings.
            </summary>
        </member>
        <member name="T:Skill.Framework.Settings.AntiAliasing">
            <summary>The AA Filtering option. </summary>
        </member>
        <member name="T:Skill.Framework.Settings.ShadowCascades">
            <summary> Number of cascades to use for directional light shadows. </summary>
        </member>
        <member name="T:Skill.Framework.Settings.VSyncCount">
            <summary> The VSync Count. </summary>
        </member>
        <member name="M:Skill.Framework.Settings.AudioSettings.SetAsCurrentSetting">
            <summary>
            read from UnityEngine.AudioSettings. this is useful when Game started for first time
            </summary>
        </member>
        <member name="M:Skill.Framework.Settings.QualitySettings.SetAsCurrentSetting">
            <summary>
            read from UnityEngine.QualitySettings. this is useful when Game started for first time
            </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.AnisotropicFiltering">
            <summary>   Global anisotropic filtering mode. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.AntiAliasing">
            <summary> Set The AA Filtering option. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.BlendWeights">
            <summary>   Blend weights. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.LodBias">
            <summary>   Global multiplier for the LOD's switching distance. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.MasterTextureLimit">
            <summary>   A texture size limit applied to all textures. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.MaximumLODLevel">
            <summary>   A maximum LOD level. All LOD groups </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.MaxQueuedFrames">
            <summary> Maximum number of frames queued up by graphics driver. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.ParticleRaycastBudget">
            <summary> Budget for how many ray casts can be performed per frame for approximate collision testing. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.PixelLightCount">
            <summary> The maximum number of pixel lights that should affect any object. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.ShadowCascades">
            <summary>   Number of cascades to use for directional light shadows. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.ShadowDistance">
            <summary>   Shadow drawing distance. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.ShadowProjection">
            <summary> Directional light shadow projection. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.SoftVegetation">
            <summary> Use a two-pass shader for the vegetation in the terrain engine. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.VSyncCount">
            <summary> The VSync Count. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.Bloom">
            <summary> Enable or disable bloom effect </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.HDR">
            <summary> Enable or disable HDR effect </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.AmbientOcclusion">
            <summary> Enable or disable AmbientOcclusion </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.PostprocessQuality">
            <summary> Gets of sets postprocess quality </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.ShadowQuality">
            <summary> Gets of sets shadow quality </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.Resolution">
            <summary> Gets of sets resolution </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.FullScreen">
            <summary> Gets of sets fullscreen </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.QualityLevel">
            <summary> Graphics quality level. </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideAnisotropicFiltering">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.anisotropicFiltering'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideAntiAliasing">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.antiAliasing'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideBlendWeights">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.blendWeights'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideLodBias">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.lodBias'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideMasterTextureLimit">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.masterTextureLimit'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideMaximumLODLevel">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.maximumLODLevel'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideMaxQueuedFrames">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.maxQueuedFrames'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideParticleRaycastBudget">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.particleRaycastBudget'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverridePixelLightCount">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.pixelLightCount'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideShadowCascades">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.shadowCascades'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideShadowDistance">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.shadowDistance'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideShadowProjection">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.shadowProjection'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideSoftVegetation">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.softVegetation'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.QualitySettings.OverrideVSyncCount">
            <summary> if true, ApplyChanges() will override 'UnityEngine.QualitySettings.vSyncCount'.This value is will saved to file </summary>
        </member>
        <member name="P:Skill.Framework.Settings.KeyMap.Index">
            <summary>
            Index of key
            </summary>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetIndex(System.String)">
            <summary>
            Find index of keyname.(used to access faster later)
            </summary>
            <param name="keyName">Name of key</param>
            <returns>Index of KeyMap</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKey(System.String)">
            <summary>
            Returns true while the user holds down the key identified by name. Think auto fire. 
            </summary>
            <param name="keyName">Name of key</param>
            <returns>Ttrue while the user holds down the key, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKey(System.Int32)">
            <summary>
            Returns true while the user holds down the key identified by name. Think auto fire. 
            </summary>
            <param name="keyIndex">Index of key</param>
            <returns>Ttrue while the user holds down the key, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKeyDown(System.String)">
            <summary>
            Returns true during the frame the user starts pressing down the key identified by name. 
            </summary>
            <param name="keyName">Name of key</param>
            <returns>True if the user starts pressing down the key, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKeyDown(System.Int32)">
            <summary>
            Returns true during the frame the user starts pressing down the key identified by name. 
            </summary>
            <param name="keyIndex">Index of key</param>
            <returns>True if the user starts pressing down the key, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKeyUp(System.String)">
            <summary>
            Returns true during the frame the user releases the key identified by name.
            </summary>
            <param name="keyName">Name of key</param>
            <returns>True if the user releases the key, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Settings.InputSettings.GetKeyUp(System.Int32)">
            <summary>
            Returns true during the frame the user releases the key identified by name.
            </summary>
            <param name="keyIndex">Index of key</param>
            <returns>True if the user releases the key, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.Settings.InputSettings.Item(System.String)">
            <summary>
            Get key by name
            </summary>
            <param name="keyName">Name of key</param>
            <returns>KeyMap</returns>
        </member>
        <member name="P:Skill.Framework.Settings.InputSettings.Item(System.Int32)">
            <summary>
            Get key by index
            </summary>
            <param name="keyIndex">Index of key</param>
            <returns>KeyMap</returns>
        </member>
        <member name="P:Skill.Framework.Settings.InputSettings.KeyCount">
            <summary>
            Retrieves number of keys
            </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.PitchController">
            <summary>
            Place one instance of this component in scene to control pitch of sounds.
            Add PitchListener to every GameObjects that affets global pitch.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Sounds.PitchController.PitchSmoothing">
            <summary>
            How to smooth pitch
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchController.Awake">
            <summary>
            Awake is called when the script instance is being loaded.
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchController.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchController.Change(System.Single,System.Single,System.Boolean)">
            <summary>
            Change pitch for specific time than fallback
            </summary>
            <param name="targetPitch">Target pitch</param>
            <param name="length">lenght of change</param>
            <param name="realtime"> use realtime or gametime?</param>
        </member>
        <member name="P:Skill.Framework.Sounds.PitchController.Instance">
            <summary>
            Global instance of PitchController 
            </summary>
        </member>
        <member name="P:Skill.Framework.Sounds.PitchController.Pitch">
            <summary>
            Gets of sets global pitch value
            </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.RandomSound">
            <summary>
            Play random sound on enable
            </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.RandomSound.Sounds">
            <summary> Array of sounds to play in random </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.RandomSound.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.RandomSound.PlaySound">
            <summary>
            Play random sound
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.RandomSound.OnEnable">
            <summary>
            This function is called when the object becomes enabled and active.
            </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.SoundCategory">
            <summary>
            Defines sound categories. one of benefits of categorizing sounds is to play sounds in deferent volumes and allow player choose volume of each category 
            </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundCategory.None">
            <summary> None </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundCategory.FX">
            <summary> Sound Effects ( like : gunfire, collisions, ... ) </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundCategory.Music">
            <summary> Background music </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundCategory.Voice">
            <summary> Dialog of characters </summary>
        </member>
        <member name="F:Skill.Framework.Sounds.SoundCategory.Cinematic">
            <summary> sound of Cutscenes and Cinematics </summary>
        </member>
        <member name="T:Skill.Framework.Sounds.PitchListener">
            <summary>
            Listen to PitchController.Instance.Pitch
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchListener.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchListener.Start">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchListener.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Sounds.PitchListener.RelinkAudios">
            <summary>
            if number of AudioSources attached to this gameobject is dynamic. call this before change pitch to find all audios again
            </summary>
        </member>
        <member name="T:Skill.Framework.SmoothType">
            <summary>
            Types of smoothing
            </summary>
        </member>
        <member name="F:Skill.Framework.SmoothType.Damp">
            <summary> Just using SmoothTime value of SmoothingParams</summary>
        </member>
        <member name="F:Skill.Framework.SmoothType.DampSpeed">
            <summary> using SmoothTime and MaxSpeed value of SmoothingParams</summary>
        </member>
        <member name="F:Skill.Framework.SmoothType.DampSpeedAndTime">
            <summary> using SmoothTime, MaxSpeed and DeltaTimeFactor value of SmoothingParams</summary>
        </member>
        <member name="T:Skill.Framework.SmoothingParameters">
            <summary>
            Parameters of Smoothing algorithm
            </summary>
        </member>
        <member name="F:Skill.Framework.SmoothingParameters.SmoothType">
            <summary> Type of Smoothing </summary>
        </member>
        <member name="F:Skill.Framework.SmoothingParameters.SmoothTime">
            <summary> Approximately the time it will take to reach the target. A smaller value will reach the target faster.</summary>
        </member>
        <member name="F:Skill.Framework.SmoothingParameters.MaxSpeed">
            <summary> Optionally allows you to clamp the maximum speed. </summary>
        </member>
        <member name="F:Skill.Framework.SmoothingParameters.DeltaTimeFactor">
            <summary> The factor of Time.deltaTime( The time since the last call to this function ). </summary>
        </member>
        <member name="T:Skill.Framework.Smoothing">
            <summary>
            Simplify using Mathf.SmoothDamp
            </summary>
        </member>
        <member name="M:Skill.Framework.Smoothing.Update(Skill.Framework.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="M:Skill.Framework.Smoothing.Reset(System.Single)">
            <summary>
            Reset current and target
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="P:Skill.Framework.Smoothing.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Framework.Smoothing.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.Framework.SmoothingAngle">
            <summary>
            Simplify using Mathf.SmoothDampAngle
            </summary>
        </member>
        <member name="M:Skill.Framework.SmoothingAngle.Update(Skill.Framework.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="M:Skill.Framework.SmoothingAngle.Reset(System.Single)">
            <summary>
            Reset current and target
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="P:Skill.Framework.SmoothingAngle.CurrentAngle">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Framework.SmoothingAngle.TargetAngle">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.Framework.Smoothing2D">
            <summary>
            Simplify using Mathf.SmoothDamp for two value
            </summary>
        </member>
        <member name="M:Skill.Framework.Smoothing2D.Update(Skill.Framework.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="M:Skill.Framework.Smoothing2D.Reset(UnityEngine.Vector2)">
            <summary>
            Reset current and target
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="P:Skill.Framework.Smoothing2D.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Framework.Smoothing2D.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.Framework.Smoothing3D">
            <summary>
            Simplify using Mathf.SmoothDamp for two value
            </summary>
        </member>
        <member name="M:Skill.Framework.Smoothing3D.Update(Skill.Framework.SmoothingParameters)">
            <summary>
            Update one step and return result
            </summary>
            <param name="sp">Parameters of Smoothing ( can be modified in inspector)</param>
            <returns>Smooth result</returns>
        </member>
        <member name="M:Skill.Framework.Smoothing3D.Reset(UnityEngine.Vector3)">
            <summary>
            Reset current and target
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="P:Skill.Framework.Smoothing3D.Current">
            <summary> Last result of call Update function </summary>
        </member>
        <member name="P:Skill.Framework.Smoothing3D.Target">
            <summary> The position we are trying to reach. </summary>
        </member>
        <member name="T:Skill.Framework.Text.PersianTextConverter">
            <summary>
            Convert a text contains of none persian characters to equivalent persian characters.
            </summary>
            <remarks>
            this version of converter does not care about changes of text and use light calculation to convert text.
            use this class when you want convert static texts, or when your TextField is RightToLeft (currently unity does not support RTL TextFields)
            </remarks>
        </member>
        <member name="T:Skill.Framework.Text.ITextConverter">
            <summary>
            Convert text to other format(in other language)
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.ITextConverter.Convert(System.String)">
            <summary>
            Convert specified text
            </summary>
            <param name="source">Source text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="M:Skill.Framework.Text.PersianTextConverter.#ctor(Skill.Framework.Text.IPersianCharacterMap,System.Int32)">
            <summary>
            Create a PersianTextConverter
            </summary>
            <param name="characterMap">Character mapping information for persian language</param>
            <param name="maxLength">Maximum length of text ( for better performance)</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianTextConverter.Convert(System.String)">
            <summary>
            Convert specified text to equivalent persian text
            </summary>
            <param name="text">Text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextConverter.CharacterMap">
            <summary>
            IPersianCharacterMap provided for this converter
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextConverter.MaxLength">
            <summary>
            Maximum length of text ( for better performance)
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextConverter.RightToLeft">
            <summary>
            if your TextField is right to left set this parameter to true
            </summary>
            <remarks>
            Unity currently does not support right to left TextField, so to convert text in LTR format to RTL persian format
            we have to reverse text.
            </remarks>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextConverter.ConvertLigature">
            <summary>
            Whether convert لا and الله to one equivalent character. (default true)
            </summary>
        </member>
        <member name="T:Skill.Framework.TimeWatch">
            <summary>
            Helper class for track time
            </summary>
        </member>
        <member name="M:Skill.Framework.TimeWatch.Begin(System.Single,System.Boolean)">
            <summary>
            Begin timer 
            </summary>
            <param name="length">Lenght of timer</param>
            <param name="useRealTime">if true TimeWatch use Time.realtimeSinceStartup instead of Time.time</param>
        </member>
        <member name="M:Skill.Framework.TimeWatch.End">
            <summary>
            End
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.StartTime">
            <summary>
            Start time
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.OverTime">
            <summary>
            End time
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.Length">
            <summary>
            Get and set Length
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.IsEnabled">
            <summary>
            Is enabled (begined)
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.Percent">
            <summary>
            If TimeWatch is enabled returns Percent of time(0.0f - 1.0f), otherwise zero(0.0f).
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.IsEnabledAndOver">
            <summary>
            Is enabled (begined) and current time is greater than OverTime
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.IsEnabledButNotOver">
            <summary>
            Is enabled (begined) and current time is lower than OverTime
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.IsOver">
            <summary>
            Whether TimeWatch is disabled or enabled and current time is greater than OverTime
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.ElapsedTime">
            <summary>
            Retrieves elapsed time since begin
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.TimeLeft">
            <summary>
            Retrieves time left to end
            </summary>
        </member>
        <member name="P:Skill.Framework.TimeWatch.UseRealTime">
            <summary>
            if true TimeWatch use Time.realtimeSinceStartup instead of Time.time
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.AccessKey">
            <summary>
            Defines base class for keys that used by AccessLimitDecorator
            </summary>
            <remarks>
            Contains a string key. Each BehaviorTree has it's own set of keys that shared among all AccessLimitDecorators
            Whenever a AccessLimitDecorator try to execute first must get access to key, otherwise fails.
            </remarks>
        </member>
        <member name="M:Skill.Framework.AI.AccessKey.#ctor(System.String)">
            <summary>
            Creates an insance of AccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
        </member>
        <member name="M:Skill.Framework.AI.AccessKey.Lock">
            <summary>
            Implemented by subclass to defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.Framework.AI.AccessKey.Unlock">
            <summary>
            Implemented by subclass. this method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.AccessKey.Key">
            <summary> The unique Accesskey in BehaviorTree.</summary>
        </member>
        <member name="T:Skill.Framework.AI.CounterLimitAccessKey">
            <summary>
            Only constant number of AccessLimitDecorators can access this key at the same time.
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.CounterLimitAccessKey.#ctor(System.String,System.Int32)">
            <summary>
            Create an instance of CounterLimitAccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
            <param name="maxAccessCount">Maximum number of AccessLimitDecorators to access this key</param>
        </member>
        <member name="M:Skill.Framework.AI.CounterLimitAccessKey.Lock">
            <summary>
            Defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.Framework.AI.CounterLimitAccessKey.Unlock">
            <summary>
            This method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.CounterLimitAccessKey.MaxAccessCount">
            <summary>
            Defines maximum number of AccessLimitDecorators to access this key
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.TimeLimitAccessKey">
            <summary>
            Only first request accepted after TimeInterval and lock untile next TimeInterval
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.TimeLimitAccessKey.#ctor(System.String,System.Single)">
            <summary>
            Create an instance of TimeLimitAccessKey
            </summary>
            <param name="accessKey">The Unique access key in BehaviorTree.</param>
            <param name="timeInterval">time interval between access to key</param>
        </member>
        <member name="M:Skill.Framework.AI.TimeLimitAccessKey.Lock">
            <summary>
            Defines how to lock key and if success returns true, otherwise false.
            </summary>
            <returns>True for success, false for fail</returns>
        </member>
        <member name="M:Skill.Framework.AI.TimeLimitAccessKey.Unlock">
            <summary>
            This method called by AccessLimitDecorators after finish his work and free key to use by another AccessLimitDecorator.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.TimeLimitAccessKey.TimeInterval">
            <summary>
            Defines time interval between access to key
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.AccessLimitDecorator">
            <summary>
            Limit execution of child node on access key.
            </summary>
            <remarks>
            Each BehaviorTree has set of AccessKey that shared among all AccessLimitDecorators in that BehaviorTree.
            Whenever a AccessLimitDecorator try to execute, first check AccessKey and continue if get access, otherwise returns BehaviorResul.Failure
            </remarks>
        </member>
        <member name="T:Skill.Framework.AI.Decorator">
            <summary>
            Typically have only one child and are used to enforce a certain return status 
            or to implement timers to restrict how often the child will run in a given amount of time
            or how often it can be executed without a pause.(none leaf node)
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Decorator.SetChild(Skill.Framework.AI.Behavior,Skill.Framework.AI.BehaviorParameterCollection)">
            <summary>
            Set child of decorator
            </summary>
            <param name="child">Child behavior</param>
            <param name="parameters">Optional parameters for child behavior at this position of tree</param>
        </member>
        <member name="M:Skill.Framework.AI.Decorator.#ctor(System.String,Skill.Framework.AI.ConditionHandler)">
            <summary>
            Create an instance of Decorator
            </summary>
            <param name="name">Name of behavior</param>
            <param name="handler">user provided function to handle execution of Decorator</param>
        </member>
        <member name="M:Skill.Framework.AI.Decorator.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status od BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.AI.Decorator.TraceChild(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Trace Child - subclasses should implement this method
            </summary>
            <param name="status">Status od BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.AI.Decorator.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior
            </summary>        
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="P:Skill.Framework.AI.Decorator.Child">
            <summary>
            Single child node
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Decorator.DecoratorType">
            <summary>
            DecoratorType
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Decorator.NeverFail">
            <summary>
            set to true if only BehaviorResult.Running is important for you (default is true)
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.AccessLimitDecorator.#ctor(System.String,Skill.Framework.AI.ConditionHandler,Skill.Framework.AI.AccessKey)">
            <summary>
            Create an instance of AccessLimitDecorator
            </summary>
            <param name="name">Name of behavior node</param>
            <param name="handler">user provided function to handle execution of Decorator</param>
            <param name="accessKey">Shared AccessKey</param>
        </member>
        <member name="M:Skill.Framework.AI.AccessLimitDecorator.TraceChild(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.Framework.AI.AccessLimitDecorator.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset
            </summary>        
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="P:Skill.Framework.AI.AccessLimitDecorator.AccessKey">
            <summary>
            Shared AccessKey
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.AccessLimitDecorator.DecoratorType">
            <summary>
            Type of Decorator
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.ActionResetEventHandler">
            <summary>
            Represents the method to handle Action reset events.
            </summary>
            <param name="action">Sender behavior</param>        
        </member>
        <member name="T:Skill.Framework.AI.ActionHandler">
            <summary>
            Represents the method that will handle execution of action by user
            </summary>        
            <param name="sender"> Sender</param>
            <param name="parameters">Parameters for action</param>
            <returns>Status of action</returns>
        </member>
        <member name="T:Skill.Framework.AI.Action">
            <summary>
            Actions which finally implement an actors or game world status changes, for example to plan a path and move on it, to sense for the nearest enemies,
            to show certain animations, switch weapons, or run a specified sound. Actions will typically coordinate and call into different game systems.
            They might run for one simulation tick – one frame – or might need to be ticked for multiple frames to finish their work.
            Action is leaf node.
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Action.#ctor(System.String,Skill.Framework.AI.ActionHandler,Skill.Framework.Posture)">
            <summary>
            Create an instance of Action
            </summary>
            <param name="name">Name of action</param>
            <param name="handler">the function to call at execution time</param>
            <param name="changePosture">Whether this action change posture of actor</param>
        </member>
        <member name="M:Skill.Framework.AI.Action.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result of action</returns>
        </member>
        <member name="M:Skill.Framework.AI.Action.OnReset">
            <summary>
            On Reset
            </summary>        
        </member>
        <member name="M:Skill.Framework.AI.Action.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset
            </summary>        
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="M:Skill.Framework.AI.Action.Continue(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            for internal use when behavior tree let action continue (when result is BehaviorResult.Running)
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="P:Skill.Framework.AI.Action.IsLeaf">
            <summary>
            Is loaf of tree? 
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Action.ChangePosture">
            <summary>Whether this action change posture of actor </summary>
        </member>
        <member name="P:Skill.Framework.AI.Action.IsBegined">
            <summary> Is action begined </summary>
        </member>
        <member name="E:Skill.Framework.AI.Action.Reset">
            <summary>
            Occurs when behavior is reset
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorResult">
            <summary>
            Defines result of Behavior execution
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorResult.Failure">
            <summary>
            Failure
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorResult.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorResult.Running">
            <summary>
            Running. needs to run next update
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorTreeStatus">
            <summary>
            Represent Status of behaviorTree and send data between nodes
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.BehaviorTreeStatus.MaxSequenceLength">
            <summary>
            Maximum lenght of visited behaviors in each BehaviorTree update
            if your BehaviorTrees is very large increas this value
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.Interrupt">
            <summary>
            Interrupt execution of tree
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.#ctor(Skill.Framework.AI.IBehaviorTree)">
            <summary>
            Create a BehaviorStatus
            </summary>
            <param name="tree">BehaviorTree</param>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.Begin">
            <summary>
            BehaviorTree call this method at begin of each update (internal use)
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.RegisterForExecution(Skill.Framework.AI.Behavior)">
            <summary>
            each behavior before execution call this method to register in execution sequence.
            </summary>
            <param name="behavior">Behavior to register</param>
            <returns>Return registerd index</returns>
            <remarks>
            we need to keep last execution sequenece to aviod some mistakes in tree
            for example : at LimitAccessDecoratot execution, it must get access to key
            if the result be Running then it hold the key until next update (at least)
            if in next update a branch before that be executed we lost the key and never unlock it        
            </remarks>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.LogExecutionSequence">
            <summary>
            Write ExecutionSequence to UnityEngin.Debug.Log
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTreeStatus.LogExecutionSequenceTree">
            <summary>
            Write ExecutionSequence to UnityEngin.Debug.Log in tree style
            </summary>        
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.Parameters">
            <summary>
            Used internally to send valid parameters to child behaviors
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.Exception">
            <summary>
            exception occurs in evaluation of tree, otherwise null
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.RunningActions">
            <summary>
            current running actions.
            </summary>
            <remarks>
            action is allways leaf node. after execution of each action, if result is running hold it's reference
            </remarks>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.ExecutionSequence">
            <summary>
            The execution sequence after last update call.
            </summary>
            <remarks>
            This Property is for additional info and debug, do not modify this manually.
            </remarks>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.SequenceCount">
            <summary> Number of valid Behaviors in ExecutionSequence</summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.UpdateId">
            <summary>
            Update id (counter)
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.Tree">
            <summary>
            BehaviorTree 
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.Posture">
            <summary>
            Posture based on actions
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTreeStatus.IsInterrupted">
            <summary>
            Is execution of tree interrupted for any reason?
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.IBehaviorTree.DefaultState">
            <summary>
            Default state of behavior tree
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorTree">
            <summary>
            Base class of BehaviorTree that manage execution of Behaviors
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.CreateTree">
            <summary>
            Implement by subclass to create tree hierarchy and return state nodes.
            </summary>
            <returns>States of tree</returns>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.OnStateChanged(System.String,System.String)">
            <summary>
            Occurs when state of behaviortree changed
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.#ctor">
            <summary>
            Create an instance of BehaviorTree
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.OnUpdated">
            <summary> Call Updated event </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.Update">
            <summary>
            Update Tree
            </summary>                
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.ForceUpdate">
            <summary>
            Force update tree even not reach UpdateTimeInterval
            </summary>                
        </member>
        <member name="M:Skill.Framework.AI.BehaviorTree.Reset">
            <summary>
            Call this when your agent dies, destroyed, or whenever you do not need BehaviorTree
            this is important because sometimes maybe one Behavior node locked an AccessKey and could not unlock it before next update
            you have to call this to make sure other instance of BehaviorTree can access that AccessKey.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.ContinuousUpdate">
            <summary>
            If true, the tree updates 'running actions' everyframe and update whole tree if required
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.States">
            <summary> States of BehaviorTree </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.CurrentState">
            <summary>
            Current state of behavior tree.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.UpdateTimeInterval">
            <summary> 
            To enable update time interval set this to more than zero (default is 1.0f). Keep call Update() each frame.
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.UserData">
            <summary>
            User data
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.Status">
            <summary>
            Status of BehaviorTree
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorTree.DefaultState">
            <summary>
            Default state of behavior tree
            </summary>
        </member>
        <member name="E:Skill.Framework.AI.BehaviorTree.StateChanged">
            <summary>
            Occurs when state of behaviortree changed
            </summary>
        </member>
        <member name="E:Skill.Framework.AI.BehaviorTree.Updated">
            <summary> Occurs when Behavior Tree updated </summary>
        </member>
        <member name="T:Skill.Framework.AI.FailurePolicy">
            <summary>
            Enumerates the options for when a ConcurrentSelector is considered to have failed.
            </summary>
            <remarks> If FailOnOne and SuceedOnOne are both active and are both trigerred in the same time step, failure will take precedence. </remarks>
        </member>
        <member name="F:Skill.Framework.AI.FailurePolicy.FailOnOne">
            <summary>  indicates that the node will return failure as soon as one of its children fails.</summary>
        </member>
        <member name="F:Skill.Framework.AI.FailurePolicy.FailOnAll">
            <summary>  indicates that all of the node's children must fail before it returns failure.</summary>
        </member>
        <member name="T:Skill.Framework.AI.SuccessPolicy">
            <summary>
            Enumerates the options for when a ConcurrentSelector is considered to have succeeded.
            </summary>    
        </member>
        <member name="F:Skill.Framework.AI.SuccessPolicy.SucceedOnOne">
            <summary>
            indicates that the node will return success as soon as one of its children succeeds.
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.SuccessPolicy.SucceedOnAll">
            <summary>
            indicates that all of the node's children must succeed before it returns success.
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.ConcurrencyMode">
            <summary>
            Defines behavior of node when is child of a ConcurrentSelector
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.ConcurrencyMode.Unlimit">
            <summary>  Execute every update regardless of success or failure </summary>
        </member>
        <member name="F:Skill.Framework.AI.ConcurrencyMode.UntilSuccess">
            <summary>  Execute until success </summary>
        </member>
        <member name="F:Skill.Framework.AI.ConcurrencyMode.UntilFailure">
            <summary>  Execute until failure </summary>
        </member>
        <member name="T:Skill.Framework.AI.ConcurrentSelector">
            <summary>
            visit all of their children during each traversal.
            A pre-specified number of children needs to fail to make the concurrent node fail, too.
            Instead of running its child nodes truly in parallel to each other there might be a specific traversal order which can be exploited when adding conditions
            to a concurrent node because an early failing condition prevents its following concurrent siblings from running.
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.CreateChildrenExecution">
            <summary>
            At first time execution, make sure the  _ChildrenResults array is valid
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.ResetChildrenExecution">
            <summary>
            Reset _ChildrenResults array
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.#ctor(System.String)">
            <summary>
            Create an instance of ConcurrentSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">status of BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.CheckConditions(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            iterate throw children and evaluate conditions
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.AI.ConcurrentSelector.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior. For internal use. when a branch with higher priority executed, let nodes in previous branch reset
            </summary>        
            <param name="status">Status of BehaviorTree</param>   
        </member>
        <member name="P:Skill.Framework.AI.ConcurrentSelector.BreakOnConditionFailure">
            <summary>
            if true, by first condition failure, ConcurrentSelector returns BehaviorResult.Failure
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.ConcurrentSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.ConcurrentSelector.FailurePolicy">
            <summary>
            FailurePolicy (default : FailOnAll)
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.ConcurrentSelector.SuccessPolicy">
            <summary>
            SuccessPolicy (default : SucceedOnAll)
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.ConditionHandler">
            <summary>
            Represents the method to handle execution of condition by user
            </summary>        
            <param name="sender"> Sender </param>
            <param name="parameters">Parameters for condition</param>
            <returns>true for success, false for failure</returns>
        </member>
        <member name="T:Skill.Framework.AI.Condition">
            <summary>
            Check that certain actor or game world statuss hold true.(leaf node)
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.Condition.#ctor(System.String,Skill.Framework.AI.ConditionHandler)">
            <summary>
            Create an instance of Condition 
            </summary>
            <param name="name">Name of Behavior</param>
            <param name="handler">function to handle execution of action</param>
        </member>
        <member name="M:Skill.Framework.AI.Condition.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns></returns>
        </member>
        <member name="P:Skill.Framework.AI.Condition.Reverse">
            <summary>
            Reverse condition. (maybe remove latter)
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.Condition.IsLeaf">
            <summary>
            Is loaf of tree? 
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.DecoratorType">
            <summary>
            Defines type of  Decorator
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.DecoratorType.Default">
            <summary>
            Access of child specified by user function
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.DecoratorType.AccessLimit">
            <summary>
            Limit execution of child node on access key.
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.LoopSelector">
            <summary>
            Loops are like sequences but they loop around when reaching their last child during their traversal.
            if reach last child and it returns Success. this node returns Running and continue from first child at next update.
            we do this to avoid fall into infinit loop
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.LoopSelector.#ctor(System.String)">
            <summary>
            Create an instance of LoopSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.Framework.AI.LoopSelector.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status of BehaviorTree</param>
            <returns>esult</returns>
        </member>
        <member name="M:Skill.Framework.AI.LoopSelector.ResetBehavior(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Reset behavior
            </summary>        
            <param name="status">Status of BehaviorTree</param>                
        </member>
        <member name="P:Skill.Framework.AI.LoopSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.LoopSelector.LoopCount">
            <summary> number of loop (-1 for infinit)</summary>
        </member>
        <member name="T:Skill.Framework.AI.PriorityType">
            <summary>
            Defines behavior of PrioritySelector
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.PriorityType.HighestPriority">
            <summary>
            Allways  begin by high priority node
            </summary>
        </member>
        <member name="F:Skill.Framework.AI.PriorityType.RunningNode">
            <summary>
            Continue by last running node
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.IRandomService">
            <summary>
            Defines an interface for objects that can generate random values 
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.IRandomService.Range(System.Single,System.Single)">
            <summary>
            Returns a random float number between and min [inclusive] and max [inclusive].
            </summary>
            <param name="min">min value</param>
            <param name="max">max value</param>
            <returns>a random float number between and min [inclusive] and max [inclusive].</returns>
        </member>
        <member name="T:Skill.Framework.AI.RandomSelector">
            <summary>    
            Select random child by chance for execution and continue executing that until result of chlid be Running. 
            if result is Failure or success, selected another random child on next exevution
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.#ctor(System.String)">
            <summary>
            Create an instance of RandomSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.Add(Skill.Framework.AI.Behavior,Skill.Framework.AI.BehaviorParameterCollection)">
            <summary>
            Add child . Remember to set weight of child before call this function
            </summary>
            <param name="child"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.RemoveAll">
            <summary>
            Remove all children
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.Remove(Skill.Framework.AI.Behavior)">
            <summary>
            Remove specified child from children
            </summary>
            <param name="child">behavior child to remove</param>
            <returns>true for success, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status od BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="M:Skill.Framework.AI.RandomSelector.GetRandomIndex">
            <summary>
            Select random child by chance
            </summary>
            <returns>Index of selected child</returns>
        </member>
        <member name="P:Skill.Framework.AI.RandomSelector.RandomService">
            <summary>        
            Gets or sets random value generation service
            </summary>
            <remarks>
            The main reason to write this property is :
            as for simulation BehaviorTree in Skill Studio i use Skill Dll, to avoid writing duplicate code for BehaviorTree (one in Skill Dll and one in Skill Studio)
            i could't use UnityEngine.Random class in Skill Studio application. so i create IRandomService interface to change random generation
            algorithm in Skill Studio application. Although you can change random generation algorith (:D).
            </remarks>
        </member>
        <member name="P:Skill.Framework.AI.RandomSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.BehaviorContainer">
            <summary>
            Helper class that contains Behavior node and apropriate parameters
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.BehaviorContainer.#ctor(Skill.Framework.AI.Behavior,Skill.Framework.AI.BehaviorParameterCollection)">
            <summary>
            Create an instance of BehaviorContainer
            </summary>
            <param name="behavior">Behavior node</param>
            <param name="parameters">Parameters of behavior at this position of tree</param>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorContainer.Parameters">
            <summary>
            Parameters of behavior at this position of tree
            </summary>
        </member>
        <member name="P:Skill.Framework.AI.BehaviorContainer.Behavior">
            <summary>
            Behavior node
            </summary>
        </member>
        <member name="T:Skill.Framework.AI.SequenceSelector">
            <summary>
            run one child to finish after the other. If one or multiple fail the whole sequence fails, too.
            Without a reset or without finishing the last child node a sequence stores the last running child to immediately return to it on the next update.
            </summary>
        </member>
        <member name="M:Skill.Framework.AI.SequenceSelector.#ctor(System.String)">
            <summary>
            Create an instance of SequenceSelector
            </summary>
            <param name="name">Name of Behavior node</param>
        </member>
        <member name="M:Skill.Framework.AI.SequenceSelector.Behave(Skill.Framework.AI.BehaviorTreeStatus)">
            <summary>
            Behave
            </summary>
            <param name="status">Status od BehaviorTree</param>
            <returns>Result</returns>
        </member>
        <member name="P:Skill.Framework.AI.SequenceSelector.CompositeType">
            <summary>
            CompositeType
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AimHelper">
            <summary>
            Helper class to calculate anim for AnimNodeAimOffset
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AimHelper.Update">
            <summary>
            Update AimHelper to calculate new aim vector
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.Aim">
            <summary>
            Calculated Aim vector
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.PitchMin">
            <summary> Gets or sets minimum value of pitch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.PitchMax">
            <summary> Gets or sets maximum value of pitch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.YawMin">
            <summary> Gets or sets minimum value of yaw </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.YawMax">
            <summary> Gets or sets maximum value of pitch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.Direction">
            <summary> Local direction of aim relative to forward direction of actor </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AimHelper.AimSpeed">
            <summary> Speed of aim </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeAdditiveBlending">
            <summary>
            This blend node allows the Anim Tree to combine additive animation, or a blend of additive animations.    
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAdditiveBlending.#ctor">
            <summary>
            Create an insatance of AnimNodeAdditiveBlending
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAdditiveBlending.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAdditiveBlending.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAdditiveBlending.AdditiveWeight">
            <summary>
            Weight of AdditiveLayer
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAdditiveBlending.IsAdditive">
            <summary>
            Whether additive layer is enable?
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAdditiveBlending.NormalNode">
            <summary>
            The AnimNode that use input blendmode specified by parent
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAdditiveBlending.AdditiveNode">
            <summary>
            The AnimNode that use additive blendmode
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAdditiveBlending.Length">
            <summary>
            Retrives lenght of active sub branch.
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeAimOffset">
            <summary>
            In a game, you often want a weapon held by a character to point where that player is aiming.
            Because an actor is defined by a collision cylinder that is only able to rotate on the yaw axis and not the pitch or roll axis,
            it's difficult to simply rotate the actor to make the player's aim.
            Even then, you may want the character's feet to remain locked in place.
            
            for more information : 
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeAimOffset
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.CenterCenterIndex">
            <summary> Index of CenterCenter child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.CenterUpIndex">
            <summary> Index of Centerup child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.CenterDownIndex">
            <summary> Index of CenterDown child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.LeftCenterIndex">
            <summary> Index of LeftCenter child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.LeftUpIndex">
            <summary> Index of LeftUp child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.LeftDownIndex">
            <summary> Index of LeftDown child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.RightCenterIndex">
            <summary> Index of RightCenter child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.RightUpIndex">
            <summary> Index of RightUp child</summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffset.RightDownIndex">
            <summary> Index of RightDown child</summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.OnProfileChanged">
            <summary>
            call ProfileChanged event and set new profile to children
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.#ctor">
            <summary>
            Create an instance of AnimNodeAimOffset node
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.SetFormat(System.String)">
            <summary>
            Set format of all profiles
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.Destroy">
            <summary>
            Destroy hierarchy of Children
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.GetProfile(System.String)">
            <summary>
            Get profile by index
            </summary>
            <param name="profile">name of profile</param>
            <returns>if success AnimNodeAimOffsetProfile, otherwise null</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.AddProfile(Skill.Framework.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Add new AnimNodeAimOffsetProfile
            </summary>
            <param name="profile">AnimNodeAimOffsetProfile to add</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.RemoveAllProfiles">
            <summary>
            Remove all profiles
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.Contains(Skill.Framework.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Determines whether specified profile is in profiles
            </summary>
            <param name="profile">profile to check</param>
            <returns>true if contains, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffset.RemoveProfile(Skill.Framework.Animation.AnimNodeAimOffsetProfile)">
            <summary>
            Remove specified profile
            </summary>
            <param name="profile">profile to remove</param>
            <returns>true for success, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AimWeight">
            <summary>
            Get or set weight of node (0.0f - 1.0f)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.UseTreeProfile">
            <summary>
            Whether use AnimationTree profiling method?
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.IsLoop">
            <summary>
            Whether aim animations are loop? (default is false).
            </summary>
            <remarks>
            If aim animations are not loop, then set as ClampForever.
            </remarks>
        </member>
        <member name="E:Skill.Framework.Animation.AnimNodeAimOffset.ProfileChanged">
            <summary>
            Occurs when profile changed
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.NormalNode">
            <summary>
            The AnimNode that use input blendmode specified by parent
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.Profile">
            <summary>
            Get of set profile
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.IsAimEnable">
            <summary>
            Whether anim layer is enable?
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.Aim">
            <summary> Normalized vector aim offset./ </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AngleOffset">
            <summary> Aim offset to append to Aim before processing.</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AimX">
            <summary> Normalized horizontal aim offset. </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AimY">
            <summary> Normalized veritcal aim offset. </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AngleOffsetX">
            <summary> Horizontal aim offset to append to Aim before processing. </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.AngleOffsetY">
            <summary> Vertical aim offset to append to Aim before processing. </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffset.ProfileCount">
            <summary>
            Retrieves number of profiles
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeAimOffsetProfile">
            <summary>
            Represent data required for AnimNodeAimOffset profile 
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeAimOffsetProfile.Name">
            <summary> Name of Profile </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeAimOffsetProfile.#ctor">
            <summary>
            Create an instance of AnimNodeAimOffsetProfile
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.Item(System.Int32)">
            <summary>
            Retrieves AnimNodeSequence by index
            </summary>
            <param name="index">Zero based index between 0 - 9</param>
            <returns>AnimNodeSequence</returns>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterCenter">
            <summary> AnimationName of CenterCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterUp">
            <summary> AnimationName of CenterUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterDown">
            <summary> AnimationName of CenterDown child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftCenter">
            <summary> AnimationName of LeftCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftUp">
            <summary> AnimationName of LeftUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftDown">
            <summary> AnimationName of LeftDown child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightCenter">
            <summary> AnimationName of RightCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightUp">
            <summary> AnimationName of RightUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightDown">
            <summary> AnimationName of RightDown child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterCenterMTs">
            <summary> MixingTransforms of CenterCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterUpMTs">
            <summary> MixingTransforms of CenterUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.CenterDownMTs">
            <summary> MixingTransforms of CenterDown child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftCenterMTs">
            <summary> MixingTransforms of LeftCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftUpMTs">
            <summary> MixingTransforms of LeftUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.LeftDownMTs">
            <summary> MixingTransforms of LeftDown child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightCenterMTs">
            <summary> MixingTransforms of RightCenter child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightUpMTs">
            <summary> MixingTransforms of RightUp child</summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeAimOffsetProfile.RightDownMTs">
            <summary> MixingTransforms of RightDown child</summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlendByIdle">
            <summary>
            This node automatically blends between idle and moving depending on the velocity.
            If the owner's velocity is zero (or a relatively small number) then the node blend to the 'Idle' branch.
            Otherwise the node blends to the 'Moving' branch.
            http://udn.epicgames.com/Three/AnimationNodes.html#UDKAnimBlendByIdle / _UTAnimBlendByIdle
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIdle.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIdle.#ctor">
            <summary>
            Create new instance of AnimNodeBlendByIdle
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIdle.IdleNode">
            <summary>
            Idle branch
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIdle.MovingNode">
            <summary>
            Moving branch
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIdle.IdleWeight">
            <summary>
            Weight of idle branch
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIdle.IsIdle">
            <summary>
            Whether actor is idle?
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIdle.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlendByPosture">
            <summary>
            This blend node allows the Anim Tree to automatically blend between three inputs;
            Standing, Crouched and Prone.
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlendByIndex">
            <summary>
            Try to keep single child active at time
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeSingleLayer">
            <summary>
            base class for AnimNodes that use single layer for children
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSingleLayer.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeSingleLayer
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSingleLayer.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.OnBecameRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.OnCeaseRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendByIndex
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.Update(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            Update
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.SwitchOneShot(System.Int32)">
            <summary>        
            For example you can play reload one shot
            </summary>
            <param name="switchIndex"> switch node by index (index is between '0' - 'ChildCount -1' ) </param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByIndex.CancelSwitchOneShot">
            <summary>
            Cancel SwitchOneShot operation
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIndex.SelectedChildIndex">
            <summary>
            Get or set selected child by index
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIndex.SelectedChildName">
            <summary>
            Get or set selected child by name
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIndex.SelectedChildNode">
            <summary>
            Retrives selected child node
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByIndex.Length">
            <summary>
            Retrieves lenght of active sub branch
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendByPosture.#ctor">
            <summary>
            Create new instance of AnimNodeBlendByPosture
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByPosture.StandingNode">
            <summary> Standing branch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByPosture.CrouchedNode">
            <summary> Crouched branch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByPosture.ProneNode">
            <summary> Prone branch </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendByPosture.Posture">
            <summary>
            Get or set posture of actor
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlendBySpeed">
            <summary>
            This blend node allows the Anim Tree to automatically blend between inputs between the constraints based on the size of the Velocity or Acceleration vector within the owning actor.
            The constraints define the bounds between each input, 
            for example, Constraints[0] and Constraints[1] define the lower and upper bound for index 0;
            Constraints[1] and Constraints[2] define the lower and upper bound for index 1; and so forth.
            These bounds are modified by the Blend Down Perc value, set Blend Down Perc to zero if you wish to keep the bounds strict.
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeBlendBySpeed
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendBySpeed.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeBlendBySpeed
            </summary>
            <param name="childCoun">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlendBySpeed.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.Velocity">
            <summary>
            Get or set velocity of actor
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.BlendUpTime">
            <summary>
            How fast to blend when going up an index.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.BlendDownTime">
            <summary>
            How fast to blend when going down an index.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.BlendDownPercent">
            <summary>
            Where abouts in the constraint bounds should the blend start blending down.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.BlendUpDelay">
            <summary>
            Time delay before blending up an index.
            </summary> 
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.BlendDownDelay">
            <summary>
            Time delay before blending down an index.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.Constraints">
            <summary> Constraints </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlendBySpeed.ConstraintCount">
            <summary> Number of constraints (ChildCount + 1)</summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimationLayer">
            <summary>
            Manage animation blending of single layer
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.#ctor(System.Int32,UnityEngine.AnimationBlendMode)">
            <summary>
            Create an instance of AnimationLayer
            </summary>
            <param name="layerIndex">Index of layer</param>
            <param name="blendMode">AnimationBlendMode</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.BeginUpdate">
            <summary>
            Prepare for update
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.Update">
            <summary>
            Update Layer
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.UpdateAnimation(Skill.Framework.Animation.AnimNodeSequence)">
            <summary>
            Make sure given AnimNodeSequence will update at next update
            </summary>
            <param name="anim">AnimNodeSequence to update</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.AddToActiveList(Skill.Framework.Animation.AnimNodeSequence)">
            <summary>
            Register given AnimNodeSequence to process next update
            </summary>
            <param name="anim"></param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.CleanUpActiveList">
            <summary>
            Remove AnimNodeSequences with weight == 0
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayer.Apply(UnityEngine.Animation)">
            <summary>
            Apply changes to UnityEngine.Animation component 
            </summary>
            <param name="animationComponent">UnityEngine.Animation to apply changes to</param>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayer.ActiveAnimNodes">
            <summary>
            include AnimNodes with weight > 0
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayer.LayerIndex">
            <summary>
            Index of layer. (begin by 0)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayer.BlendMode">
            <summary>
            AnimationBlendMode. (Blend or Additive)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayer.RootMotion">
            <summary>
            RootMotion result of Sequences in this layer
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimationLayerManager">
            <summary>
            Contains AnimationLayers of an AnimationTree
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayerManager.#ctor">
            <summary>
            Create an instance of AnimationLayerManager
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationLayerManager.Create(UnityEngine.AnimationBlendMode)">
            <summary>
            Create new layer with specified AnimationBlendMode
            </summary>
            <param name="blendMode">AnimationBlendMode</param>
            <returns>New create and regitered AnimationLayer</returns>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayerManager.Layers">
            <summary>
            List of AnimationLayer. (do not modify manually)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationLayerManager.EnableAnimNodeSequenceCount">
            <summary>
            Retrieves number of AnimNodeSequence that updated in current update(frame)
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.WeightChangeMode">
            <summary>
            Defines weight state of AnimNode
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.WeightChangeMode.NoChange">
            <summary>
            No changes occurs between this and previous update
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.WeightChangeMode.Increased">
            <summary>
            The value of Weight increased depend on previous update
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.WeightChangeMode.Decreased">
            <summary>
            The value of Weight decreased depend on previous update
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeEventHandler">
            <summary>
            Represents the method that will handle events of AnimNpde
            </summary>
            <param name="sender">The actual AnimNode that this even belongs to</param>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeRandom">
            <summary>
            This blend node allows the Anim Tree to randomly blend between inputs set by the user.
            select random node when BecameRelevant and continue to update that until cease relevant.
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeRandom.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeRandom
            </summary>
            <param name="childCoun">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeRandom.OnBecameRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeRandom.PickRandomChildIndex">
            <summary>
            Select a child index based i\on there chances
            </summary>
            <returns></returns>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeRandom.Chances">
            <summary>
            Get or set chance of each node. (make sure chances be >0)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeRandom.TotalChance">
            <summary>
            Sum of all chances
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeOverride">
            <summary>
            place children nodes in different layers.
            </summary>
            <remarks>
            for example :
            almost in reload AnimationClips only hand bones involved and other bones do not have keys.
            you can use this node to override hand animations so the lower body can play another animation
            be sure that lower body bones do not have any keys in AnimationClip or set MixingTransforms for bones
            Another usage of this nodeis when you want to play an IdleBreak animation sometimes
            </remarks>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.#ctor(System.Int32)">
            <summary>
            Create new instance of AnimNodeOverride
            </summary>
            <param name="childCount">number of children</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.OnBecameRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.OnCeaseRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.Update(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            Update
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.CalcBlendWeights(Skill.Framework.Animation.BlendWeight[]@)">
            <summary>
            Calculate weight of children between 0.0f - 1.0f
            </summary>
            <param name="blendWeights">previous weight of children</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.OverrideOneShot">
            <summary>
            Used when OverridePeriod is zero
            For example you can play reload one shot
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeOverride.OverrideOneShot(System.Int32)">
            <summary>
            Used when OverridePeriod is zero
            For example you can play reload one shot
            </summary>
            <param name="overrideIndex"> overriding node by index (index is between '1' - 'ChildCount -1' ) </param>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.NormalNode">
            <summary>
            Normal node
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.OverrideNode">
            <summary>
            Override Node (higher layer)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.OverrideIndex">
            <summary>
            Get or set active overriding node by index (index is between '1' - 'ChildCount -1' )
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.IsOverriding">
            <summary>
            Whether overriding brach enable?
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.OverridePeriod">
            <summary>
            if true, node automatically override one shot at period time
            </summary>
            <remarks>
            can be used on IdleBreak, set idle to NormalNode and idlebreak(could be an AnimNodeRandom) to OverrideNode.
            remember to disable IsOverriding when actor is not idle
            </remarks>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeOverride.Length">
            <summary>
            Lenght of active branch
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeSequence">
            <summary>
            This animation node outputs the animation data within an animation sequence.
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeSequence.UpdatePreviousAnimation">
            <summary>
            whether animation layer needs to update PreviousAnimation. when AnimationTree profile changed
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.AnimNodeSequence.RelevantTime">
            <summary>
            Specify when this animation bacame relevant, and when needs to finish
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.UpdateAnimation">
            <summary>
            Update AnimationName and Format and check whether it needs to update previous animation
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.#ctor">
            <summary>
            Create an instance of AnimNodeSequence
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.#ctor(System.String)">
            <summary>
            Create an instance of AnimNodeSequence
            </summary>
            <param name="animationName">Name of AnimationClip</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.OnBecameRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call BecameRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.OnCeaseRelevant(Skill.Framework.Animation.AnimationTreeState)">
            <summary>
            call CeaseRelevant event
            </summary>
            <param name="state">State of AnimationTree</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.Blend">
            <summary>
            update weight
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.SelectLayer(Skill.Framework.Animation.AnimationLayerManager,Skill.Framework.Animation.AnimationLayer)">
            <summary>
            Allow each node to get apropriate AnimationLayer
            </summary>
            <param name="manager">LayerManager to create layer</param>
            <param name="parentSuggestLayer">AnimationLayer suggested by parent. (layer of child at index 0)</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.SetFormat(System.String)">
            <summary>
            Set format of aimation name
            </summary>
            <param name="format"></param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeSequence.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize and collect information from animationComponent
            </summary>
            <param name="animationComponent">UnityEngine.Animation</param>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.IgnoreMissAnimationWarning">
            <summary>
            by default skill generates warnings for miss animations. set it true to disable warnings.
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.PreviousAnimation">
            <summary>
            Previous AnimationName
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.AnimationName">
            <summary>
            Name of AnimationClip
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.Format">
            <summary>
            Format of AnimationName. used in AnimationTree profile
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.CurrentAnimation">
            <summary>
            Current Animation Name
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.UseTreeProfile">
            <summary>
            Whether use AnimationTree profiling method? (default is true)
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.MixingTransforms">
            <summary> MixingTransforms </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.Synchronize">
            <summary>
            Synchronize animations with other animations in same Layer?
            </summary>
            <remarks>
            it can be used for Direction AnimationClips that has same length.
            </remarks>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.Speed">
            <summary>
            Speed at which the animation will be played back. Default is 1.0
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.WrapMode">
            <summary>
            WrapMode
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.Layer">
            <summary>
            Layer
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.Length">
            <summary>
            Lenght of AnimationClip based on speed
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeSequence.RootMotion">
            <summary> RootMotion data </summary>
        </member>
        <member name="T:Skill.Framework.Animation.MoveDirection">
            <summary>
            Defines 4 main direction
            </summary>
        </member>
        <member name="F:Skill.Framework.Animation.MoveDirection.Forward">
            <summary> Forward direction </summary>
        </member>
        <member name="F:Skill.Framework.Animation.MoveDirection.Backward">
            <summary> Backward direction </summary>
        </member>
        <member name="F:Skill.Framework.Animation.MoveDirection.Left">
            <summary> Left direction </summary>
        </member>
        <member name="F:Skill.Framework.Animation.MoveDirection.Right">
            <summary> Right direction  </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimNodeBlend4Directional">
            <summary>
            This blend node allows the Anim Tree to automatically blend between four inputs which represent the owning actor moving forwards, backwards, strafing left and strafing right.
            The blend node compares the direction of velocity or acceleration to the direction of the owning actor. 
            Depending on the differences between the two, it will switch between the inputs.
            http://udn.epicgames.com/Three/AnimationNodes.html#AnimNodeBlendDirectional
            </summary>
        </member>
        <member name="M:Skill.Framework.Animation.AnimNodeBlend4Directional.#ctor">
            <summary>
            Create an instance of AnimNodeBlend4Directional
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Forward">
            <summary> Forward child node </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Backward">
            <summary> Backward child node </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Left">
            <summary> Left child node </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Right">
            <summary> Right child node </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Angle">
            <summary>
            Angle of actor in local space
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimNodeBlend4Directional.Direction">
            <summary>
            current direction of actor based of angle
            </summary>
        </member>
        <member name="T:Skill.Framework.Animation.AnimationTree">
            <summary>
            Base class for AnimationTrees
            </summary>
            <remarks>
            The AnimationTree use unity Animation Layers system ( see .... )
            All AnimNodes in AnimationTre seprated to two category SingleLayer and MultiLayer
            SingleLayers AnimNodes use single layer to blend between their children, whitch means use same layer index for all children
            MultiLayer AnimNodes use a layer per child and blend them togather (like BlendByIdle)
            to know about which AnimNode inherites from SingleLayer or MultiLayer see hierarchy inheritance of classes
            the idea of designing this AnimationTree system comes from Unreal Engine AnimaionTree ( see : http://udn.epicgames.com/Three/AnimationNodes.html )
            </remarks>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.CreateTree">
            <summary>
            Override by subclass to create hierarchy of AnimNodes and return root node
            </summary>
            <returns>Root node of tree</returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.#ctor">
            <summary>
            Create an instance of AnimationTree
            </summary>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.AddProfile(System.String,System.String)">
            <summary>
            Add new profile
            </summary>
            <param name="name">Name of profile</param>
            <param name="format">Format of profile in C#</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.RemoveProfile(System.String)">
            <summary>
            Remove profile by name
            </summary>
            <param name="name">Name of profile</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.Initialize(UnityEngine.Animation)">
            <summary>
            Initialize UnityEngine.Animation. call this at 'Awake', or 'Start' method of MonoBehavior based class
            </summary>
            <param name="animationComponent">UnityEngine.Animation to initialize</param>        
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.SyncLayers(UnityEngine.Animation)">
            <summary>
            Sync all layers used in this AnimationTree. (maybe not useful because we do'nt use 'CrossFade' method)
            </summary>
            <param name="animationComponent">UnityEngine.Animation to sync layers</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.Update(Skill.Framework.Controller)">
            <summary>
            Update AnimationTree in new state each frame
            </summary>
            <param name="controller">optional controller to send throw AnimNodes</param>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.Apply(UnityEngine.Animation)">
            <summary>
            Apply AnimationTree
            </summary>
            <param name="animationComponent">UnityEngine.Animation to update</param>                       
            <remarks>
            you can apply this AnimationTree to more than one UnityEngine.Animation each frame (instancing)
            Make sure default AnimationClip of Animation setted to 'none' in editor
            </remarks>
        </member>
        <member name="M:Skill.Framework.Animation.AnimationTree.Destroy">
            <summary>
            Destroy hierarchy
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.LayerCount">
            <summary>
            Maximum layer used by this AnimationTree
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.Root">
            <summary>
            The root AnimNode
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.UserData">
            <summary>
            User data
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.LayerManager">
            <summary>
            LayerManager
            </summary>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.Profile">
            <summary>
            Get or set profile by name
            </summary>
            <remarks>
            Profiles can be used in situations like : you want to swich weapon type (Rifle, Pistol, ...)
            all of this weapons have same AnimationClips (Reload, Fire, RunForward, WalkForward, ...).
            in such situations it's possible to name AnimationClips in standard format like this :
            
            Rifle_Reload,  Rifle_Fire,  Rifle_RunForward,  Rifle_WalkForward,   ...
            Pistol_Reload, Pistol_Fire, Pistol_RunForward, Pistol_WalkForward, ...
            
            by this naming method the formats of profiles can be
            
            Rifle_{0}
            Pistol_{0}
                    
            then set AnimationName property of AnimNodeSequences to
            
            Reload,  Fire,  RunForward,  WalkForward,   ...
            
            by this method at any time you can switch between weapons.
            </remarks>
        </member>
        <member name="P:Skill.Framework.Animation.AnimationTree.RootMotion">
            <summary> Retrieves RootMotion at current frame </summary>
        </member>
        <member name="T:Skill.Framework.Posture">
            <summary>
            Defines possible posture of actor
            </summary>
        </member>
        <member name="F:Skill.Framework.Posture.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Skill.Framework.Posture.Standing">
            <summary>
            Standing
            </summary>
        </member>
        <member name="F:Skill.Framework.Posture.Crouched">
            <summary>
            Crouched
            </summary>
        </member>
        <member name="F:Skill.Framework.Posture.Prone">
            <summary>
            Prone
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.DialogResult">
            <summary>
            Specifies identifiers to indicate the return value of a dialog box.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.None">
            <summary>
            Nothing is returned from the dialog box. This means that the modal dialog continues running.
            </summary>    
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.OK">
            <summary>
            The dialog box return value is OK (usually sent from a button labeled OK).
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.Cancel">
            <summary>
            The dialog box return value is Cancel (usually sent from a button labeled Cancel).
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.Abort">
            <summary>
            The dialog box return value is Abort (usually sent from a button labeled Abort).
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.Retry">
            <summary>
            The dialog box return value is Retry (usually sent from a button labeled Retry).
            </summary>   
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.Ignore">
            <summary>
            The dialog box return value is Ignore (usually sent from a button labeled Ignore).
            </summary>    
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.Yes">
            <summary>
            The dialog box return value is Yes (usually sent from a button labeled Yes).
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.DialogResult.No">
            <summary>
            The dialog box return value is No (usually sent from a button labeled No).
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.OptionBox">
            <summary>
            An extended control that contains two buttons as left and right button and a label in between to show content.
            an example of usage is to let player select Resolution, Shadow Quality, Texture Quality, ...
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Grid">
            <summary>
            Defines a flexible grid area that consists of columns and rows.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Grid.#ctor">
            <summary>
            Initializes a new instance of Grid.        
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Grid.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Grid.ColumnDefinitions">
            <summary>
            Gets a ColumnDefinitionCollection defined on this instance of Grid.
            </summary>        
        </member>
        <member name="P:Skill.Framework.UI.Grid.RowDefinitions">
            <summary>
            Gets a RowDefinitionCollection defined on this instance of Grid.
            </summary>    
        </member>
        <member name="T:Skill.Framework.UI.IFocusable">
            <summary>
            Defines focusable behavior
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.IFocusable.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>        
        </member>
        <member name="M:Skill.Framework.UI.IFocusable.Focus">
            <summary> Try focuse control </summary>
        </member>
        <member name="M:Skill.Framework.UI.IFocusable.DisableFocusable">
            <summary> Disable focusable - sometimes in editor it is better to disable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.IFocusable.EnableFocusable">
            <summary> Enable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.IFocusable.HandleEvent(UnityEngine.Event)">
            <summary>
            Handle event
            </summary>
            <param name="e">Event to handle</param>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.IsEnabled">
            <summary>
            Gets or sets a value indicating whether this element is enabled in the user interface (UI).
            </summary>
            <returns>  true if the element is enabled; otherwise, false. The default value is true. </returns>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.IsFocusable">
            <summary>
            Indicates whether the element can receive focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.IFocusable.GotFocus">
            <summary>
            Occurs when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.IFocusable.LostFocus">
            <summary>
            Occurs when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.TabIndex">
            <summary> Tab index of control. </summary>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.IsFocused">
            <summary> Gets a value that determines whether this element has logical focus. (You must set valid name to enable this behavior) </summary>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.IsExtendedFocusable">
            <summary> Gets a value that determines whether this element is a unity built in focusable (like button, textbox, ...) or extended </summary>
        </member>
        <member name="P:Skill.Framework.UI.IFocusable.Name">
            <summary>
            Gets or sets name of control ( should be valid ).
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.OnSelectionChanged">
            <summary>
            Occurs when SelectedOption changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.#ctor(System.String[])">
            <summary>
            Create an OptionBox
            </summary>
            <param name="options">Options as array of string</param>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.#ctor(UnityEngine.GUIContent[])">
            <summary>
            Create an OptionBox
            </summary>
            <param name="options">Options as array of GUIContent</param>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. (Up and Down command to switch selected index)
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>        
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.DisableFocusable">
            <summary> Disable focusable - sometimes in editor it is better to disable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.EnableFocusable">
            <summary> Enable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.OnGotFocus">
            <summary>
            when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.OnLostFocus">
            <summary>
            when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.OptionBox.Focus">
            <summary> Try focuse control </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.FocusedBackground">
            <summary> Border and Background to use when OptionBox is focused.</summary>                
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.Background">
            <summary> The box that use as background  </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.LeftButton">
            <summary> Left Button to select previous option </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.RightButton">
            <summary> Right Button to select next option  </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.OptionLabel">
            <summary> Middle lable to show contents </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.FillBackground">
            <summary>
            Is background box fill entire control of just in the middle of control( behind OptionLabel)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.Loop">
            <summary> Whether cycle through options</summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.Options">
            <summary> Options </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.SelectedIndex">
            <summary> Gets or sets index of selected option </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.SelectedOption">
            <summary> Gets or sets selected option </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.OptionBox.SelectionChanged">
            <summary>
            Occurs when SelectedOption changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.ButtonWidthPercent">
            <summary>
            What is the percentage of button width relative to control(0 - 50)- default is 30        
            </summary>
            <remarks>
            Percent of OptionLabel : 100 - (ButtonWidthPercent * 2)
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.TabIndex">
            <summary> Tab index of control. </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.IsFocused">
            <summary>
            Gets a value that determines whether this element has logical focus. (You must set valid name to enable this behavior)
            </summary>
            <returns>
            true if this element has logical focus; otherwise, false.(You must set valid name to enable this behavior)
            </returns>
            <remarks>
            Set used for internal use
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.IsFocusable">
            <summary>
            Indicates whether the element can receive focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.OptionBox.IsExtendedFocusable">
            <summary> it is an extended focusable </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.OptionBox.GotFocus">
            <summary>
            Occurs when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.OptionBox.LostFocus">
            <summary>
            Occurs when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.StrokeLable">
            <summary>
            An extended lable to visualize stroke color by rendering four additional label at left, right, top and bottom side of main label
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Label">
            <summary>
            Make a text or texture label on screen.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Control">
            <summary>
            Defines base class for all Controls in Skill.UI
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Control.ControlType">
            <summary>
            Type of Control : Control
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Control.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Label.#ctor">
            <summary>
            Create an instance of Lable
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Label.Render">
            <summary>
            Render Label
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Label.Content">
            <summary>
            Text, image and tooltip for this label.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Label.Text">
            <summary>
            Text to display on the label.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.StrokeLable.OnRenderAreaChanged">
            <summary>
            Render aread chnged
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.StrokeLable.#ctor">
            <summary>
            Create a StrokeLable
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.StrokeLable.Render">
            <summary>
            Render StrokeLable
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.StrokeLable.Parent">
            <summary> Parent </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.StrokeLable.StrokeColor">
            <summary> Gets or set Stroke Color </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.StrokeLable.StrokeThickness">
            <summary> Gets of sets Stroke Thickness </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.StrokeLable.StrokeFont">
            <summary> it is possible to change the font used as stroke </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.StrokeLable.Style">
            <summary> Style of label </summary>
        </member>
        <member name="T:Skill.Framework.UI.FocusableControl">
            <summary>
            Base class for focusables Controls.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.DisableFocusable">
            <summary> Disable focusable - sometimes in editor it is better to disable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.EnableFocusable">
            <summary> Enable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.OnGotFocus">
            <summary>
            when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.OnLostFocus">
            <summary>
            when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.Focus">
            <summary> Try focuse control </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.HandleEvent(UnityEngine.Event)">
            <summary>
            Check for events (KeyUp, KeyDown)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.OnKeyDown(Skill.Framework.UI.KeyEventArgs)">
            <summary>
            Occurs when a keyboard key was pressed.(if WantsKeyEvents = true )
            </summary>
            <param name="args"> KeyEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.OnKeyUp(Skill.Framework.UI.KeyEventArgs)">
            <summary>
            Occurs when a keyboard key was released.(if WantsKeyEvents = true )
            </summary>
            <param name="args"> KeyEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.FocusableControl.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="P:Skill.Framework.UI.FocusableControl.TabIndex">
            <summary> Tab index of control. </summary>
        </member>
        <member name="P:Skill.Framework.UI.FocusableControl.IsFocusable">
            <summary>
            Indicates whether the element can receive focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.FocusableControl.IsExtendedFocusable">
            <summary> it is not extended focusable </summary>
        </member>
        <member name="P:Skill.Framework.UI.FocusableControl.IsFocused">
            <summary>
            Gets a value that determines whether this element has logical focus. (You must set valid name to enable this behavior)
            </summary>
            <returns>
            true if this element has logical focus; otherwise, false.(You must set valid name to enable this behavior)
            </returns>
            <remarks>
            Set used for internal use
            </remarks>
        </member>
        <member name="E:Skill.Framework.UI.FocusableControl.GotFocus">
            <summary>
            Occurs when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.FocusableControl.LostFocus">
            <summary>
            Occurs when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.FocusableControl.WantsKeyEvents">
            <summary>
            WantsKeyEvents?
            </summary>
            <returns>True if hooked, otherwise false</returns>
        </member>
        <member name="E:Skill.Framework.UI.FocusableControl.KeyDown">
            <summary> Occurs when a keyboard key was pressed.(if WantsKeyEvents = true ) </summary>
        </member>
        <member name="E:Skill.Framework.UI.FocusableControl.KeyUp">
            <summary> Occurs when a keyboard key was released.(if WantsKeyEvents = true ) </summary>
        </member>
        <member name="T:Skill.Framework.UI.FrameLocation">
            <summary>
            Specifies the position MenuFrame
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.FrameLocation.Fill">
            <summary>
            The location of a frame fill entire size of screen.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.FrameLocation.Center">
            <summary>
            The location of a frame is the center of screen.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.FrameLocation.Manual">
            <summary>
            The location of a frame set by user.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.GridSplitter">
            <summary>
            Represents the control that redistributes space between columns or rows of a Grid control.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Box">
            <summary>
            Make a graphical box.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Box.#ctor">
            <summary>
            Make a graphical box.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Box.Render">
            <summary> Render box content </summary>
        </member>
        <member name="P:Skill.Framework.UI.Box.Content">
            <summary>
            Text, image and tooltip for this box.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.GridSplitter._RenderAreaWidthOverFlow">
            <summary>
            area to detect mouse
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.GridSplitter.OnRenderAreaChanged">
            <summary>
            RenderAreaChanged
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.GridSplitter.#ctor">
            <summary>
            Create a GridSplitter
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.GridSplitter.OnMouseDown(Skill.Framework.UI.MouseClickEventArgs)">
            <summary>
            Occurs when mouse button was pressed.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseClickEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.GridSplitter.OnMouseUp(Skill.Framework.UI.MouseClickEventArgs)">
            <summary>
            Occurs when mouse button was released.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseClickEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.GridSplitter.OnMouseDrag(Skill.Framework.UI.MouseMoveEventArgs)">
            <summary>
            Occurs when mouse was dragged.(if WantsMouseEvents = true)
            </summary>
            <param name="args"> MouseMoveEventArgs </param>
        </member>
        <member name="P:Skill.Framework.UI.GridSplitter.OverFlow">
            <summary> extend mouse hover position </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridSplitter.Parent">
            <summary> Parent Panel that host this control.(this value should be setted by parent) </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridSplitter.Orientation">
            <summary> Vertical if split columns, Horizontal if split rows </summary>
        </member>
        <member name="T:Skill.Framework.UI.IContextMenu">
            <summary>
            Base class for ContextMenu
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.IContextMenu.Show(Skill.Framework.UI.BaseControl,UnityEngine.Vector2)">
            <summary>
            Show ContextMenu
            </summary>
            <param name="owner">Owner ui object that showthis contenxt menu</param>
            <param name="position">Mouse position</param>
        </member>
        <member name="P:Skill.Framework.UI.IContextMenu.Owner">
            <summary> Owner ui object that showthis contenxt menu </summary>
        </member>
        <member name="T:Skill.Framework.UI.ImageShake">
            <summary>
            Helper class to simulate shake ImageWithTexCoords
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageShake.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageShake.LateUpdate">
            <summary>
            LateUpdate
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageShake.Shake(Skill.Framework.UI.ImageWithTexCoords,System.Single,UnityEngine.Vector2,System.Boolean,System.Single)">
            <summary>
            Shake image for specific time
            </summary>
            <param name="image">Image to apply shake </param>
            <param name="lenght">lenght of shake animation</param>
            <param name="shakeAmount">amount of shake in x,y</param>
            <param name="saveTexCoords">Whether to return to initial TexCoords after shake </param>
            <param name="fadeout">Fade out shake at specified time left of shake</param>
        </member>
        <member name="T:Skill.Framework.UI.ImageZoom">
            <summary>
            A helper class to simulate zoom in ImageWithTexCoords
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.Zoom(Skill.Framework.UI.ImageWithTexCoords,System.Single,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>
            Zoom from startTextCoords to destTextCoords
            </summary>
            <param name="image">Image to apply zoom effect</param>
            <param name="lenght">lenght of zoom animation</param>
            <param name="startTextCoords">start TextCoords</param>
            <param name="destTextCoords">destination TextCoords</param>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.ZoomTo(Skill.Framework.UI.ImageWithTexCoords,System.Single,System.Single,System.Single)">
            <summary>
            Zoom to center of image 
            </summary>
            <param name="image">Image to apply zoom effect</param>
            <param name="lenght">lenght of zoom animation</param>
            <param name="zoomInX">zoom percent in x</param>
            <param name="zoomInY"> zoom percent in y </param>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.ZoomTo(Skill.Framework.UI.ImageWithTexCoords,System.Single,UnityEngine.Rect)">
            <summary>
            Zoom from currect TextCoords to destTextCoords
            </summary>
            <param name="image">Image to apply zoom effect</param>
            <param name="lenght">lenght of zoom animation</param>
            <param name="destTextCoords">destination TextCoords</param>
        </member>
        <member name="M:Skill.Framework.UI.ImageZoom.ZoomTo(Skill.Framework.UI.ImageWithTexCoords,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            zoom from currect TextCoords to rect defined in pixels
            </summary>
            <param name="image">Image to apply zoom effect</param>
            <param name="lenght">lenght of zoom animation</param>
            <param name="x"> pixel x (0 - image.Texture.width)</param>
            <param name="y"> pixel y (0 - image.Texture.height) </param>
            <param name="width">with of destination in pixel</param>
            <param name="height">height of destination in pixel</param>
            <param name="inverseY">Inverse y</param>
        </member>
        <member name="T:Skill.Framework.UI.Menu">
            <summary>
            Contains frames and dialogs and manage how to they be visible
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.OnExit">
            <summary>
            Occurs when last frame removed(backed) from menu
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.#ctor(Skill.Framework.UI.Frame[])">
            <summary>
            Create a menu
            </summary>
            <param name="frames">Frames to use by menu</param>
        </member>
        <member name="M:Skill.Framework.UI.Menu.IsInUse(Skill.Framework.UI.Frame)">
            <summary>
            Is specified frame already in view stack? ( it is top most visible frame or reachable by calling 'Back()' )
            </summary>
            <param name="frame">Frame to check</param>
            <returns>True if frame is in use, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.UI.Menu.ShowFrame(System.String)">
            <summary>
            Show a frame in next render.do not call this when a dialog is visible or the frame already in use
            </summary>
            <param name="frameName">Valid name of frame to show in next render</param>
        </member>
        <member name="M:Skill.Framework.UI.Menu.ShowDialog(System.String)">
            <summary>
            Show a dialog in next render.do not call this when the frame already in use
            </summary>
            <param name="frameName">Valid name of frame(dialog) to show in next render</param>
        </member>
        <member name="M:Skill.Framework.UI.Menu.Back">
            <summary>
            Pop current frame from stack and show previous frame. do not call this when a dialog is visible 
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.Clear">
            <summary>
            Clear view stack
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.OnGUI">
            <summary>
            Call this in OnGUI method of MonoBehaviour to draw menu
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.Update">
            <summary>
            Update Menu
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Menu.HandleCommand(Skill.Framework.UI.UICommand,System.Boolean)">
            <summary>
            Handle specified command
            </summary>
            <param name="command">Command to handle</param>        
            <param name="handleTabIndex">whether to handle tab index</param>        
            <returns>True if command is handled, otherwise false</returns>        
            <remarks>
            1- This method first allow focused control (if exist) to handle command
            2- if not let the control that is under mouse cursor to handle command
            3- if not then go through controls and let each to handle command
            4- if not and handleTabIndex is true : 
                if command is Up   : PreviousTab()
                if command is Down : NextTab()
            5- Handle cancel command as Back
            as soon as first control handled the command ignore next steps
            </remarks>        
        </member>
        <member name="M:Skill.Framework.UI.Menu.GetEnumerator">
            <summary>
            Returns an System.Collections.IEnumerator
            </summary>
            <returns> An System.Collections.IEnumerator </returns>
        </member>
        <member name="M:Skill.Framework.UI.Menu.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an System.Collections.IEnumerator
            </summary>
            <returns> An System.Collections.IEnumerator </returns>
        </member>
        <member name="M:Skill.Framework.UI.Menu.EatTabKeyImplementation">
            <summary>
            Default implamentation of eat tab key
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Menu.TopFrame">
            <summary> Retrieves top most visible frame </summary>
        </member>
        <member name="P:Skill.Framework.UI.Menu.TopDialog">
            <summary> Retrieves top most visible dialog </summary>
        </member>
        <member name="P:Skill.Framework.UI.Menu.ExitDialog">
            <summary> Name of dialog to show before last frame removed from view stack</summary>
        </member>
        <member name="P:Skill.Framework.UI.Menu.EatTabKey">
            <summary>
            if true, use event when user pressed tab key on keyboard and allow to handle tab key by commands
            </summary>
            <remarks>
            Because Skill UI use commands to handle tab and cycle through controls, it must disable tab index that unity gui used internally.
            Remember if you draw custom control before Menu.OnGUI(), this method may not works correctly, so you have to eat tab key yourself at the begin of MonoBehaviour OnGUI.
            use Menu.EatTabKeyImplementation method
            or writting this code at begin of OnGUI:
            <code>
            if (UnityEngine.Event.current.keyCode == UnityEngine.KeyCode.Tab || UnityEngine.Event.current.character == '\t')
                   UnityEngine.Event.current.Use();
            </code>        
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.Menu.Item(System.String)">
            <summary>
            Retrieves frames by name
            </summary>
            <param name="name">Name of frame</param>
            <returns>Frame</returns>
        </member>
        <member name="E:Skill.Framework.UI.Menu.Exit">
            <summary>
            Occurs when last frame removed(backed) from menu
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.MenuFrame">
            <summary>
            Base class for frames to use in GameMenu. you have to inherite this and implement CreateUI() method and create required controls and add them to Frame
            this GameObject must be child of GameMenu
            </summary>
            <remarks>
            Because each Frame requires some specific textures and skins, i decided to separate each frame to GameObjects for better management.
            </remarks>
        </member>
        <member name="F:Skill.Framework.UI.MenuFrame.FrameName">
            <summary> Unique name of of frame </summary>
        </member>
        <member name="F:Skill.Framework.UI.MenuFrame.Location">
            <summary> Location of frame in screen </summary>
        </member>
        <member name="F:Skill.Framework.UI.MenuFrame.Width">
            <summary> Width of frame if Location is manual </summary>
        </member>
        <member name="F:Skill.Framework.UI.MenuFrame.Height">
            <summary> Height of frame if Location is manual </summary>
        </member>
        <member name="M:Skill.Framework.UI.MenuFrame.Awake">
            <summary> Awake </summary>
        </member>
        <member name="M:Skill.Framework.UI.MenuFrame.CreateUI">
            <summary> Create required controls and add them to Frame </summary>
            <returns>Root frame of ui</returns>
        </member>
        <member name="M:Skill.Framework.UI.MenuFrame.Update">
            <summary> Update </summary>
        </member>
        <member name="P:Skill.Framework.UI.MenuFrame.Frame">
            <summary> Frame </summary>
        </member>
        <member name="M:Skill.Framework.UI.PauseMenu.PauseGame">
            <summary> Same as Show() </summary>
        </member>
        <member name="M:Skill.Framework.UI.PauseMenu.Show">
            <summary> Show Game Menu </summary>
        </member>
        <member name="M:Skill.Framework.UI.PauseMenu.UnPauseGame">
            <summary>
            Same as Hide()
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.PauseMenu.Hide">
            <summary> Hide Game Menu </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.SplashImages">
            <summary> Texture : it could be Texture2D or MovieTexture(Unity Pro) </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.Scale">
            <summary> ScaleMode of splash image</summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.FadeTexture">
            <summary> Texture to use for fading texture between each splash image (black) </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.SplashTime">
            <summary> Time to show each splash </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.Size">
            <summary> Size of splash relative to screen (0.0f- 1.0f)</summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.AllowEscapeAfter">
            <summary> Allow escape slapsh after this time </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.LevelToLoad">
            <summary> Level to load in background.(Unity Pro) </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.FullScreenMovies">
            <summary> Show movies in fullscreen size</summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.FastEscape">
            <summary>
            If true when user press escape immediately go to next splash and ignore fadeout
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.SplashScreen.MaxLoadProgress">
            <summary>
            When AsyncOperation.progress reach this value we take it as load level process is completed
            </summary>
            <remarks>
            In my experience AsyncOperation.progress never reach 1.0f and i think this is a bug in unity,
            anyway if you think i am wrong or this bug is corrected set it to something more than 0.8f
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.OnCompleted">
            <summary> Occurs when SplashScreen is completed </summary>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.GetReferences">
            <summary>
            Get required references
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.Start">
            <summary>
            Start
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.Update">
            <summary> Update </summary>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.Escape">
            <summary>
            Allow subclass to define when user press escape 
            by defalut : Input.GetKeyDown(KeyCode.Escape)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.SplashScreen.OnGUI">
            <summary>
            OnGUI
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.SplashScreen.Completed">
            <summary> Occurs when SplashScreen is completed </summary>
        </member>
        <member name="T:Skill.Framework.UI.ToggleButtonGroup">
            <summary>
            Manage ToggleButtons and make sure only one of ToggleButtons is checked.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButtonGroup.#ctor">
            <summary>
            Create a ToggleButtonGroup
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButtonGroup.Add(Skill.Framework.UI.IToggleButton)">
            <summary>
            Add a ToggleButton to group
            </summary>
            <param name="button">Button to add</param>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButtonGroup.Remove(Skill.Framework.UI.IToggleButton)">
            <summary>
            Remove ToggleButton to group
            </summary>
            <param name="button">Button to remove</param>
            <returns>True if success otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.UI.ToggleButtonGroup.ForceChecked">
            <summary>
            Make sure that one button is always checked (default true)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToggleButtonGroup.Name">
            <summary> Gets or sets Name of group (optional) </summary>
        </member>
        <member name="T:Skill.Framework.UI.KeyCommand">
            <summary>
            Defines types of commands by Keyboard or Gamepad
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.None">
            <summary> Nothing </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Left">
            <summary> User pressed left direction </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Right">
            <summary> User pressed right direction </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Up">
            <summary> User pressed up direction </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Down">
            <summary> User pressed down direction </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Enter">
            <summary> User pressed enter (or something else) to accept</summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Cancel">
            <summary> User pressed escape (or something else) to cancel. also usable as Back command </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Home">
            <summary> User pressed home </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.End">
            <summary> User pressed end </summary>
        </member>
        <member name="F:Skill.Framework.UI.KeyCommand.Tab">
            <summary> User pressed tab </summary>
        </member>
        <member name="T:Skill.Framework.UI.UICommand">
            <summary>
            Defines commands by Keyboard or Gamepad
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.UICommand.Reset">
            <summary> Reset all variables </summary>
        </member>
        <member name="M:Skill.Framework.UI.UICommand.GetDefaultInput">
            <summary>
            Get default input data from keyboard
            </summary>
            <returns>True if at least one key command is occured</returns>
        </member>
        <member name="P:Skill.Framework.UI.UICommand.Key">
            <summary> Key command </summary>
        </member>
        <member name="P:Skill.Framework.UI.UICommand.MousePosition">
            <summary> Position of mouse </summary>
        </member>
        <member name="P:Skill.Framework.UI.UICommand.Control">
            <summary> User holds control </summary>
        </member>
        <member name="P:Skill.Framework.UI.UICommand.Shift">
            <summary> Uset holds shift </summary>
        </member>
        <member name="P:Skill.Framework.UI.UICommand.Alt">
            <summary> Uset holds alt </summary>
        </member>
        <member name="T:Skill.Framework.UI.UIEventArgs">
            <summary>
            Base class for UI events
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.UIEventArgs.Handled">
            <summary> Is event handled </summary>
        </member>
        <member name="T:Skill.Framework.UI.MouseButton">
            <summary>
            Mouse Buttons
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.None">
            <summary> None </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse0">
            <summary> Mouse0 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse1">
            <summary> Mouse1 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse2">
            <summary> Mouse2 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse3">
            <summary> Mouse3 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse4">
            <summary> Mouse4 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse5">
            <summary> Mouse5 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Mouse6">
            <summary> Mouse6 </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Left">
            <summary> Left mouse button </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Right">
            <summary> Right mouse button </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Middle">
            <summary> Middle mouse button </summary>
        </member>
        <member name="F:Skill.Framework.UI.MouseButton.Other">
            <summary> Another button in the mouse </summary>
        </member>
        <member name="T:Skill.Framework.UI.MouseEventArgs">
            <summary>
            Mouse event args
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.MouseEventArgs.#ctor(UnityEngine.Vector2,UnityEngine.EventModifiers)">
            <summary>
            Create a MouseEventArgs
            </summary>
            <param name="mousePosition"> The mouse position. </param>
            <param name="modifiers"> Which modifier keys are held down. </param>
        </member>
        <member name="P:Skill.Framework.UI.MouseEventArgs.MousePosition">
            <summary> The mouse position. </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseEventArgs.Modifiers">
            <summary> Which modifier keys are held down. </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseEventArgs.Shift">
            <summary> Is Shift held down? (Read Only) </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseEventArgs.Ctrl">
            <summary> Is Control key held down? (Read Only) </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseEventArgs.Alt">
            <summary> Is Alt/Option key held down? (Read Only) </summary>
        </member>
        <member name="T:Skill.Framework.UI.MouseClickEventArgs">
            <summary>
            Mouse Click Event Args
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.MouseClickEventArgs.#ctor(UnityEngine.Vector2,UnityEngine.EventModifiers,Skill.Framework.UI.MouseButton,System.Int32)">
            <summary>
            Create a MouseClickEventArgs
            </summary>
            <param name="mousePosition"> The mouse position. </param>
            <param name="modifiers"> Which modifier keys are held down. </param>
            <param name="button"> Which mouse button was pressed. </param>
            <param name="clickCount">  How many consecutive mouse clicks have we received. </param>
        </member>
        <member name="P:Skill.Framework.UI.MouseClickEventArgs.Button">
            <summary> Which mouse button was pressed. Used in EventType.MouseDown, EventType.MouseUp events.  </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseClickEventArgs.ClickCount">
            <summary> How many consecutive mouse clicks have we received. </summary>
        </member>
        <member name="T:Skill.Framework.UI.MouseMoveEventArgs">
            <summary>
            Mouse Move Event Args
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.MouseMoveEventArgs.#ctor(UnityEngine.Vector2,UnityEngine.EventModifiers,Skill.Framework.UI.MouseButton,UnityEngine.Vector2)">
            <summary>
            Create a MouseMoveEventArgs
            </summary>
            <param name="mousePosition"> The mouse position. </param>
            <param name="modifiers"> Which modifier keys are held down. </param>
            <param name="button"> Which mouse button was pressed. </param>
            <param name="delta"> The relative movement of the mouse compared to last event. </param>
        </member>
        <member name="P:Skill.Framework.UI.MouseMoveEventArgs.Button">
            <summary> Which mouse button was pressed. Used in EventType.MouseDown, EventType.MouseUp events.  </summary>
        </member>
        <member name="P:Skill.Framework.UI.MouseMoveEventArgs.Delta">
            <summary> The relative movement of the mouse compared to last event. </summary>
        </member>
        <member name="T:Skill.Framework.UI.MouseEventHandler">
            <summary>
            MouseEventHandler
            </summary>
            <param name="sender"> Owner of event  </param>
            <param name="args"> MouseEventArgs </param>
        </member>
        <member name="T:Skill.Framework.UI.MouseClickEventHandler">
            <summary>
            MouseClickEventHandler
            </summary>
            <param name="sender"> Owner of event  </param>
            <param name="args"> MouseClickEventArgs </param>
        </member>
        <member name="T:Skill.Framework.UI.MouseMoveEventHandler">
            <summary>
            MouseMoveEventHandler
            </summary>
            <param name="sender"> Owner of event  </param>
            <param name="args"> MouseMoveEventHandler </param>
        </member>
        <member name="T:Skill.Framework.UI.KeyEventArgs">
            <summary>
            KeyEventArgs
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.KeyEventArgs.#ctor(UnityEngine.KeyCode,System.Char)">
            <summary>
            Create a KeyEventArgs
            </summary>
            <param name="key">  The raw key code for keyboard events. </param>
            <param name="character"> The character typed. </param>
        </member>
        <member name="P:Skill.Framework.UI.KeyEventArgs.Character">
            <summary> The character typed. </summary>
        </member>
        <member name="P:Skill.Framework.UI.KeyEventArgs.Key">
            <summary> The raw key code for keyboard events. </summary>
        </member>
        <member name="T:Skill.Framework.UI.KeyEventHandler">
            <summary>
            KeyEventHandler
            </summary>
            <param name="sender"> Owner of event  </param>
            <param name="args"> KeyEventArgs </param>
        </member>
        <member name="T:Skill.Framework.IO.XmlElement">
            <summary>
            Represents an element.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.AppendChild(Skill.Framework.IO.XmlElement)">
            <summary>
            Adds the specified node to the end of the list of child nodes, of this node.
            </summary>
            <param name="newChild"> The node to add. All the contents of the node to be added are moved into the specified location.</param>
            <returns>The node added.</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.GetAttribute(System.String)">
            <summary>
            Returns the value for the attribute with the specified name.
            </summary>
            <param name="name"> The name of the attribute to retrieve. This is a qualified name. It is matched against the Name property of the matching node.</param>
            <returns>
            The value of the specified attribute. An empty string is returned if a matching
             attribute is not found or if the attribute does not have a specified or default value.
            </returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.SetAttribute(System.String,System.String)">
            <summary>
            Sets the value of the attribute with the specified name.
            </summary>
            <param name="name">
            The name of the attribute to create or alter. This is a qualified name. If
            the name contains a colon it is parsed into prefix and local name components.
            </param>
            <param name="value">The value to set for the attribute.</param>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.HasAttribute(System.String)">
            <summary>
            Determines whether the current node has an attribute with the specified name.
            </summary>
            <param name="name">The name of the attribute to find. This is a qualified name. It is matched against the Name property of the matching node.</param>
            <returns>true if the current node has the specified attribute; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.RemoveAll">
            <summary>
            Removes all specified attributes and children of the current node. Default attributes are not removed.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.RemoveAllAttributes">
            <summary>
            Removes all specified attributes from the element. Default attributes are not removed.
            </summary>
        </member>
        <member name="M:Skill.Framework.IO.XmlElement.RemoveAttribute(System.String)">
            <summary>
            Removes an attribute by name.
            </summary>
            <param name="name"> The name of the attribute to remove.This is a qualified name. It is matched against the Name property of the matching node.</param>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.Parent">
            <summary> Parent element </summary>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.Item(System.String)">
            <summary>
            Gets the first child element with the specified Name.
            </summary>
            <param name="name"> The qualified name of the element to retrieve. </param>
            <returns> The first XmlElement that matches the specified name. </returns>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.FirstChild">
            <summary>
            Gets the first child of the node.
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.Name">
            <summary>
            Gets the qualified name of the node.
            </summary>
            <returns>
            The qualified name of the node. For XmlElement nodes, this is the tag name of the element.
            </returns>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.NextSibling">
            <summary>
            Gets the XmlElement immediately following this element.
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.OwnerDocument">
            <summary>
            Gets the XmlDocument to which this node belongs.
            </summary>
        </member>
        <member name="P:Skill.Framework.IO.XmlElement.HasAttributes">
            <summary>
            Gets a boolean value indicating whether the current node has any attributes.
            </summary>
            <returns>
            true if the current node has attributes; otherwise, false.
            </returns>
        </member>
        <member name="T:Skill.Framework.Controller">
            <summary>
            Base class for controllers
            </summary>
        </member>
        <member name="F:Skill.Framework.Controller.Identifier">
            <summary>
            An optional meaningful identifier for controller to be distinguishable from others.
            (set this to a valid value to be visible in BehaviorTree debugger)
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.HookEvents">
            <summary>
            Hooks required events of EventManager.
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.UnhookEvents">
            <summary>
            Unhooks hooked events
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.Events_Die(System.Object,System.EventArgs)">
            <summary>
            Notify GameObject is dead
            </summary>
            <param name="sender"> The source of the event. </param>
            <param name="e"> An System.EventArgs that contains no event data. </param>
        </member>
        <member name="M:Skill.Framework.Controller.Events_Hit(System.Object,Skill.Framework.HitEventArgs)">
            <summary>
            Handle a ray or somthing Hit this GameObject
            </summary>
            <param name="sender"> sender </param>
            <param name="args"> An HitEventArgs that contains hit event data. </param>        
        </member>
        <member name="M:Skill.Framework.Controller.Events_Cached(System.Object,Skill.Framework.Managers.CacheEventArgs)">
            <summary>
            Handle when object cached by CacheSpawner
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Skill.Framework.Controller.OnDestroy">
            <summary>
            when controller destroyed
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.DestroySelf">
            <summary>
            Destroy controller
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Skill.Framework.Controller.GetReferences">
            <summary>
            Get required references
            </summary>
        </member>
        <member name="P:Skill.Framework.Controller.Behavior">
            <summary>
            BehaviorTree of controller (should provide by subclass)
            </summary>
        </member>
        <member name="P:Skill.Framework.Controller.Health">
            <summary>
            Health
            </summary>
        </member>
        <member name="P:Skill.Framework.Controller.Spawner">
            <summary>
            Spawner that spawned this controller
            </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheEventArgs">
            <summary>
            containing cache event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.CacheEventArgs.#ctor(System.Int32)">
            <summary>
            Create CacheEventArgs
            </summary>
            <param name="cacheId"> cache id </param>
        </member>
        <member name="P:Skill.Framework.Managers.CacheEventArgs.CacheId">
            <summary> Cache id </summary>
        </member>
        <member name="T:Skill.Framework.Managers.CacheEventHandler">
            <summary>
            Handle when GameObject is cached
            </summary>
            <param name="sender"> The source of the event. (null)</param>
            <param name="args"> A CacheEventArgs containing cache data </param>
        </member>
        <member name="T:Skill.Framework.Managers.Cache">
            <summary>
            Manage spawning cache objects
            </summary>
        </member>
        <member name="M:Skill.Framework.Managers.Cache.Spawn(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
            Spawn a cache object
            </summary>
            <param name="prefab">GameObject with CacheBehavior component</param>
            <param name="position">Position</param>
            <param name="rotation">Rotation</param>
            <param name="active">Activate at spawn time or let caller activate it self</param>
            <returns>Spawned GameObject</returns>
            <remarks>
            If GameObject has not a CacheBehavior component, spawner instantiate it normally ( by GameObject.Instantiate method )
            </remarks>
        </member>
        <member name="M:Skill.Framework.Managers.Cache.DestroyCache(UnityEngine.GameObject)">
            <summary>
            Destroy cache GameObject and add to free list
            </summary>
            <param name="objectToDestroy">GameObject with CacheBehavior component</param>
            <remarks>
            If GameObject has not a CacheBehavior component, spawner destroy it normally ( by GameObject.Destroy method )
            </remarks>
        </member>
        <member name="T:Skill.Framework.Modules.DelayRender">
            <summary>
            Object vill be visible at specific time after instantiate
            </summary>    
        </member>
        <member name="F:Skill.Framework.Modules.DelayRender.Delay">
            <summary> Delay time </summary>
        </member>
        <member name="M:Skill.Framework.Modules.DelayRender.OnEnable">
            <summary>
            OnEnable
            </summary>
        </member>
        <member name="M:Skill.Framework.Modules.DelayRender.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="T:Skill.Framework.Triggers.CameraShakeTrigger">
            <summary>
            Shake camera on trigger enter
            </summary>    
        </member>
        <member name="F:Skill.Framework.Triggers.CameraShakeTrigger.Shake">
            <summary>
            Camera shake config
            </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.CameraShakeTrigger.OnEnter(UnityEngine.Collider)">
            <summary>
            called when the Collider other enters the trigger.
            </summary>
            <param name="other">other Collider</param>
            <returns>True if event handled, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.Triggers.CameraShakeTrigger.GizmoFilename">
            <summary>
            Name of file in Gizmos folder 
            </summary>
        </member>
        <member name="T:Skill.Framework.Triggers.DamageTrigger">
            <summary>
            Apply periodic damage to each collidion objects
            </summary>    
        </member>
        <member name="F:Skill.Framework.Triggers.DamageTrigger.Damage">
            <summary> Amount of damage </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.DamageTrigger.Interval">
            <summary> Interval between apply damage while stay in collision </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.DamageTrigger.Range">
            <summary> Maximum distance to apply damage (if DecreaseByDistance is true ) </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.DamageTrigger.DecreaseByDistance">
            <summary> Decrease amount of damage by distance </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.DamageTrigger.DamageType">
            <summary> Damage Type </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.DamageTrigger.Awake">
            <summary>
            Awake
            </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.DamageTrigger.OnEnter(UnityEngine.Collider)">
            <summary>
            called when the Collider other enters the trigger.
            </summary>
            <param name="other">other Collider</param>
            <returns>True if event handled, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Triggers.DamageTrigger.OnExit(UnityEngine.Collider)">
            <summary>
            called when the Collider other has stopped touching the trigger.
            </summary>
            <param name="other">other Collider</param>
        </member>
        <member name="M:Skill.Framework.Triggers.DamageTrigger.OnStay(UnityEngine.Collider)">
            <summary>
            called almost all the frames for every Collider other that is touching the trigger.
            </summary>
            <param name="other">other Collider</param>
        </member>
        <member name="P:Skill.Framework.Triggers.DamageTrigger.UserData">
            <summary> User Data </summary>
        </member>
        <member name="T:Skill.Framework.Triggers.SlowMotionTrigger">
            <summary>
            Slow motion OnTriggerEnter 
            </summary>    
        </member>
        <member name="F:Skill.Framework.Triggers.SlowMotionTrigger.Motion">
            <summary>
            Slow motion config
            </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.SlowMotionTrigger.OnEnter(UnityEngine.Collider)">
            <summary>
            called when the Collider other enters the trigger.
            </summary>
            <param name="other">other Collider</param>
            <returns>True if event handled, otherwise false</returns>
        </member>
        <member name="P:Skill.Framework.Triggers.SlowMotionTrigger.GizmoFilename">
            <summary>
            Name of file in Gizmos folder 
            </summary>
        </member>
        <member name="T:Skill.Framework.Triggers.EnableTrigger">
            <summary>
            Enable or desable a spawner on trigger enter
            </summary>    
        </member>
        <member name="F:Skill.Framework.Triggers.EnableTrigger.Behaviours">
            <summary> Spawners </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.EnableTrigger.Enable">
            <summary> Enable spawners or disable spawners </summary>
        </member>
        <member name="F:Skill.Framework.Triggers.EnableTrigger.Delay">
            <summary> Delay before enable or disable spawners </summary>
        </member>
        <member name="M:Skill.Framework.Triggers.EnableTrigger.OnEnter(UnityEngine.Collider)">
            <summary>
            called when the Collider other enters the trigger.
            </summary>
            <param name="other">other Collider</param>
            <returns>True if event handled, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Triggers.EnableTrigger.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="P:Skill.Framework.Triggers.EnableTrigger.GizmoFilename">
            <summary>
            Name of file in Gizmos folder
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ControlType">
            <summary>
            Types of Controls
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.ControlType.Control">
            <summary>
            Controls that hosted by panels
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.ControlType.Panel">
            <summary>
            Panels that contains another Controls
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.ControlType.Frame">
            <summary>
            Frame 
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.BaseControlCollection">
            <summary>
            Defines methods to manipulate collection of BaseControls.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.OnLayoutChange">
            <summary>
            when any Control insid collection needs to update it's layout
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.#ctor(Skill.Framework.UI.Panel)">
            <summary>
            Create a BaseControlCollection
            </summary>
            <param name="panel"> Panel that use this collection</param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.Add(Skill.Framework.UI.BaseControl)">
            <summary>
            Adds an BaseControl to the Collection.
            </summary>
            <param name="control"> The BaseControl to add to Collection </param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.Insert(System.Int32,Skill.Framework.UI.BaseControl)">
            <summary>
            Inserts an element into the collection at the specified index.
            </summary>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <param name="control"> The BaseControl to add to Collection </param>                
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.Clear">
            <summary>
            Removes all Controls from the collection
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.Contains(Skill.Framework.UI.BaseControl)">
            <summary>
            Determines whether the collection contains a specific Control
            </summary>
            <param name="control">The Cotrol to locate in collection</param>
            <returns> true if Control is found in the collection; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.CopyTo(Skill.Framework.UI.BaseControl[],System.Int32)">
            <summary>
            Copies the elements of the collection to an System.Array, starting at a particular System.Array index.
            </summary>
            <param name="array">The one-dimensional System.Array that is the destination of the elements
            copied from collection. The System.Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
            array is multidimensional.-or-The number of elements in the source collection
            is greater than the available space from arrayIndex to the end of the destination
            array.-or-Type T cannot be cast automatically to the type of the destination array.
            </exception>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.Remove(Skill.Framework.UI.BaseControl)">
            <summary>
            Removes  the first occurrence of a specific control from the collection.
            </summary>
            <param name="control"> The BaseControl to remove from the collection </param>
            <returns>
            true if item was successfully removed from the collection otherwise, false.
            This method also returns false if item is not found in the original collection
            </returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltBaseControl;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.BringToFront(Skill.Framework.UI.BaseControl)">
            <summary>
            Attempts to bring this element to front.
            </summary>
            <param name="control">BaseControl to bring to front</param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.BringToBack(Skill.Framework.UI.BaseControl)">
            <summary>
            Attempts to bring this element to back.
            </summary>
            <param name="control">BaseControl to bring to back</param>
        </member>
        <member name="M:Skill.Framework.UI.BaseControlCollection.IndexOf(Skill.Framework.UI.BaseControl)">
            <summary>
            Searches for the specified BaseControl and returns the zero-based index of the first occurrence within the entire Controls.
            </summary>
            <param name="control">The BaseControl to locate in the Controls.</param>
            <returns>
            The zero-based index of the first occurrence of item within the entire Controls, if found; otherwise, –1.
            </returns>
        </member>
        <member name="E:Skill.Framework.UI.BaseControlCollection.LayoutChange">
            <summary>
             Occurs when any Control insid collection needs to update it's layout
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControlCollection.Panel">
            <summary>
            Panel that use this collection
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControlCollection.Item(System.Int32)">
            <summary>
            Retrieves controls by index
            </summary>
            <param name="index">index of control</param>
            <returns>Control at specified index</returns>
        </member>
        <member name="P:Skill.Framework.UI.BaseControlCollection.Count">
            <summary>
            Gets the number of Controls contained in the collection.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.BaseControlCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Button">
            <summary>
            Make a single press button. The user clicks them and something happens immediately.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Button.OnClick">
            <summary>
            when users clicks the button
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Button.#ctor">
            <summary>
            Create a Button
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Button.Render">
            <summary>
            Render button
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Button.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. button respond to Enter command
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>   
        </member>
        <member name="P:Skill.Framework.UI.Button.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.Button.Click">
            <summary>
            Occurs when users clicks the button
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ColumnDefinition">
            <summary>
            Defines column-specific properties that apply to Grid elements.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinition.#ctor">
            <summary>
            Initializes a new instance of the ColumnDefinition class.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ColumnDefinition.Change">
            <summary>
            Occurs when any changes happens to definition
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinition.Width">
            <summary>
             Gets the calculated width of a ColumnDefinition element,
             or sets the GridLength value of a column that is defined by the ColumnDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinition.MaxWidth">
            <summary>
            Gets or sets a value that represents the maximum width of a ColumnDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinition.MinWidth">
            <summary>
            Gets or sets a value that represents the minimum width of a ColumnDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinition.RenderWidth">
            <summary> Width of column after update layout </summary>
        </member>
        <member name="T:Skill.Framework.UI.ColumnDefinitionCollection">
            <summary>
            Provides access to an ordered, strongly typed collection of ColumnDefinition objects.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.#ctor">
            <summary>
            Create a instance of ColumnDefinitionCollection class
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.Add(Skill.Framework.UI.ColumnDefinition)">
            <summary>
            Adds a ColumnDefinition element to a ColumnDefinitionCollection.
            </summary>
            <param name="value">Identifies the ColumnDefinition to add to the collection.</param>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.Add(System.Single,Skill.Framework.UI.GridUnitType)">
            <summary>
            Adds a ColumnDefinition element to a ColumnDefinitionCollection.
            </summary>
            <param name="value"> The initial value of this instance of GridLength. </param>
            <param name="type"> The GridUnitType held by this instance of GridLength. </param>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.Clear">
            <summary>
            Clears the content of the ColumnDefinitionCollection.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.Contains(Skill.Framework.UI.ColumnDefinition)">
            <summary>
            Determines whether a given ColumnDefinition exists within a ColumnDefinitionCollection.
            </summary>
            <param name="value"> Identifies the ColumnDefinition that is being tested. </param>
            <returns>true if the ColumnDefinition exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.CopyTo(Skill.Framework.UI.ColumnDefinition[],System.Int32)">
            <summary>
             Copies an array of ColumnDefinition objects to a given index position within a ColumnDefinitionCollection.
            </summary>
            <param name="array"> An array of ColumnDefinition objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the ColumnDefinition objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.Remove(Skill.Framework.UI.ColumnDefinition)">
            <summary>
            Removes a ColumnDefinition from a ColumnDefinitionCollection.
            </summary>
            <param name="value"> The ColumnDefinition to remove from the collection. </param>
            <returns> true if the ColumnDefinition was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltColumnDefinition;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.Framework.UI.ColumnDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinitionCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a ColumnDefinitionCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="E:Skill.Framework.UI.ColumnDefinitionCollection.Change">
            <summary>
            Occurs when any changes happens to collection (Add, Remove, Clear)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinitionCollection.Count">
            <summary>
            Gets the total number of items within this instance of ColumnDefinitionCollection.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ColumnDefinitionCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a ColumnDefinitionCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ImageWithTexCoords">
            <summary>
            Draw a texture within a rectangle.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageWithTexCoords.#ctor">
            <summary>
            Create an instance of Image
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ImageWithTexCoords.Render">
            <summary>
            Render Image
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ImageWithTexCoords.Texture">
            <summary>
            Texture to display.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ImageWithTexCoords.AlphaBlend">
            <summary>
            Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ImageWithTexCoords.TextureCoordinate">
            <summary>
            Draw a texture within a rectangle with the given texture coordinates.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ImageWithTexCoords.TintColor">
            <summary>
            Getsor sets tinting color
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ImageWithTexCoords.AlphaFading">
            <summary>
            If not null Image use alpha value of referenced Fading
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Dock">
            <summary>
            Specifies the Dock position of a child element that  is inside a DockPanel.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Dock.Left">
            <summary>
            A child element that is positioned on the left side of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Dock.Top">
            <summary>
            A child element that is positioned at the top of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Dock.Right">
            <summary>
            A child element that is positioned on the right side of the DockPanel.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Dock.Bottom">
            <summary>
            A child element that is positioned at the bottom of the DockPanel.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.DockPanel">
            <summary>
            Defines an area where you can arrange child elements either horizontally or vertically, relative to each other.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.DockPanel.#ctor">
            <summary>
            Initializes a new instance of the DockPanel class.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.DockPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.DockPanel.LastChildFill">
            <summary>
            Gets or sets a value that indicates whether the last child element within
            a DockPanel stretches to fill the remaining available space. (The default value is true.)
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Frame">
            <summary>
            Frame is a content control that supports navigation.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.FocusControl(System.String)">
            <summary>
            Move keyboard focus to a named control.
            </summary>
            <param name="controlName">Name of focusable control</param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.FocusControl(Skill.Framework.UI.IFocusable)">
            <summary>
            Move keyboard focus to a named control.
            </summary>
            <param name="focusable">focusable control</param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.UnFocusControls">
            <summary>
            remove keyboard focus.
            </summary>        
        </member>
        <member name="M:Skill.Framework.UI.Frame.NextTab">
            <summary>
            Move focuced control to next tab index.
            </summary>
            <remarks>
            Set sequential tab index for controls inside a frame to make this method work correctly
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.PreviousTab">
            <summary>
            Move focuced control to previous tab index.
            </summary>
            <remarks>
            Set sequential tab index for controls inside a frame to make this method work correctly
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.RegisterPrecedenceEvent(Skill.Framework.UI.BaseControl)">
            <summary>
            request to have chance for handle events frst
            </summary>
            <param name="pe">BaseControl to register</param>
            <returns>True if succes, oterwise false
            </returns>
        </member>
        <member name="M:Skill.Framework.UI.Frame.UnregisterPrecedenceEvent(Skill.Framework.UI.BaseControl)">
            <summary>
            unregister from chance for handle events frst
            </summary>
            <param name="pe">BaseControl to unregister</param>
            <returns>True if succes, oterwise false</returns>
            <remarks> pe must registered before </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.IsPrecedenceEvent(Skill.Framework.UI.BaseControl)">
            <summary>
            Is registered for PrecedenceEvent
            </summary>
            <param name="pe"> BaseControl to check </param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnPositionChange">
            <summary>
            when position of control changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.CheckEvents">
            <summary>
            Check for events
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnKeyDown(Skill.Framework.UI.KeyEventArgs)">
            <summary>
            Occurs when a keyboard key was pressed.
            </summary>
            <param name="args"> KeyEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnKeyUp(Skill.Framework.UI.KeyEventArgs)">
            <summary>
            Occurs when a keyboard key was released.
            </summary>
            <param name="args"> KeyEventArgs </param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnGUI">
            <summary>
            to render control you have to call this method in OnGUI method of MonoBehavior.(call this for Frame class)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.Update">
            <summary>
            Update GUI Frame
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.DrawControls">
            <summary>
            Call Grid.OnGUI() to draw controls
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Frame.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Frame class.
            </summary>        
            <param name="name">Valid and unique name of frame</param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.EnterFrame">
            <summary>
            Called when Frame is about to enter view stack
            </summary>
            <returns>Whehter enter is success or still needs time to success</returns>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnEnter">
            <summary>
            Called when Frame is about to enter view stack
            </summary>
            <returns>Whehter enter is success or still needs time to success</returns>
            <remarks>
            It is possible frame has animations or fades. keep return false until these operations succeed.
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.LeaveFrame(System.Boolean@)">
            <summary>
            Called when Frame is about to leave view stack
            </summary>        
            <param name="cancel">Cancel leave operation do to show a dialog, ... </param>
            <returns>Whehter leave is success or still needs time to success</returns>        
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnLeave(System.Boolean@)">
            <summary>
            Called when Frame is about to leave view stack
            </summary>        
            <param name="cancel">Cancel leave operation do to show a dialog, ... </param>
            <returns>Whehter leave is success or still needs time to success</returns>
            <remarks>
            It is possible frame has animations or fades. keep return false until these operations succeed.
            In some senarios like 'Settings menu' it is possible to cancel frame leave and show a dialog to ask for 'are you sure?'
            and get result back by 'HandleDialogMessage' method, then if user accepts, call 'Menu.Back()' again to continue frame leave.
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.HideFrame">
            <summary>
            Called when Frame is in view stack and about to hide do to another frame pushed in view stack
            </summary>
            <returns>Whehter hide is success or still needs time to success</returns>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnHide">
            <summary>
            Called when Frame is in view stack and about to hide do to another frame pushed in view stack
            </summary>
            <returns>Whehter hide is success or still needs time to success</returns>
            <remarks>
            It is possible frame has animations or fades. keep return false until these operations succeed.
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.ShowFrame">
            <summary>
            Called when Frame is in view stack and hide, when a higher Frame in view stack leaved and cause this Frame showed again
            </summary>
            <returns>Whehter show is success or still needs time to success</returns>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnShow">
            <summary>
            Called when Frame is in view stack and hide, when a higher Frame in view stack leaved and cause this Frame showed again
            </summary>
            <returns>Whehter show is success or still needs time to success</returns>
            <remarks>
            It is possible frame has animations or fades. keep return false until these operations succeed.
            </remarks>
        </member>
        <member name="M:Skill.Framework.UI.Frame.HandleDialog(Skill.Framework.UI.Frame)">
            <summary>
            Let Frame handle requested dialog
            </summary>
            <param name="dialog">The dialog requested by this frame</param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.OnHandleDialog(Skill.Framework.UI.Frame)">
            <summary>
            Let Frame handle requested dialog
            </summary>
            <param name="dialog">The dialog requested by this frame</param>
        </member>
        <member name="M:Skill.Framework.UI.Frame.HandleCommand(Skill.Framework.UI.UICommand,System.Boolean)">
            <summary>
            Handle specified command
            </summary>
            <param name="command">Command to handle</param>        
            <param name="handleTabIndex">whether to handle tab index</param>
            <returns>True if command is handled, otherwise false</returns>        
            <remarks>
            1- This method first allow focused control (if exist) to handle command
            2- if not let the control that is under mouse cursor to handle command        
            3- if not and handleTabIndex is true : 
                if command is Up   : PreviousTab()
                if command is Down : NextTab()
            as soon as first control handled the command ignore next steps
            </remarks>        
        </member>
        <member name="P:Skill.Framework.UI.Frame.Parent">
            <summary> Frame does not have parent </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.ControlType">
            <summary> Specify type of Control  </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.IsEnabled">
            <summary>
            Gets or sets a value indicating whether this element is enabled in the user interface (UI).
            </summary>
            <returns>  true if the element is enabled; otherwise, false. The default value is true. </returns>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Position">
            <summary>
            Position of control relative to parent
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.X">
            <summary>
            Gets or sets Position.X
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Y">
            <summary>
            Gets or sets Position.Y
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Width">
            <summary>
            Gets or sets the suggested width of the element
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Height">
            <summary>
            Gets or sets the suggested height of the element.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Name">
            <summary>
            Retrieves Name of Frame.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Grid">
            <summary>
            Grid of Frame.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.FocusedControl">
            <summary>
            Get focused FocusableControl in last update or null if no FocusableControl got focus
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Menu">
            <summary>
            Retrieves parent menu of frame
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.DialogResult">
            <summary>
            Result of frame when used as a dialog. A dialog will continue modal until this value be somthing except 'None'
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.Frame.PositionChange">
            <summary> Occurs when position of control changed </summary>
        </member>
        <member name="E:Skill.Framework.UI.Frame.KeyDown">
            <summary> Occurs when a keyboard key was pressed.() </summary>
        </member>
        <member name="E:Skill.Framework.UI.Frame.KeyUp">
            <summary> Occurs when a keyboard key was released. </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.LocalGrid">
            <summary>
            Is grid rendered in local space of Frame.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Frame.Controls">
            <summary>
            Grid.Controls.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.GridLength">
            <summary>
            Represents the length of elements that explicitly support Skill.UI.GridUnitType.Star unit types.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the GridLength structure using the specified absolute value in pixels.
            </summary>
            <param name="pixels"> The number of  pixels.</param>
            <exception cref="T:System.ArgumentException">Pixels is equal to float.NegativeInfinity, float.PositiveInfinity, or float.NaN </exception>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.#ctor(System.Single,Skill.Framework.UI.GridUnitType)">
            <summary>
            Initializes a new instance of the GridLength structure and specifies what kind of value it holds.
            </summary>
            <param name="value"> The initial value of this instance of GridLength. </param>
            <param name="type"> The GridUnitType held by this instance of GridLength. </param>
            <exception cref="T:System.ArgumentException">Pixels is equal to float.NegativeInfinity, float.PositiveInfinity, or float.NaN </exception>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.op_Equality(Skill.Framework.UI.GridLength,Skill.Framework.UI.GridLength)">
            <summary>
             Compares two GridLength structures for equality.
            </summary>
            <param name="gl1"> The first instance of GridLength to compare. </param>
            <param name="gl2"> The second instance of GridLength to compare. </param>
            <returns> true if the two instances of GridLength have the same value and GridUnitType; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.op_Inequality(Skill.Framework.UI.GridLength,Skill.Framework.UI.GridLength)">
            <summary>
             Compares two GridLength structures to determine if they are not equal.
            </summary>
            <param name="gl1"> The first instance of GridLength to compare. </param>
            <param name="gl2"> The second instance of GridLength to compare. </param>
            <returns>true if the two instances of GridLength do not have the same value and GridUnitType; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current GridLength instance.
            </summary>
            <param name="oCompare"> The object to compare with the current instance. </param>
            <returns> true if the specified object has the same value and GridUnitType as the current instance; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.Equals(Skill.Framework.UI.GridLength)">
            <summary>
            Determines whether the GridLength is equal to the current GridLength.
            </summary>
            <param name="gridLength"> The GridLength structure to compare with the current instance. </param>
            <returns> true if the specified GridLength has the same value and GridUnitType as the current instance; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.GetHashCode">
            <summary>
            Gets a hash code for the GridLength.
            </summary>
            <returns>
             A hash code for the current GridLength structure.
            </returns>
        </member>
        <member name="M:Skill.Framework.UI.GridLength.ToString">
            <summary>
            Returns a System.String representation of the GridLength.
            </summary>
            <returns> A System.String representation of the current GridLength structure.</returns>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.IsAbsolute">
            <summary>
            Gets a value that indicates whether the GridLength holds a value that is expressed in pixels.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.IsAuto">
            <summary>
            Gets a value that indicates whether the GridLength holds a value whose size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.IsStar">
            <summary>
             Gets a value that indicates whether the GridLength holds a value that is expressed as a weighted proportion of available space.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.Value">
            <summary>
            Gets a float that represents the value of the GridLength.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.GridUnitType">
            <summary>
            Gets the associated GridUnitType for the GridLength.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.GridLength.Auto">
            <summary>
            Gets an instance of GridLength that holds a value whose size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.GridUnitType">
            <summary>
            Describes the kind of value that a GridLength object is holding.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.GridUnitType.Auto">
            <summary>
            The size is determined by the size properties of the content object.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.GridUnitType.Pixel">
            <summary>
            The value is expressed as a pixel.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.GridUnitType.Star">
            <summary>
            The value is expressed as a weighted proportion of available space.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Group">
            <summary>
            A group of controls
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Group.#ctor">
            <summary>
            Create new instance of Group
            </summary>        
        </member>
        <member name="M:Skill.Framework.UI.Group.BeginRender">
            <summary> Begin render contents </summary>
        </member>
        <member name="M:Skill.Framework.UI.Group.EndRender">
            <summary> End render contents </summary>
        </member>
        <member name="P:Skill.Framework.UI.Group.Content">
            <summary>
            Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out,
            no background is rendered, and mouse clicks are passed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Group.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.HorizontalAlignment">
            <summary>
            Indicates where an element should be displayed on the horizontal axis relative to the allocated layout slot of the parent element.    
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.HorizontalAlignment.Left">
            <summary>
            An element aligned to the left of the layout slot for the parent element.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.HorizontalAlignment.Center">
            <summary>
            An element aligned to the center of the layout slot for the parent element.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.HorizontalAlignment.Right">
            <summary>
            An element aligned to the right of the layout slot for the parent element.
            </summary>     
        </member>
        <member name="F:Skill.Framework.UI.HorizontalAlignment.Stretch">
            <summary>
            An element stretched to fill the entire layout slot of the parent element.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Image">
            <summary>
            Draw a texture within a rectangle.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Image.#ctor">
            <summary>
            Create an instance of Image
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Image.Render">
            <summary>
            Render Image
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.Texture">
            <summary>
            Texture to display.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.Scale">
            <summary>
            How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.AlphaBlend">
            <summary>
            Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.ImageAspect">
            <summary>
            Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
            Pass in w/h for the desired aspect ratio.
            This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.TintColor">
            <summary>
            Getsor sets tinting color
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Image.AlphaFading">
            <summary>
            If not null Image use alpha value of referenced Fading
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.SelectionMode">
            <summary> Defines the selection behavior for a ListBox. </summary>
        </member>
        <member name="F:Skill.Framework.UI.Extended.SelectionMode.Single">
            <summary> The user can select only one item at a time. </summary>
        </member>
        <member name="F:Skill.Framework.UI.Extended.SelectionMode.Multiple">
            <summary> The user can select multiple items without holding down a modifier key. </summary>
        </member>
        <member name="F:Skill.Framework.UI.Extended.SelectionMode.Extended">
            <summary> The user can select multiple consecutive items while holding down the SHIFT key. </summary>
        </member>
        <member name="T:Skill.Framework.UI.Extended.ListBox">
            <summary>
            Contains a list of selectable items.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.StackPanel">
            <summary>
            Arranges child elements into a single line that can be oriented horizontally or vertically.    
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.StackPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.StackPanel.#ctor">
            <summary>
            Create an instance of StackPanel
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.StackPanel.OnLayoutChanged">
            <summary>
            When Layout changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.StackPanel.Orientation">
            <summary>
            Gets or sets a value that indicates the dimension by which child elements are stacked.
            </summary>       
        </member>
        <member name="P:Skill.Framework.UI.StackPanel.LayoutHeight">
            <summary>
            Retrieves Height used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.StackPanel.LayoutWidth">
            <summary>
            Retrieves Width used in layout. It is dependents on visibility and state of children
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.DisableFocusable">
            <summary> Disable focusable - sometimes in editor it is better to disable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.EnableFocusable">
            <summary> Enable focusable </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.OnGotFocus">
            <summary>
            when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.OnLostFocus">
            <summary>
            when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.Focus">
            <summary> Try focuse control </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.OnSelectionChanged">
            <summary>
            when the selection of ListBox changes.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.#ctor">
            <summary>
            Create an instance of ScrollView
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.BeginRender">
            <summary> Begin render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.Render">
            <summary>
            Render ListBox
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.Extended.ListBox.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. (Up and Down command to switch selected index)
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>        
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.TabIndex">
            <summary> Tab index of control. </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.IsFocused">
            <summary>
            Gets a value that determines whether this element has logical focus. (You must set valid name to enable this behavior)
            </summary>
            <returns>
            true if this element has logical focus; otherwise, false.(You must set valid name to enable this behavior)
            </returns>
            <remarks>
            Set used for internal use
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.IsFocusable">
            <summary>
            Indicates whether the element can receive focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.IsExtendedFocusable">
            <summary> it is an extended focusable </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.ListBox.GotFocus">
            <summary>
            Occurs when this element gets logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.Extended.ListBox.LostFocus">
            <summary>
            Occurs when this element loses logical focus.(You must set valid name to enable this behavior)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.Items">
            <summary>
            This is same as Controls property (for adaptability)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.SelectedItems">
            <summary> Gets the currently selected items. </summary>
            <returns> Returns a collection of the currently selected items. </returns>
            <exception cref="T:System.InvalidOperationException"> The ListBox.SelectionMode property is set to SelectionMode.Single. </exception>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.SelectedItem">
            <summary> Gets or sets the first item in the current selection or returns null if the selection is empty </summary>
            <returns>The first item in the current selection or null if the selection is empty.</returns>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.AutoScroll">
            <summary>
            If true : Listbox scroll to view selected item whenever user changed SelectedItem with key command in SelectionMode.Single.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.SelectedIndex">
            <summary> 
            Gets or sets the index of the first item in the current selection or returns
            negative one (-1) if the selection is empty.
            </summary>
            <returns>
            The index of first item in the current selection. The default value is negative one (-1).
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.SelectionMode">
            <summary>
            Gets or sets the selection behavior for a ListBox.
            </summary>
            <returns>One of the SelectionMode values. The default is SelectionMode.Single selection.</returns>
        </member>
        <member name="E:Skill.Framework.UI.Extended.ListBox.SelectionChanged">
            <summary>
            Occurs when the selection of ListBox changes.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.SelectedStyle">
            <summary>
            Style to use for Box used as background of selected items
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.BackgroundVisible">
            <summary>
            Is background visible
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.Background">
            <summary>
            Border and Background.
            </summary>
            <remarks>
            To draw border and background if ListBox set visibility of Background property to true and set valid style
            </remarks>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.FocusedBackground">
            <summary>
            Border and Background to use when listbox is focused.
            </summary>                
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.HorizontalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.VerticalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.ScrollPosition">
            <summary>
            The pixel distance that the view is scrolled in the X and Y directions.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.ScrollX">
            <summary>
            The pixel distance that the view is scrolled in the X direction.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.ScrollY">
            <summary>
            The pixel distance that the view is scrolled in the Y direction.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.AlwayShowHorizontal">
            <summary>
            Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when clientRect is wider than position.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.AlwayShowVertical">
            <summary>
            Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when clientRect is taller than position.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.HandleScrollWheel">
            <summary>
            Optional parameter to handle ScrollWheel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.ScrollViewRect">
            <summary>
            Gets view rectangle used for inner ScrollView
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.ScrollbarThickness">
            <summary>
            Gets or sets thikness of vertical scrollbar to consider when calculating scrollview area (default is 16)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.Orientation">
            <summary> Gets or sets a value that indicates the dimension by which child elements are stacked. </summary>
        </member>
        <member name="P:Skill.Framework.UI.Extended.ListBox.Padding">
            <summary>
            Gets or sets the padding inside a control.
            </summary>
            <returns>
            The amount of space between the content of a Panel
            and its Margin or Border.
            The default is a thickness of 0 on all four sides.
            </returns>
        </member>
        <member name="T:Skill.Framework.UI.Orientation">
            <summary>
            Defines the different orientations that a control or layout can have.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Orientation.Horizontal">
            <summary>
            Control or layout should be horizontally oriented.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Orientation.Vertical">
            <summary>
            Control or layout should be vertically oriented.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.PasswordField">
            <summary>
            Make a text field where the user can enter a password.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.PasswordField.OnPasswordChanged">
            <summary>
            when password changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.PasswordField.#ctor">
            <summary>
            Create an instance of PasswordField
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.PasswordField.Render">
            <summary>
            Render PasswordField
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.PasswordField.Password">
            <summary>
            Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.PasswordField.PasswordChanged">
            <summary>
            Occurs when password changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.PasswordField.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.PasswordField.MaskChar">
            <summary>
            Character to mask the password with.(default '•')
            </summary>
        </member>
        <member name="T:Skill.Framework.Text.IPersianCharacterMap">
            <summary>
            Defines character mapping information for persian language
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.IPersianCharacterMap.GetMappedCharacter(System.Char)">
            <summary>
            maps each none persian chracter to equivalent persian character
            </summary>
            <param name="c">The character to remap to persian character</param>
            <returns>if there is a map for given character returns a PersianCharacter, otherwise null.</returns>
        </member>
        <member name="T:Skill.Framework.Text.PersianCharacterMap">
            <summary>
            Default PersianCharacterMap 
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacterMap.UseFirstNumerics">
            <summary>
            Use first set of persian characters in unicode ( '\u0660', '\u0661', ... , '\u0669' )
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacterMap.UseSecondNumerics">
            <summary>
            Use second set of persian characters in unicode ( '\u06F0', '\u06F1', ... , '\u06F9' )
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacterMap.#ctor(System.Boolean)">
            <summary>
            Create a PersianCharacterMap
            </summary>
            <param name="convertEnglishCharacters">Whether convert english characters to equivalent persian characters (as on keyboard)?</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacterMap.GetMappedCharacter(System.Char)">
            <summary>
            maps each none persian chracter to equivalent persian character
            </summary>
            <param name="c">The character to remap to persian character</param>
            <returns>if there is a map for given character returns a PersianCharacter, otherwise null.</returns>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Alef">
            <summary> الف </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Beh">
            <summary> ب </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Peh">
            <summary> پ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Teh">
            <summary> ت </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Theh">
            <summary> ث </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Jeem">
            <summary> ج </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Cheh">
            <summary> چ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Hah">
            <summary> ح </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Khah">
            <summary> خ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Dal">
            <summary> د </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Thal">
            <summary> ذ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Reh">
            <summary> ر </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Zain">
            <summary> ز </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Jeh">
            <summary> ژ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Seen">
            <summary> س </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Sheen">
            <summary> ش </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Sad">
            <summary> ص </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Dad">
            <summary> ض </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Tah">
            <summary> ط </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Zah">
            <summary> ظ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Ain">
            <summary> ع </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Ghain">
            <summary> غ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Feh">
            <summary> ف </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Qaf">
            <summary> ق </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Kaf">
            <summary> ک </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Gaf">
            <summary> گ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Lam">
            <summary> ل </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Meem">
            <summary> م </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Noon">
            <summary> ن </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Waw">
            <summary> و </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Heh">
            <summary> ه </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Yeh">
            <summary> ی </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Zero">
            <summary> 0 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.One">
            <summary> 1 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Two">
            <summary> 2 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Three">
            <summary> 3 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Four">
            <summary> 4 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Five">
            <summary> 5 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Six">
            <summary> 6 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Seven">
            <summary> 7 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Eight">
            <summary> 8 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Nine">
            <summary> 9 </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Fathatan">
            <summary> اً </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Dammatan">
            <summary> اٌ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Kasratan">
            <summary> اٍ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Fatha">
            <summary> اَ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Damma">
            <summary> اُ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Kasra">
            <summary> اِ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Shadda">
            <summary> اّ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.RialSign">
            <summary> ريال </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Comma">
            <summary> ، </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Semicolon">
            <summary> ؛ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.AlefMadda">
            <summary> آ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.WawWithHamzaAbove">
            <summary> ؤ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.AlefWithHamzaAbove">
            <summary> أ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.AlefWithHamzaBelow">
            <summary> إ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Hamza">
            <summary> ء </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.QuestionMark">
            <summary> ؟ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Tatweel">
            <summary> ـ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.LeftParenthesis">
            <summary> ( </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.RightParenthesis">
            <summary> ) </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.YehWithHamzaAbove">
            <summary> ئ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.ExclamationMark">
            <summary> ! </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Dot">
            <summary> . </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.DollarSign">
            <summary> $ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.PercentSign">
            <summary> % </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Ampersand">
            <summary> and </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Asterisk">
            <summary> * </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.PlusSign">
            <summary> + </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.HyphenMinus">
            <summary> - </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.FullStop">
            <summary> . </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.EqualSign">
            <summary> = </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.LessThanSign">
            <summary> lth; </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.GreaterThanSign">
            <summary> gth; </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.CommercialAt">
            <summary> @ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.CircumflexAccent">
            <summary> ^ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.LowLine">
            <summary> _ </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.NewLine">
            <summary> \n </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.Tab">
            <summary> \t </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.LigatureLam">
            <summary> لا </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.LigatureAllah">
            <summary> الله </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacterMap.ConvertEnglishCharacters">
            <summary>
            Whether convert english characters to equivalent persian characters (as on keyboard)?
            </summary>
        </member>
        <member name="T:Skill.Framework.Text.PersianCharacter">
            <summary>
            Defines all forms of a persian character
            </summary>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.#ctor(System.Char,System.Char,System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Create a PersianCharacter
            </summary>
            <param name="initial">Character in Initial form</param>
            <param name="medial">Character in Medial form</param>
            <param name="final">Character in Final form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.#ctor(System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Create a PersianCharacter
            </summary>        
            <param name="final">Character in Final (also Initial and Medial) form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.#ctor(System.Char)">
            <summary>
            Create a PersianCharacter
            </summary>                
            <param name="isolated">Character in Isolated ( also Initial, Medial and Final) form</param>        
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.SetData(System.Char,System.Char,System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Set all properties in one call
            </summary>
            <param name="initial">Character in Initial form</param>
            <param name="medial">Character in Medial form</param>
            <param name="final">Character in Final form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.SetData(System.Char,System.Char,System.Boolean,System.Boolean)">
            <summary>
            Set all properties in one call
            </summary>        
            <param name="final">Character in Final (also Initial and Medial) form </param>
            <param name="isolated">Character in Isolated form</param>
            <param name="canStickToPrevious">can stick to previous character</param>
            <param name="canStickToNext">can stick to next character</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.SetData(System.Char)">
            <summary>
            Set all properties in one call
            </summary>                
            <param name="isolated">Character in Isolated ( also Initial, Medial and Final) form</param>  
        </member>
        <member name="M:Skill.Framework.Text.PersianCharacter.Contains(System.Char)">
            <summary>
            Whether specified character is any form of persian character
            </summary>
            <param name="c">Character to check</param>
            <returns>True if specified character is one form of persian character, otherwise false.</returns>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.InitialForm">
            <summary> Gets or sets Character in Initial form </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.MedialForm">
            <summary> Gets or sets Character in Medial form </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.FinalForm">
            <summary> Gets or sets Character in Final form </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.IsolatedForm">
            <summary> Gets or sets Character in Isolated form </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.CanStickToPrevious">
            <summary> Whether this persian character can stick to previous character.</summary>
            <remarks>
            usually four form characters can stick to previous and next character, two form characters can stick to previous and not to next character.
            </remarks>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.CanStickToNext">
            <summary> Whether this persian character can stick to next character.</summary>
            <remarks>
            usually four form characters can stick to previous and next character, two form characters can stick to previous and not to next character.
            </remarks>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.LeftToRight">
            <summary>
            Is this character left to right ( like numerics )
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianCharacter.Item(Skill.Framework.Text.PersianCharacterForm)">
            <summary> Gets or sets Character in specified form </summary>
            <param name="form">Form of persian character</param>
            <returns>Character in specified form.</returns>
        </member>
        <member name="T:Skill.Framework.Text.PersianTextFieldConverter">
            <summary>
            Convert a text contains of none persian characters to equivalent persian characters.
            </summary>
            <remarks>
            this version of converter use more calculation to convert text and should use for left to right TextField.
            so use this class when your text is dynamic.
            As unity does not support right to left TextField(yet), this algorithm is not perfect and have some bugs. if you search, you can find more persian algorithms
            each has it's own cons and pros. it is on you to use this method.
            in this algorithm you can write text from begin to end without problem, but if you want to edit text and add some character in middle it goes wrong.
            </remarks>
        </member>
        <member name="M:Skill.Framework.Text.PersianTextFieldConverter.#ctor(Skill.Framework.Text.IPersianCharacterMap,System.Int32)">
            <summary>
            Create a PersianTextConverter
            </summary>
            <param name="characterMap">Character mapping information for persian language</param>
            <param name="maxLength">Maximum length of text ( for better performance)</param>
        </member>
        <member name="M:Skill.Framework.Text.PersianTextFieldConverter.Convert(System.String)">
            <summary>
            Convert specified text to equivalent persian text
            </summary>
            <param name="text">Text to convert</param>
            <returns>Converted text</returns>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextFieldConverter.CharacterMap">
            <summary>
            IPersianCharacterMap provided for this converter
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextFieldConverter.MaxLength">
            <summary>
            Maximum length of text ( for better performance)
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextFieldConverter.LastConvertedText">
            <summary>
            Gets last converted text by this converter and set it when you want to continue editing text.
            for example when load profile name and you want edit it again.
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextFieldConverter.ConvertLigature">
            <summary>
            Whether convert لا and الله to one equivalent character. (default false)
            </summary>
        </member>
        <member name="P:Skill.Framework.Text.PersianTextFieldConverter.TextToSave">
            <summary>
            This is reversed text to save.
            </summary>
            <remarks>
            When we set text of TextField for first time the converter does not know that this text reversed before
            so it will reverse it and the result in TextFiled gets wrong.
            </remarks>
        </member>
        <member name="T:Skill.Framework.Text.PersianCharacterForm">
            <summary>
            Defines forms that each persian character can take in a word
            </summary>
        </member>
        <member name="F:Skill.Framework.Text.PersianCharacterForm.Initial">
            <summary> Character is first character of word  </summary>
        </member>
        <member name="F:Skill.Framework.Text.PersianCharacterForm.Medial">
            <summary> Character is between and stick to beside characters in word  </summary>
        </member>
        <member name="F:Skill.Framework.Text.PersianCharacterForm.Final">
            <summary> Character is end character of word  </summary>
        </member>
        <member name="F:Skill.Framework.Text.PersianCharacterForm.Isolated">
            <summary> Character is whole word (is alone) </summary>
        </member>
        <member name="T:Skill.Framework.UI.RepeatButton">
            <summary>
            Make a button that is active as long as the user holds it down.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.OnDown">
            <summary>
            when first time button is down
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.OnUp">
            <summary>
            when first time button is up
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.OnRepeat">
            <summary>
            each frame until it gets up
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.#ctor">
            <summary>
            Create an instance of RepeatButton
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.Render">
            <summary>
            Render RepeatButton
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RepeatButton.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. button respond to Enter command
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>   
        </member>
        <member name="P:Skill.Framework.UI.RepeatButton.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.RepeatButton.Down">
            <summary>
            Occurs when first time button is down
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.RepeatButton.Up">
            <summary>
            Occurs when first time button is up
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.RepeatButton.Repeat">
            <summary>
            Occurs each frame until it gets up
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.RowDefinition">
            <summary>
            Defines row-specific properties that apply to Grid elements.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinition.#ctor">
            <summary>
            Initializes a new instance of the RowDefinition class.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.RowDefinition.Change">
            <summary>
            Occurs when any changes happens to definition
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinition.Height">
            <summary>
             Gets the calculated height of a RowDefinition element,
             or sets the GridLength value of a column that is defined by the RowDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinition.MaxHeight">
            <summary>
            Gets or sets a value that represents the maximum height of a RowDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinition.MinHeight">
            <summary>
            Gets or sets a value that represents the minimum height of a RowDefinition.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinition.RenderHeight">
            <summary> Height of row after update layout </summary>
        </member>
        <member name="T:Skill.Framework.UI.RowDefinitionCollection">
            <summary>
            Provides access to an ordered, strongly typed collection of RowDefinition objects.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.#ctor">
            <summary>
            Create a instance of RowDefinitionCollection class
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.Add(Skill.Framework.UI.RowDefinition)">
            <summary>
            Adds a RowDefinition element to a RowDefinitionCollection.
            </summary>
            <param name="value">Identifies the RowDefinition to add to the collection.</param>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.Add(System.Single,Skill.Framework.UI.GridUnitType)">
            <summary>
            Adds a RowDefinition element to a ColumnDefinitionCollection.
            </summary>
            <param name="value"> The initial value of this instance of GridLength. </param>
            <param name="type"> The GridUnitType held by this instance of GridLength. </param>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.Clear">
            <summary>
            Clears the content of the RowDefinitionCollection.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.Contains(Skill.Framework.UI.RowDefinition)">
            <summary>
            Determines whether a given RowDefinition exists within a RowDefinitionCollection.
            </summary>
            <param name="value"> Identifies the RowDefinition that is being tested. </param>
            <returns>true if the RowDefinition exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.CopyTo(Skill.Framework.UI.RowDefinition[],System.Int32)">
            <summary>
             Copies an array of RowDefinition objects to a given index position within a RowDefinitionCollection.
            </summary>
            <param name="array"> An array of RowDefinition objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the RowDefinition objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.Remove(Skill.Framework.UI.RowDefinition)">
            <summary>
            Removes a RowDefinition from a RowDefinitionCollection.
            </summary>
            <param name="value"> The RowDefinition to remove from the collection. </param>
            <returns> true if the RowDefinition was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltRowDefinition;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.Framework.UI.RowDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinitionCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a RowDefinitionCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="E:Skill.Framework.UI.RowDefinitionCollection.Change">
            <summary>
            Occurs when any changes happens to collection (Add, Remove, Clear)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinitionCollection.Count">
            <summary>
            Gets the total number of items within this instance of RowDefinitionCollection.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.RowDefinitionCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a RowDefinitionCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ScrollView">
            <summary>
            Make a scrolling view inside your GUI.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ScrollView.#ctor">
            <summary>
            Create an instance of ScrollView
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ScrollView.BeginRender">
            <summary> Begin Render control's content </summary>
        </member>
        <member name="M:Skill.Framework.UI.ScrollView.EndRender">
            <summary> End Render control's content </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.HorizontalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.VerticalScrollbarStyle">
            <summary>
            Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.ScrollPosition">
            <summary>
            The pixel distance that the view is scrolled in the X and Y directions.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.ScrollX">
            <summary>
            The pixel distance that the view is scrolled in the X direction.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.ScrollY">
            <summary>
            The pixel distance that the view is scrolled in the Y direction.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.ViewRect">
            <summary>
            The rectangle used inside the scrollview.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.AlwayShowHorizontal">
            <summary>
            Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when clientRect is wider than position.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.AlwayShowVertical">
            <summary>
            Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when clientRect is taller than position.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.HandleScrollWheel">
            <summary>
            Optional parameter to handle ScrollWheel
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.ScrollbarThickness">
            <summary>
            Gets or sets thikness of vertical scrollbar to consider when calculating scrollview area (default is 16)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ScrollView.Padding">
            <summary>
            Gets or sets the padding inside a control.
            </summary>
            <returns>
            The amount of space between the content of a Panel
            and its Margin or Border.
            The default is a thickness of 0 on all four sides.
            </returns>
        </member>
        <member name="T:Skill.Framework.UI.SelectionGrid">
            <summary>
            Make a grid of buttons.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGrid.OnSelectedChanged">
            <summary>
            when selected item changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGrid.#ctor">
            <summary>
            Create an instance of SelectionGrid
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGrid.Render">
            <summary>
            Render SelectionGrid
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGrid.Items">
            <summary>
            Grid items
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGrid.SelectedIndex">
            <summary>
            Gets or sets Selected grid item index
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGrid.SelectedOption">
            <summary>
            Gets or sets Selected grid item
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGrid.XCount">
            <summary> How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.</summary>
        </member>
        <member name="E:Skill.Framework.UI.SelectionGrid.SelectedChanged">
            <summary>
            Occurs when selected item changed
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.SelectionGridItem">
            <summary>
            An item to show on the grid buttons
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItem.OnSelected">
            <summary>
            When item first got selected
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItem.OnUnselected">
            <summary>
            When item first time item lost selected
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItem.#ctor(System.String)">
            <summary>
            Create a SelectionGridItem
            </summary>
            <param name="text">text of content</param>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItem.Content">
            <summary>
            text, image and tooltips for the grid button.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItem.Name">
            <summary> Optional name </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItem.Index">
            <summary> Index of item in collection</summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItem.UserData">
            <summary> UserData  </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItem.IsSelected">
            <summary>
            is item selected
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.SelectionGridItem.Selected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.SelectionGridItem.Unselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.SelectionGridItemCollection">
            <summary>
            A collection of SelectionGridItem
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.#ctor">
            <summary>
            Create a SelectionGridItemCollection
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.RefreshContents">
            <summary>
            Meka sure that Contents are valid. call this when change content of an item after add in collection
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.Add(Skill.Framework.UI.SelectionGridItem)">
            <summary>
            Adds a SelectionGridItem element to a SelectionGridItemCollection.
            </summary>
            <param name="item">Identifies the SelectionGridItem to add to the collection.</param>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.Clear">
            <summary>
            Clears the content of the SelectionGridItemCollection.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.Contains(Skill.Framework.UI.SelectionGridItem)">
            <summary>
            Determines whether a given RowDefinition exists within a SelectionGridItemCollection.
            </summary>
            <param name="item"> Identifies the SelectionGridItem that is being tested. </param>
            <returns>true if the SelectionGridItem exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.CopyTo(Skill.Framework.UI.SelectionGridItem[],System.Int32)">
            <summary>
             Copies an array of SelectionGridItem objects to a given index position within a SelectionGridItemCollection.
            </summary>
            <param name="array"> An array of SelectionGridItem objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the SelectionGridItem objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.Remove(Skill.Framework.UI.SelectionGridItem)">
            <summary>
            Removes a SelectionGridItem from a SelectionGridItemCollection.
            </summary>
            <param name="item"> The SelectionGridItem to remove from the collection. </param>
            <returns> true if the SelectionGridItem was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltSelectionGridItem;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.Framework.UI.SelectionGridItemCollection.IndexOf(Skill.Framework.UI.SelectionGridItem)">
            <summary>
            return first occurence index of specified SelectionGridItem
            </summary>
            <param name="item">item to find</param>
            <returns>
            > 0 index of SelectionGridItem; otherwise -1.
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItemCollection.Contents">
            <summary>
            Array of item's contents
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItemCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a SelectionGridItemCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItemCollection.Count">
            <summary>
            Gets the total number of items within this instance of SelectionGridItemCollection.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.SelectionGridItemCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a SelectionGridItemCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Size">
            <summary>
            Implements a structure that is used to describe the Size of an object.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Size.op_Equality(Skill.Framework.UI.Size,Skill.Framework.UI.Size)">
            <summary>
            Compares two instances of Size for equality.
            </summary>
            <param name="size1">The first instance of Skill.UI.Size to compare.</param>
            <param name="size2"> The second instance of Skill.UI.Size to compare.</param>
            <returns>true if the two instances of Skill.UI.Size are equal; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.op_Inequality(Skill.Framework.UI.Size,Skill.Framework.UI.Size)">
            <summary>
            Compares two instances of Skill.UI.Size for inequality.
            </summary>
            <param name="size1">The first instance of Skill.UI.Size to compare.</param>
            <param name="size2">The second instance of Skill.UI.Size to compare.</param>
            <returns>true if the instances of Skill.UI.Size are not equal; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.Equals(Skill.Framework.UI.Size,Skill.Framework.UI.Size)">
            <summary>
            
            </summary>
            <param name="size1"></param>
            <param name="size2"></param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.Equals(System.Object)">
            <summary>
            Compares an object to an instance of Skill.UI.Size for equality.
            </summary>
            <param name="o">The System.Object to compare.</param>
            <returns>true if the sizes are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.Equals(Skill.Framework.UI.Size)">
            <summary>
            Compares a value to an instance of Skill.UI.Size for equality.
            </summary>
            <param name="value">The size to compare to this current instance of Skill.UI.Size.</param>
            <returns>true if the instances of Skill.UI.Size are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.GetHashCode">
            <summary>
            Gets the hash code for this instance of Skill.UI.Size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.ToString">
            <summary>
             The hash code for this instance of Skill.UI.Size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the Skill.UI.Size structure and assigns it an initial width and height.
            </summary>
            <param name="width">The initial width of the instance of Skill.UI.Size.</param>
            <param name="height">The initial height of the instance of Skill.UI.Size.</param>
        </member>
        <member name="M:Skill.Framework.UI.Size.op_Explicit(Skill.Framework.UI.Size)~UnityEngine.Vector2">
            <summary>
            Convet a Size to a UnityEngine.Vector2
            </summary>
            <param name="size">size to convert</param>
            <returns>Size</returns>
        </member>
        <member name="M:Skill.Framework.UI.Size.op_Explicit(UnityEngine.Vector2)~Skill.Framework.UI.Size">
            <summary>
            Convet a UnityEngine.Vector2 to a Size
            </summary>
            <param name="vector"> vector to convert </param>
            <returns>Skill.UI.Size</returns>
        </member>
        <member name="P:Skill.Framework.UI.Size.Empty">
            <summary>
            Empty size
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Size.IsEmpty">
            <summary>
            Gets a value that represents a static empty Skill.UI.Size.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Size.Width">
            <summary>
            Gets or sets the Skill.UI.Size.Width of this instance of Skill.UI.Size.
            </summary>
            <returns>
            The Skill.UI.Size.Width of this instance of Skill.UI.Size. The default value is 0. The value cannot be negative.
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.Size.Height">
            <summary>
            Gets or sets the Skill.UI.Size.Height of this instance of Skill.UI.Size.
            </summary>
            <returns> The Skill.UI.Size.Height of this instance of Skill.UI.Size. The default is 0. The value cannot be negative. </returns>
        </member>
        <member name="T:Skill.Framework.UI.Slider">
            <summary> A slider the user can drag to change a value between a min and a max. </summary>
        </member>
        <member name="M:Skill.Framework.UI.Slider.OnValueChanged">
            <summary>
            Occurs when value of slider changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Slider.#ctor">
            <summary>
            Create an instance of Slider
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Slider.Render">
            <summary>
            Render Slider
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Slider.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. slider respond to direction commands
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>   
        </member>
        <member name="P:Skill.Framework.UI.Slider.ThumbStyle">
            <summary>
            The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.Orientation">
            <summary>
            Orientation of slider
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.DrawCenter">
            <summary>
            Unity draw slider at top of RenderArea, to bring it to center set DrawCenter to witdh of slider.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.KeyStep">
            <summary>
            Amount of change when user press direction button (only used in HandleCommand method)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.Value">
            <summary>
            The value the slider shows. This determines the position of the draggable thumb.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.Slider.ValueChanged">
            <summary>
            Occurs when value of slider changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.MinValue">
            <summary>
            Minimum valud of slider
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Slider.MaxValue">
            <summary>
            Maximum valud of slider
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.TextArea">
            <summary>
            Make a Multi-line text area where the user can edit a string.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextArea.OnTextChanged">
            <summary>
            Occurs when text of TextArea changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextArea.#ctor">
            <summary>
            Create an TextArea
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextArea.Render">
            <summary>
            Render TextArea
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.TextArea.Text">
            <summary>
            Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.TextArea.TextChanged">
            <summary>
            Occurs when text of TextArea changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.TextArea.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.TextField">
            <summary>
            Make a single-line text field where the user can edit a string.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextField.OnTextChanged">
            <summary>
            Occurs when text of TextField changed
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextField.#ctor">
            <summary>
            Create an instance of TextField
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.TextField.Render">
            <summary>
            Render TextField
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.TextField.Text">
            <summary>
            Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.TextField.TextChanged">
            <summary>
            Occurs when text of TextField changed
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.TextField.MaxLength">
            <summary>
            The maximum length of the string. If left out, the user can type for ever and ever.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.TextField.Converter">
            <summary>
            Text conveter for other languages (like persian)
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Thickness">
            <summary>
            Describes the thickness of a frame around a rectangle. 
            Four float values describe the Thickness.Left, Thickness.Top, Thickness.Right, and Thickness.Bottom sides of the rectangle, respectively.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the Thickness structure that has the specified uniform length on each side.
            </summary>
            <param name="uniformLength">The uniform length applied to all four sides of the bounding rectangle.</param>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the Thickness structure that has specific lengths (supplied as a System.Double) applied to each side of the rectangle.
            </summary>
            <param name="left"> The thickness for the left side of the rectangle.</param>
            <param name="top">The thickness for the upper side of the rectangle.</param>
            <param name="right">The thickness for the right side of the rectangle</param>
            <param name="bottom">The thickness for the lower side of the rectangle.</param>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the Thickness structure that has specific lengths (supplied as a System.Double) applied to each side of the rectangle.
            </summary>
            <param name="leftAndRight"> The thickness for the left side and the right side of the rectangle.</param>
            <param name="topAndBottom"> The thickness for the upper side and the lower side of the rectangle.</param>        
        </member>
        <member name="M:Skill.Framework.UI.Thickness.Equals(System.Object)">
            <summary>
            Compares this Thickness structure to another System.Object for equality.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>true if the two objects are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.Equals(Skill.Framework.UI.Thickness)">
            <summary>
             Compares this Thickness structure to another Thickness structure for equality.
            </summary>
            <param name="thickness"> An instance of Thickness to compare for equality.</param>
            <returns>true if the two instances of Thickness are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.GetHashCode">
            <summary>
            Returns the hash code of the structure.
            </summary>
            <returns> A hash code for this instance of Thickness. </returns>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.ToString">
            <summary>
            Returns the string representation of the Thickness structure.
            </summary>
            <returns>A System.String that represents the Thickness value.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.op_Equality(Skill.Framework.UI.Thickness,Skill.Framework.UI.Thickness)">
            <summary>
            Compares the value of two Thickness structures for equality.
            </summary>
            <param name="t1">The first structure to compare.</param>
            <param name="t2">The other structure to compare.</param>
            <returns>true if the two instances of Thickness are equal; otherwise, false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.Thickness.op_Inequality(Skill.Framework.UI.Thickness,Skill.Framework.UI.Thickness)">
            <summary>
            Compares two Thickness structures for inequality.
            </summary>
            <param name="t1">The first structure to compare.</param>
            <param name="t2">The other structure to compare.</param>
            <returns>true if the two instances of Thickness are not equal; otherwise, false.</returns>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Left">
            <summary>
            Gets or sets the width, in pixels, of the left side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Top">
            <summary>
            Gets or sets the width, in pixels, of the upper side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Right">
            <summary>
            Gets or sets the width, in pixels, of the right side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Bottom">
            <summary>
             Gets or sets the width, in pixels, of the lower side of the bounding rectangle.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Horizontal">
            <summary>
            Left + Right
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Vertical">
            <summary>
            Top + Bottom
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Thickness.Empty">
            <summary>
            zero Thickness
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.IToggleButton">
            <summary> ToggleButton interface </summary>
        </member>
        <member name="E:Skill.Framework.UI.IToggleButton.Checked">
            <summary> Occurs when a ToggleButton is checked. </summary>
        </member>
        <member name="E:Skill.Framework.UI.IToggleButton.Unchecked">
            <summary> Occurs when a ToggleButton is unchecked. </summary>
        </member>
        <member name="P:Skill.Framework.UI.IToggleButton.IsChecked">
            <summary> Gets or sets whether the ToggleButton is checked. </summary>
        </member>
        <member name="T:Skill.Framework.UI.ToggleButton">
            <summary>
            Make an on/off toggle button.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.OnChecked">
            <summary>
            Occurs when a ToggleButton is checked.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.OnUnchecked">
            <summary>
            Occurs when a ToggleButton is unchecked.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.OnChanged">
            <summary>
            when a ToggleButton is Changed.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.#ctor">
            <summary>
            Create an instance of ToggleButton
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.Render">
            <summary>
            Render ToggleButton
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToggleButton.HandleCommand(Skill.Framework.UI.UICommand)">
            <summary>
            Handle specified command. toggle button respond to Enter command
            </summary>
            <param name="command">Command to handle</param>
            <returns>True if command is handled, otherwise false</returns>   
        </member>
        <member name="P:Skill.Framework.UI.ToggleButton.Content">
            <summary>
            Text, image and tooltip for this button.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToggleButton.IsChecked">
            <summary>
            Gets or sets whether the ToggleButton is checked.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ToggleButton.Checked">
            <summary>
            Occurs when a ToggleButton is checked.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ToggleButton.Unchecked">
            <summary>
            Occurs when a ToggleButton is unchecked.
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ToggleButton.Changed">
            <summary>
            Occurs when a ToggleButton is Changed.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToggleButton.Group">
            <summary>
            only one of ToggleButtons inside a group is checked
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Toolbar">
            <summary>
            Make a toolbar
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Toolbar.#ctor">
            <summary>
            Create a Toolbar
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.Toolbar.Render">
            <summary>
            Render Toolbar
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Toolbar.Items">
            <summary>
            Toolbar buttons
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Toolbar.SelectedIndex">
            <summary>
            gets or sets selected button index
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Toolbar.SelectedOption">
            <summary>
            gets or sets selected button
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ToolbarButton">
            <summary>
            item to show on the toolbar buttons.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButton.OnSelected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButton.OnUnselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButton.#ctor">
            <summary>
            Create a ToolbarButton
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButton.Content">
            <summary>
             text, image and tooltip for the toolbar button.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButton.Index">
            <summary> Index of button </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButton.UserData">
            <summary> UserData  </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButton.Name">
            <summary>
            Optional name for button
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButton.IsSelected">
            <summary>
            is button selected
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ToolbarButton.Selected">
            <summary>
            Occurs When item first got selected
            </summary>
        </member>
        <member name="E:Skill.Framework.UI.ToolbarButton.Unselected">
            <summary>
            Occurs When item first time item lost selected
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.ToolbarButtonCollection">
            <summary>
            A collection of ToolbarButton
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.#ctor">
            <summary>
            Create a ToolbarButtonCollection
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.RefreshContents">
            <summary>
            Meka sure that Contents are valid. call this when change content of an item after add in collection
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.Add(Skill.Framework.UI.ToolbarButton)">
            <summary>
            Adds a ToolbarButton element to a ToolbarButtonCollection.
            </summary>
            <param name="item">Identifies the ToolbarButton to add to the collection.</param>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.Clear">
            <summary>
            Clears the content of the ToolbarButtonCollection.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.Contains(Skill.Framework.UI.ToolbarButton)">
            <summary>
            Determines whether a given RowDefinition exists within a ToolbarButtonCollection.
            </summary>
            <param name="item"> Identifies the ToolbarButton that is being tested. </param>
            <returns>true if the ToolbarButton exists within the collection; otherwise false.</returns>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.CopyTo(Skill.Framework.UI.ToolbarButton[],System.Int32)">
            <summary>
             Copies an array of ToolbarButton objects to a given index position within a ToolbarButtonCollection.
            </summary>
            <param name="array"> An array of ToolbarButton objects. </param>
            <param name="arrayIndex"> Identifies the index position within array to which the ToolbarButton objects are copied. </param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- The number of elements in the source System.Collections.ICollection is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.Remove(Skill.Framework.UI.ToolbarButton)">
            <summary>
            Removes a ToolbarButton from a ToolbarButtonCollection.
            </summary>
            <param name="item"> The ToolbarButton to remove from the collection. </param>
            <returns> true if the ToolbarButton was found in the collection and removed; otherwise, false. </returns>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator;ltToolbarButton;gt that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An System.Collections.IEnumerator object that can be used to iterate through the collection. </returns>
        </member>
        <member name="M:Skill.Framework.UI.ToolbarButtonCollection.IndexOf(Skill.Framework.UI.ToolbarButton)">
            <summary>
            return first occurence index of specified ToolbarButton
            </summary>
            <param name="item">item to find</param>
            <returns>
            > 0 index of ToolbarButton; otherwise -1.
            </returns>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButtonCollection.Contents">
            <summary>
            Array of item's contents
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButtonCollection.Item(System.Int32)">
            <summary>
            Gets a value that indicates the current item within a ToolbarButtonCollection.
            </summary>
            <param name="index"> The current item in the collection.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index position in the collection.</exception>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButtonCollection.Count">
            <summary>
            Gets the total number of items within this instance of ToolbarButtonCollection.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.ToolbarButtonCollection.IsReadOnly">
            <summary>
            Gets a value that indicates whether a ToolbarButtonCollection is read-only.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.UniformGrid">
            <summary>
            Provides a way to arrange content in a grid where all the cells in the grid have the same size.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.UniformGrid.#ctor">
            <summary>
            Initializes a new instance of the UniformGrid class.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.UniformGrid.UpdateLayout">
            <summary>
             Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.UniformGrid.Columns">
            <summary> Gets or sets the number of columns that are in the grid. </summary>
        </member>
        <member name="P:Skill.Framework.UI.UniformGrid.Rows">
            <summary> Gets or sets the number of rows that are in the grid. </summary>
        </member>
        <member name="T:Skill.Framework.UI.VerticalAlignment">
            <summary>
            Describes how a child element is vertically positioned or stretched within a parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.VerticalAlignment.Top">
            <summary>
            The child element is aligned to the top of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.VerticalAlignment.Center">
            <summary>
            The child element is aligned to the center of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.VerticalAlignment.Bottom">
            <summary>
            The child element is aligned to the bottom of the parent's layout slot.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.VerticalAlignment.Stretch">
            <summary>
            The child element stretches to fill the parent's layout slot.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Visibility">
            <summary>
            Specifies the display state of an element.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Visibility.Visible">
            <summary>
            Display the element.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Visibility.Hidden">
            <summary>
            Do not display the element, but reserve space for the element in layout.
            </summary>
        </member>
        <member name="F:Skill.Framework.UI.Visibility.Collapsed">
            <summary>
            Do not display the element, and do not reserve space for it in layout.
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.Window">
            <summary>
            Make a popup window.
            </summary>
            <remarks>
            you have to set useGuiLayout = true to make window render correctly
            </remarks>     
        </member>
        <member name="M:Skill.Framework.UI.Window.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Frame class.
            </summary>        
            <param name="name">Valid and unique name of frame</param>
        </member>
        <member name="M:Skill.Framework.UI.Window.DrawControls">
            <summary>
            Draw controls inside window
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.Id">
            <summary>
            A unique ID to use for each window. This is the ID you'll use to interface to.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.IsDraggable">
            <summary>
            Whether the window Is draggable or not? (Do not update position of window each frame when this value is true.)
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.FullDraggable">
            <summary>
            True if you want to have the entire window background to act as a drag area, otherwise false to use DraggableArea
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.DraggableArea">
            <summary>
            the part of the window that can be dragged. This is clipped to the actual window.
            </summary>        
        </member>
        <member name="P:Skill.Framework.UI.Window.Title">
            <summary>
            Title of window
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.Style">
            <summary>
            The style to use. If null, the style from the current GUISkin is used.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.Window.LocalGrid">
            <summary>
            Grid rendered in local space
            </summary>
        </member>
        <member name="T:Skill.Framework.UI.WrapImage">
            <summary>
            Draw a wrapped texture
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.WrapImage.#ctor">
            <summary>
            Create an instance of WrapImage
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.WrapImage.Render">
            <summary> Render Image </summary>
        </member>
        <member name="P:Skill.Framework.UI.WrapImage.Texture">
            <summary> Texture to display. </summary>
        </member>
        <member name="P:Skill.Framework.UI.WrapImage.AlphaBlend">
            <summary> Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display. </summary>
        </member>
        <member name="P:Skill.Framework.UI.WrapImage.WrapU">
            <summary> Enable or Disable Wrap U</summary>
        </member>
        <member name="P:Skill.Framework.UI.WrapImage.WrapV">
            <summary> Enable or Disable Wrap V</summary>
        </member>
        <member name="T:Skill.Framework.UI.WrapPanel">
            <summary>
            Positions child elements in sequential position from left to right, breaking
            content to the next line at the edge of the containing box. Subsequent ordering
            happens sequentially from top to bottom or from right to left, depending
            on the value of the WrapPanel.Orientation property.
            </summary>
        </member>
        <member name="M:Skill.Framework.UI.WrapPanel.UpdateLayout">
            <summary>
            Ensures that all visual child elements of this element are properly updated for layout.
            </summary>
        </member>
        <member name="P:Skill.Framework.UI.WrapPanel.Orientation">
            <summary>
            Gets or sets a value that specifies the dimension in which child content is arranged.
            </summary> 
            <returns>
             An Orientation value that represents the physical orientation of content within the WrapPanel as horizontal or vertical.
             The default value is Orientation.Horizontal.
            </returns>
        </member>
        <member name="T:Skill.Framework.Weapons.ShootMode">
            <summary>
            Number of bullet at each fire command
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ShootMode.Continuous">
            <summary> Continue shooting until out of ammo or stop command.</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ShootMode.One">
            <summary> By each fire command it shoots one bullet.</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ShootMode.Two">
            <summary> By each fire command it shoots two bullets.</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ShootMode.Three">
            <summary> By each fire command it shoots three bullets.</summary>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponShootEventArgs">
            <summary>
            containing Weapon shoot event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.WeaponShootEventArgs.#ctor(System.Int32)">
            <summary>
            Create WeaponShootEventArgs
            </summary>
            <param name="consumedAmmo"> Amount of consumed ammo </param>
        </member>
        <member name="P:Skill.Framework.Weapons.WeaponShootEventArgs.ConsumedAmmo">
            <summary> Amount of consumed ammo </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponReloadEventArgs">
            <summary>
            containing Weapon reload event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.WeaponReloadEventArgs.#ctor(System.Boolean)">
            <summary>
            Create WeaponReloadEventArgs
            </summary>
            <param name="isComplete"> Is complete reload (when clip is empty and reload happened) </param>
        </member>
        <member name="P:Skill.Framework.Weapons.WeaponReloadEventArgs.IsComplete">
            <summary> Is complete reload (when clip is empty and reload happened) </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponChangeProjectileEventArgs">
            <summary>
            containing Weapon change projectile event data.
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.WeaponChangeProjectileEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create WeaponChangeProjectileEventArgs
            </summary>
            <param name="previousProjectileIndex">Index of previous projectile</param>
            <param name="newProjectileIndex">Index of new selected projectile</param>
        </member>
        <member name="P:Skill.Framework.Weapons.WeaponChangeProjectileEventArgs.PreviousProjectileIndex">
            <summary> Index of previous projectile </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.WeaponChangeProjectileEventArgs.NewProjectileIndex">
            <summary> Index of new selected projectile </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponShootEventHandler">
            <summary>
            Handle weapon shoot event
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="args"> An WeaponShootEventHandler that contains shoot event data. </param>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponReloadEventHandler">
            <summary>
            Handle weapon reload event
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="args"> An WeaponReloadEventHandler that contains reload event data. </param>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponChangeProjectileEventHandler">
            <summary>
            Handle weapon change projectile event
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="args"> An WeaponChangeProjectileEventHandler that contains projectile change event data. </param>
        </member>
        <member name="T:Skill.Framework.Weapons.Weapon">
            <summary>
            Defines base class for weapons
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.Name">
            <summary> Name of weapon </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.Profile">
            <summary> Profile of weapon. Useful for AnimationTree </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.Projectiles">
            <summary> Projectiles. should contain at least one projectile </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.EmptySound">
            <summary> sound to play on empty fire </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.Mode">
            <summary> Number of shot in each fire command. </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.CanThrow">
            <summary> Can player toss his weapon out? Typically false for default inventory. </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.AutoReload">
            <summary> Reload automatically when clip is empty</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Weapon.Spread">
            <summary> Error in shooting </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.AddIgnoreCollider(UnityEngine.Collider)">
            <summary>
            Add collider to ignored by bullets
            </summary>
            <param name="collider">Collider to ignore</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.RemoveIgnoreCollider(UnityEngine.Collider)">
            <summary>
            remove collider to ignored by bullets
            </summary>
            <param name="collider">Collider to ignore</param>
            <returns></returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ClearIgnoreColliders">
            <summary>
            Remove all ignored colliders
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.OnShoot">
            <summary> Occurs when a shoot happpened </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.PrepareBullet(Skill.Framework.Weapons.Bullet)">
            <summary>
            Prepare bullet parameters just after spawn
            </summary>
            <param name="bullet">Bullet to prepare</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ShootBullets(System.Int32)">
            <summary>
            Instantiate a bullet and throw it at correct direction and force 
            </summary>
            <param name="bulletCount">Number of bullet to shoot</param>
            <returns> Array of spawned bullets </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.OnReload(System.Boolean)">
            <summary>
            Occurs when a reload happpened
            </summary>
            <param name="isCompleteReload"> Is complete reload (when clip is empty and reload happened) </param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.OnReloadCompleted">
            <summary>
            Occurs when a reload completed and clip refills
            </summary>        
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.OnProjectileChanged(System.Int32,System.Int32)">
            <summary>
            Occurs when projectile of weapon changes
            </summary>
            <param name="previousProjectileIndex">Index of previous projectile</param>
            <param name="newProjectileIndex">Index of new selected projectile</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.GetReferences">
            <summary>
            Get required references
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.Start">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ConsumeAmmo">
            <summary>
            Consumes ammunition when firing a shot.
            Subclass me to define weapon ammunition consumption. 
            </summary>
            <returns> Amount actually consummed. </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.AddAmmo(System.Int32,System.Int32)">
            <summary>
            Add ammo to weapon
            Subclass me to define ammo addition rules.        
            </summary>
            <param name="damageType"> Type of ammo. if this weapon contains a projectile with this type of ammo, then add ammo  </param>
            <param name="amount">Amount of ammo to add</param>
            <returns> Amount actually added. (In case magazine is already full and some ammo is left) </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.SetBusy(System.Single)">
            <summary>
            Set weapon busy
            </summary>
            <param name="busyTime"> How long to be busy </param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.RequestReload">
            <summary>
            Request a reload in next update
            </summary>
            <returns>True if request accepted, otherwise false</returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ChangeProjectile(System.String)">
            <summary>
            Change projectile
            </summary>
            <param name="projectileName">Name of projectile to change</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ChangeProjectile(System.Int32)">
            <summary>
            Change projectile
            </summary>
            <param name="projectileIndex">Index of projectile to change</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.StartFire">
            <summary>
            Start fire command
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.StopFire">
            <summary>
            Stop fire command
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ShootCurveBullets(System.Int32)">
            <summary>
            Instantiate a bullet and throw it at correct direction and force 
            </summary>
            <param name="bulletCount">Number of bullet to shoot</param>
            <returns> Array of spawned bullets </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ShootStraightLineBullets(System.Int32)">
            <summary>
            Instantiate a bullet and throw it at correct direction and force 
            </summary>
            <param name="bulletCount">Number of bullet to shoot</param>
            <returns> Array of spawned bullets </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Weapon.ShootRaycastBullets(System.Int32)">
            <summary>
            Instantiate a bullet and throw it at correct direction and force 
            </summary>
            <param name="bulletCount">Number of bullet to shoot</param>
            <returns> Array of spawned bullets </returns>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.State">
            <summary> State of weapon </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.HasAmmo">
            <summary> This function checks to see if the weapon has any ammo available </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.IsFiring">
            <summary> Is trigger down and weapon keeps firing </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.SelectedProjectile">
            <summary> Current equipped projectile </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.SelectedProjectileIndex">
            <summary> Current equipped projectile </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.CanFire">
            <summary> Can fire immediately? </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.SelectedClipAmmo">
            <summary> Number of ammo in current clip </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.Target">
            <summary> Target of weapon. can be setted by Controller </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.DamageFactor">
            <summary> Gets or set damage factor  </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Weapon.ThrowCurveProjectilesOnTarget">
            <summary> If true, weapon try to calculate initial speed of curve projectiles to hit Target(if valid) </summary>
        </member>
        <member name="E:Skill.Framework.Weapons.Weapon.Shoot">
            <summary> Occurs when a shoot happpened </summary>
        </member>
        <member name="E:Skill.Framework.Weapons.Weapon.Reload">
            <summary> Occurs when a reload happpened </summary>
        </member>
        <member name="E:Skill.Framework.Weapons.Weapon.ReloadCompleted">
            <summary> Occurs when a reload completed and clip refills </summary>
        </member>
        <member name="E:Skill.Framework.Weapons.Weapon.ProjectileChanged">
            <summary> Occurs when projectile of weapon changes </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.Bullet">
            <summary>
            Bullet to use by weapons. if bullet has RigidBody with low speed controlled by physics engine. it is possible to enable gravity to fall down after spawn or
            disable gravity to go in straight direction. The weapon do AddForce to RigidBody bullets at spawn time.
            if collider is a trigger the bullet check collision by OnTriggerEnter method
            if collider is not a trigger the bullet check collision by OnCollisionEnter method
            </summary>    
        </member>
        <member name="F:Skill.Framework.Weapons.Bullet.Explosions">
            <summary> Object to spawn on collision </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Bullet.ExplosionPos">
            <summary> Position of explosion </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Bullet.LifeTime">
            <summary>
            Lift time of bullet after spawn. A time with this value begins OnEnable and destroy gameobject when timer end. ( zero or negative for infinit lift time)
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.StartJourney">
            <summary>
            Called by weapon when initialize bullet
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.
            </summary>
            <param name="collision"> Collision information</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.
            </summary>
            <param name="other"> other collider</param>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.IsCollisionAccepted(UnityEngine.Collider)">
            <summary>
            Allow subclass to filter collsions. it is possible to filter collisions by tags based on whether this bullet shooted by player/friend or
            shooted by an enemy.
            </summary>
            <param name="other"> other collider</param>
            <returns>True if accepted, false for rejected</returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.IsCollisionAccepted(UnityEngine.Collision)">
            <summary>
            Allow subclass to filter collsions. it is possible to filter collisions by tags based on whether this bullet shooted by player/friend or
            shooted by an enemy.
            </summary>
            <param name="collision">Collision</param>
            <returns>True if accepted, false for rejected</returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.GetExplosion(UnityEngine.Collider)">
            <summary>
            Allow subclass to filter explosion particle based on collider bullet hit with
            by default return random explosion if exist
            </summary>
            <param name="collider">The collider that bullet hit with (can be null)</param>
            <returns>valid GameObjct if explosion required, otherwise null</returns>
        </member>
        <member name="M:Skill.Framework.Weapons.Bullet.OnDie(UnityEngine.Collider)">
            <summary>
            Call this when bullet reach end of range or hit something or out of life time
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Shooter">
            <summary>
            The GameObject that shoots this bullet. usually it is Controller of weapon.
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Damage">
            <summary>
            Amount of damage caused by this bullet.
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Speed">
            <summary>
            Speed of bullet in air. (should be setted by weapon)
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Direction">
            <summary>
            Direction of bullet in air. (should be setted by weapon)
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Range">
            <summary>
            Range of bullet after spawn. (should be setted by weapon)
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.UserData">
            <summary> User Data </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.DamageType">
            <summary> Damage Type of projectil</summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Bullet.Target">
            <summary> Target of projectile </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.MuzzleFlash">
            <summary>
            A muzzle flash in front of weapon at fire time.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Weapons.MuzzleFlash.Weapon">
            <summary> Weapon that own's this muzzle flash </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.MuzzleFlash.LifeTime">
            <summary> Time of muzzle flash </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.MuzzleFlash.MinScale">
            <summary> Minmum value of random scale </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.MuzzleFlash.MaxScale">
            <summary> Maxmum value of random scale </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.MuzzleFlash.OnEnable">
            <summary>
            This function is called when the object becomes enabled and active.
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.MuzzleFlash.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.MuzzleFlash.HookEvents">
            <summary>
            Hoot required events
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.MuzzleFlash.UnhookEvents">
            <summary>
            Unhoot hooked events
            </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.InitialCurveProjectileRotation">
            <summary>
            Defines rotation of curve projectile when spawned by weapon
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.InitialCurveProjectileRotation.Identity">
            <summary> Quaternion.identity </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.InitialCurveProjectileRotation.Forward">
            <summary> Forward of spawn point </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.InitialCurveProjectileRotation.AbsoluteCustom">
            <summary> custom rotation </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.InitialCurveProjectileRotation.RelativeCustom">
            <summary> custom local rotation </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.CurveProjectileParams">
            <summary>
            Parameters needed by weapon when shooting Curve projectiles
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.CurveProjectileParams.ThrowAngle">
            <summary> Angle relative to direction to throw bullets. </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.CurveProjectileParams.InitialRotation">
            <summary> Rotation of bulet when spawn</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.CurveProjectileParams.Rotation">
            <summary> Custom Rotation of bulet when InitialRotation is Custom</summary>
        </member>
        <member name="P:Skill.Framework.Weapons.CurveProjectileParams.TangentThrowAngle">
            <summary> Retrieves precalculated Mathf.Tan(ThrowAngle) </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.RaycastBullet">
            <summary>
            A very fast bullet and goes in a straight direction. this bullet check collisions by doing a raycast in travelled distance in current frame.
            </summary>    
        </member>
        <member name="T:Skill.Framework.Weapons.StraightLineBullet">
            <summary>
            This bullet goes in a straight direction.
            </summary>    
        </member>
        <member name="F:Skill.Framework.Weapons.StraightLineBullet.DamageFallOf">
            <summary>
            Amount of damage fall of per unit.
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.StraightLineBullet.MinDamage">
            <summary>
            Damage of bullet do not be lower that this do to fallof
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.StraightLineBullet.Gravity">
            <summary>
            Gravity of bullet when rigidbody.isKinematic
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.StraightLineBullet.RotationFactor">
            <summary>
            How to rotate towards direction. (when rigidbody.isKinematic and Gravity != 0)
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.StraightLineBullet.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.StraightLineBullet.StartJourney">
            <summary>
            Called by weapon when initialize bullet
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.StraightLineBullet.TravelledDistance">
            <summary>
            The travelled distance of bullet after spawn.
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.StraightLineBullet.LayerMask">
            <summary>
            Layers to raycast. (should be setted by weapon)
            </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.StraightLineBullet.Damage">
            <summary>
            Amount of damage caused by this bullet.
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.RaycastBullet.Update">
            <summary>
            Update
            </summary>
        </member>
        <member name="M:Skill.Framework.Weapons.RaycastBullet.CreateHitInfo(UnityEngine.Collider)">
            <summary>
            Create a default RaycastHitInfo. subclass can override this method to create a new type of RaycastHitInfo
            </summary>
            <param name="other">The collider that this bullet hits with</param>
            <returns> RaycastHitInfo </returns>
        </member>
        <member name="M:Skill.Framework.Weapons.RaycastBullet.StartJourney">
            <summary>
            Called by weapon when initialize bullet
            </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.ProjectileType">
            <summary>
            Type of bullet
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ProjectileType.StraightLine">
            <summary>
            A weapon that uses velocity for rigidbody bullets and speed/Direction for none rigidbody bullets to shoot bullets.
            The RigidBody of bullets use no gravity to go straight.
            If Target of weapon is valid it shoots on Target, otherwise shoots in front direction.
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ProjectileType.Raycast">
            <summary>        
            use raycasting to shoot bullets and needs StraightLineBullet.
            If Target of weapon is valid it shoots on Target, otherwise shoots in front direction.        
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.ProjectileType.Curve">
            <summary>
            Bullet of this projectile needs rigidbody and use gravity to move.
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.Name">
            <summary> Name of projectile </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.SpawnPoint">
            <summary> where to spawn bullets. usually it is a point in child of weapon that moves by weapon </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.BulletPrefab">
            <summary> A prefab that has a Bullet script component </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.Type">
            <summary> Type of bullet. each type needs deferent parameters and components</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.FireSounds">
            <summary> Sound to play on fire </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.ReloadSound">
            <summary> Sound to play on reload </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.CompleteReloadSound">
            <summary> Sound to play on reload when clip is empty and complete reload needed</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.InitialSpeed">
            <summary> Initial speed of bullet at spawn time </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.DamagePerSecond">
            <summary> </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.ClipSize">
            <summary> Size of eack clip </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.MaxAmmo">
            <summary> Maximum number of ammo count </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.DefaultAmmo">
            <summary> Default ammo count </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.Range">
            <summary> Range of bullet </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.EquipTime">
            <summary> How long does it take to switch to this projectile </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.ReloadTime">
            <summary> How long does it take to change a clip </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.CompleteReloadTime">
            <summary> How long does it take to change a clip when current clip is empty and complete reload needed </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.FireInterval">
            <summary> Holds the amount of time a single shot takes </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.InstantHitDamage">
            <summary> How much damage does a given instanthit shot do </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.DamageType">
            <summary> DamageTypes for Instant Hit Weapons </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.InfinitClip">
            <summary> whether this projectile has infinite clips( reload happens but no ammo consumes ). </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.InfinitAmmo">
            <summary> whether this projectile has infinite ammo.( no reload no consume ammo ).   </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.CurveParams">
            <summary> Curve projectile specific parameters </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.LayerMask">
            <summary> Layer mask to use in raycasting </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.Projectile.HitAtSpawn">
            <summary> Whether weapon check hit posint of this bullet at spawn time or let bullet check hits itself.</summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Projectile.ClipAmmo">
            <summary> Number of ammo in current clip </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Projectile.Ammo">
            <summary> Total number of ammo without clip ammo </summary>
        </member>
        <member name="P:Skill.Framework.Weapons.Projectile.TotalAmmo">
            <summary> Total number of ammo </summary>
        </member>
        <member name="T:Skill.Framework.Weapons.WeaponState">
            <summary>
            Defines state of weapon
            </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.WeaponState.Ready">
            <summary> Weapon is ready to fire </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.WeaponState.Refill">
            <summary> Weapon is refill another ammo. infact this is FireInterval between shots</summary>
        </member>
        <member name="F:Skill.Framework.Weapons.WeaponState.Reloading">
            <summary> Weapon is reloading </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.WeaponState.ChangeProjectile">
            <summary> Weapon is changing projectile </summary>
        </member>
        <member name="F:Skill.Framework.Weapons.WeaponState.Busy">
            <summary> Weapon is busy for other reason </summary>
        </member>
    </members>
</doc>
